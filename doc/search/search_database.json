var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program name = \"SEP-stochastic\"\nversion = \"0.0.1\"\nauthor = \"Ming Zhang and contributors\" executable name = \"2damrhistss\" executable name = \"maggrid\" executable name = \"mapb2s\" executable name = \"combiner\" executable name = \"seedgen\" executable name = \"sim3d\" executable name = \"shockfront\" [extras.ford]\nproject = \"SEP-Stochastic\"\nsummary = \"TODO\"\nversion = \"0.0.0\"\nauthor = \"Ming Zhang and contributors\"\nsource = false\nincl_src = false\nprint_creation_date = true\ncreation_date = \"%Y-%m-%d %H:%M %z\"\nsort = \"permission-alpha\"","tags":"home","url":"index.html"},{"title":"gregorian_date – Fortran Program ","text":"type, public :: gregorian_date Components Type Visibility Attributes Name Initial integer, public :: iday integer, public :: month integer, public :: iyear integer, public :: iyday","tags":"","url":"type/gregorian_date.html"},{"title":"rk4 – Fortran Program","text":"public  function rk4(f, x0, y0, h, odefun_param) result(yout) Arguments Type Intent Optional Attributes Name procedure( odefun ) :: f real(kind=real64) :: x0 real(kind=real64) :: y0 (:) real(kind=real64) :: h real(kind=real64) :: odefun_param Return Value real(kind=real64), allocatable, (:)","tags":"","url":"proc/rk4.html"},{"title":"odefun – Fortran Program","text":"interface public  function odefun(x, y, p) result(v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y (3) real(kind=real64), intent(in) :: p Return Value real(kind=real64)(3)","tags":"","url":"interface/odefun.html"},{"title":"plgndr – Fortran Program","text":"function plgndr(l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","url":"proc/plgndr.html"},{"title":"factorialratio – Fortran Program","text":"subroutine factorialratio(fac_table) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: fac_table (NS,NS)","tags":"","url":"proc/factorialratio.html"},{"title":"magfield – Fortran Program","text":"subroutine magfield(rvec, b, bmag, cvtu, gbmag, dbbds, srfctrtl, g, h) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rvec (3) real(kind=real64), intent(out) :: b (3) real(kind=real64), intent(out) :: bmag real(kind=real64), intent(out) :: cvtu (3) real(kind=real64), intent(out) :: gbmag (3) real(kind=real64), intent(out) :: dbbds real(kind=real64), intent(in) :: srfctrtl (NS,NS) real(kind=real64), intent(in) :: g (0:NS,0:NS) real(kind=real64), intent(in) :: h (0:NS,0:NS)","tags":"","url":"proc/magfield.html"},{"title":"init_aplm – Fortran Program","text":"subroutine init_aplm(alp_arr, dalp_arr, d2alp_arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: alp_arr (0:N_THETA,0:NS,0:NS) real(kind=real64), intent(out) :: dalp_arr (0:N_THETA,0:NS,0:NS) real(kind=real64), intent(out) :: d2alp_arr (0:N_THETA,0:NS,0:NS)","tags":"","url":"proc/init_aplm.html"},{"title":"gasdev – Fortran Program","text":"public impure function gasdev(idum) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idum Return Value real(kind=real64)","tags":"","url":"proc/gasdev.html"},{"title":"ran2 – Fortran Program","text":"public  function ran2(idum) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idum Return Value real(kind=real64)","tags":"","url":"proc/ran2.html"},{"title":"fl_open – Fortran Program","text":"public  subroutine fl_open(nfl, nsts) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nfl integer, intent(out) :: nsts Common Blocks record_nodes (subroutine) read_param (subroutine) \">\n           common /filnm/ Type Attributes Name Initial character(len=256) :: pclfil character(len=256) :: finfil character(len=256) :: sucfil character(len=256) :: nodesfil character(len=256) :: anfil character(len=256) :: anstfil common /nfinish/ Type Attributes Name Initial integer :: nfinish sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /rankstr/ Type Attributes Name Initial character(len=2) :: rankstr","tags":"","url":"proc/fl_open.html"},{"title":"record_nodes – Fortran Program","text":"public  subroutine record_nodes(nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes Common Blocks fl_open (subroutine) read_param (subroutine) \">\n           common /filnm/ Type Attributes Name Initial character(len=256) :: pclfil character(len=256) :: finfil character(len=256) :: sucfil character(len=256) :: nodesfil character(len=256) :: anfil character(len=256) :: anstfil","tags":"","url":"proc/record_nodes.html"},{"title":"write_head – Fortran Program","text":"public  subroutine write_head(nfl, nf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfl integer, intent(in) :: nf","tags":"","url":"proc/write_head.html"},{"title":"open_file_from_environment – Fortran Program","text":"public  subroutine open_file_from_environment(env_var_name, fileunit, file_form, file_status) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: env_var_name integer, intent(out) :: fileunit character(len=*), intent(in) :: file_form character(len=*), intent(in), optional :: file_status","tags":"","url":"proc/open_file_from_environment.html"},{"title":"read_param – Fortran Program","text":"public  subroutine read_param(nodes, nseeds) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nodes integer, intent(out), allocatable :: nseeds (:) Common Blocks cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir fl_open (subroutine) record_nodes (subroutine) \">\n           common /filnm/ Type Attributes Name Initial character(len=256) :: pclfil character(len=256) :: finfil character(len=256) :: sucfil character(len=256) :: nodesfil character(len=256) :: anfil character(len=256) :: anstfil get_rlambda (function) set_rlambda (subroutine) \">\n           common /rlambda/ Type Attributes Name Initial real(kind=real64) :: rlambda get_rlambdax (function) set_rlambdax (subroutine) \">\n           common /rlambdax/ Type Attributes Name Initial real(kind=real64) :: rlambdax real(kind=real64) :: rlambday set_rlambda (subroutine) \">\n           common /nlambda/ Type Attributes Name Initial integer :: nlambda split (subroutine) walk3d (subroutine) walk3d (subroutine) walk3d (subroutine) \">\n           common /nlambdaconst/ Type Attributes Name Initial integer :: nlambdaconst set_rlambdax (subroutine) \">\n           common /nlambdax/ Type Attributes Name Initial integer :: nlambdax get_rlambda0 (function) set_rlambda (subroutine) vfunc (subroutine) shockfront (program) sim3d (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu get_rlambdax (function) cofm (subroutine) set_rlambdax (subroutine) shockfront (program) sim3d (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx split (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt fs0 (function) \">\n           common /acc/ Type Attributes Name Initial real(kind=real64) :: ecrmax real(kind=real64) :: ecrmin real(kind=real64) :: ob0 real(kind=real64) :: obw real(kind=real64) :: etinj real(kind=real64) :: fampb real(kind=real64) :: ratkp Namelists Namelist input Variables Name Type Default Description vswSI real(kind=real64) None rsSI real(kind=real64) None bemNT real(kind=real64) None TsunDAY real(kind=real64) None facip real(kind=real64) None Namelist io Variables Name Type Default Description f1n character(len=256) None f2n character(len=256) None Namelist dpdt Variables Name Type Default Description ndpdt integer None Namelist dmumu Variables Name Type Default Description rlambda real(kind=real64) None nlambda integer None ndmumu integer None nlambdaconst integer None Namelist dxx Variables Name Type Default Description rlambdax real(kind=real64) None rlambday real(kind=real64) None ndxx integer None nlambdax integer None Namelist shkacc Variables Name Type Default Description ecrmax real(kind=real64) None ecrmin real(kind=real64) None ob0 real(kind=real64) None obw real(kind=real64) None etinj real(kind=real64) None fampb real(kind=real64) None ratkp real(kind=real64) None","tags":"","url":"proc/read_param.html"},{"title":"read_seeds – Fortran Program","text":"public  subroutine read_seeds(n, nseeds) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(out), allocatable :: nseeds (:)","tags":"","url":"proc/read_seeds.html"},{"title":"read_b1rs – Fortran Program","text":"public  subroutine read_b1rs(b1rsgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: b1rsgrid (0:N_R,0:N_THETA,0:N_PHI)","tags":"","url":"proc/read_b1rs.html"},{"title":"read_maggrid – Fortran Program","text":"public  subroutine read_maggrid(magfieldgrid, gbgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: magfieldgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), intent(out) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3)","tags":"","url":"proc/read_maggrid.html"},{"title":"read_shtc – Fortran Program","text":"public  subroutine read_shtc(g, h, n) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: g (0:n,0:n) real(kind=real64), intent(out) :: h (0:n,0:n) integer, intent(in) :: n","tags":"","url":"proc/read_shtc.html"},{"title":"write_maggrid – Fortran Program","text":"public  subroutine write_maggrid(bgrid, gbgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: bgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), intent(in) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3)","tags":"","url":"proc/write_maggrid.html"},{"title":"write_b1rs – Fortran Program","text":"public  subroutine write_b1rs(b1rs, map) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: b1rs (0:N_R,0:N_THETA,0:N_PHI,2) integer, intent(in) :: map (0:N_R,0:N_THETA,0:N_PHI)","tags":"","url":"proc/write_b1rs.html"},{"title":"get_rlambdax – Fortran Program","text":"public  function get_rlambdax() Arguments None Return Value real(kind=real64) Common Blocks read_param (subroutine) set_rlambdax (subroutine) \">\n           common /rlambdax/ Type Attributes Name Initial real(kind=real64) :: rlambdax real(kind=real64) :: rlambday read_param (subroutine) cofm (subroutine) set_rlambdax (subroutine) shockfront (program) sim3d (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx","tags":"","url":"proc/get_rlambdax.html"},{"title":"get_rlambda0 – Fortran Program","text":"public  function get_rlambda0(e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64) Common Blocks read_param (subroutine) set_rlambda (subroutine) vfunc (subroutine) shockfront (program) sim3d (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu","tags":"","url":"proc/get_rlambda0.html"},{"title":"get_rlambdax0 – Fortran Program","text":"public  function get_rlambdax0(e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64)","tags":"","url":"proc/get_rlambdax0.html"},{"title":"get_rlambday0 – Fortran Program","text":"public  function get_rlambday0(e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64)","tags":"","url":"proc/get_rlambday0.html"},{"title":"get_rlambda – Fortran Program","text":"public  function get_rlambda() Arguments None Return Value real(kind=real64) Common Blocks read_param (subroutine) set_rlambda (subroutine) \">\n           common /rlambda/ Type Attributes Name Initial real(kind=real64) :: rlambda","tags":"","url":"proc/get_rlambda.html"},{"title":"preparedxx – Fortran Program","text":"public  subroutine preparedxx(ndxx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndxx","tags":"","url":"proc/preparedxx.html"},{"title":"cofm – Fortran Program","text":"public  subroutine cofm(r, p, pa, beta, bv, bm, cvtu, gbm, dbbds, b1s, gb1s, g, dg) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: beta real(kind=real64), intent(in) :: bv (3) real(kind=real64), intent(in) :: bm real(kind=real64), intent(in) :: cvtu (3) real(kind=real64), intent(in) :: gbm (3) real(kind=real64), intent(in) :: dbbds real(kind=real64), intent(in) :: b1s real(kind=real64), intent(in) :: gb1s (3) real(kind=real64), intent(out) :: g (3) real(kind=real64), intent(out) :: dg (3) Common Blocks read_dxx (subroutine) \">\n           common /dxxcnst/ Type Attributes Name Initial real(kind=real64) :: g0 (3) real(kind=real64) :: b (3) real(kind=real64) :: a (3) read_param (subroutine) get_rlambdax (function) set_rlambdax (subroutine) shockfront (program) sim3d (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx read_param (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip","tags":"","url":"proc/cofm.html"},{"title":"read_dxx – Fortran Program","text":"public  subroutine read_dxx(ndxx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndxx Common Blocks cofm (subroutine) \">\n           common /dxxcnst/ Type Attributes Name Initial real(kind=real64) :: g0 (3) real(kind=real64) :: b (3) real(kind=real64) :: a (3) read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir Namelists Namelist inputdxx Variables Name Type Default Description gperCMS real(kind=real64) None bper real(kind=real64) None aper real(kind=real64) None","tags":"","url":"proc/read_dxx.html"},{"title":"set_rlambdax – Fortran Program","text":"public  subroutine set_rlambdax(e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Common Blocks read_param (subroutine) \">\n           common /nlambdax/ Type Attributes Name Initial integer :: nlambdax read_param (subroutine) get_rlambdax (function) \">\n           common /rlambdax/ Type Attributes Name Initial real(kind=real64) :: rlambdax real(kind=real64) :: rlambday read_param (subroutine) get_rlambdax (function) cofm (subroutine) shockfront (program) sim3d (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx","tags":"","url":"proc/set_rlambdax.html"},{"title":"set_rlambda – Fortran Program","text":"public  subroutine set_rlambda(e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Common Blocks read_param (subroutine) get_rlambda0 (function) vfunc (subroutine) shockfront (program) sim3d (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu read_param (subroutine) \">\n           common /nlambda/ Type Attributes Name Initial integer :: nlambda read_param (subroutine) get_rlambda (function) \">\n           common /rlambda/ Type Attributes Name Initial real(kind=real64) :: rlambda dmumuDG1 (function) read_dmumuDG (subroutine) \">\n           common /dmumuDGcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: rnu real(kind=real64) :: delta real(kind=real64) :: va","tags":"","url":"proc/set_rlambda.html"},{"title":"locate – Fortran Program","text":"public  function locate(xx, n, x) result(j) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: xx (n) integer, intent(in) :: n real(kind=real64), intent(in) :: x Return Value integer","tags":"","url":"proc/locate.html"},{"title":"preparecme – Fortran Program","text":"public  subroutine preparecme() =======if using data or observation at 1au to calculate Va and Vs=======\nbm densw,tempsw could be replaced with those from observation =======if using data at rc1 to calculate Va and Vs directly=====\nmagnetosonic speed (Vms): Vms 2 = 0.5 * {Va 2 + Vs 2 + [(Va 2 + Vs 2) 2 -\n 4 * Va 2 * Vs 2 * (cos (theta)) 2] 0.5}\n====================================================\n----------choose smaller one----------------------------------- if (tauc2_0 Arguments None Common Blocks inorout (subroutine) sksurface (subroutine) \">\n           common /cmesk/ Type Attributes Name Initial real(kind=real64) :: pexsk (0:144,8) real(kind=real64) :: vskf0 real(kind=real64) :: acsk real(kind=real64) :: tska (20) real(kind=real64) :: pska (20,8) integer :: nsk read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip prepareptcl (subroutine) split (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 inorout (subroutine) sksurface (subroutine) sim3d (program) \">\n           common /vsksw/ Type Attributes Name Initial real(kind=real64) :: vsksw real(kind=real64) :: tauf real(kind=real64) :: tauc1_0 real(kind=real64) :: tauc2 real(kind=real64) :: tauc2_0 real :: vcme0kmPs real(kind=real64) :: vcme0","tags":"","url":"proc/preparecme.html"},{"title":"inorout – Fortran Program","text":"public  subroutine inorout(tsh, x, dnsk, vsk, vnx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tsh real(kind=real64), intent(in) :: x (6) real(kind=real64), intent(inout) :: dnsk real(kind=real64), intent(out) :: vsk real(kind=real64), intent(out) :: vnx (3) Common Blocks preparecme (subroutine) sksurface (subroutine) \">\n           common /cmesk/ Type Attributes Name Initial real(kind=real64) :: pexsk (0:144,8) real(kind=real64) :: vskf0 real(kind=real64) :: acsk real(kind=real64) :: tska (20) real(kind=real64) :: pska (20,8) integer :: nsk read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip prepareptcl (subroutine) split (subroutine) preparecme (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 preparecme (subroutine) sksurface (subroutine) sim3d (program) \">\n           common /vsksw/ Type Attributes Name Initial real(kind=real64) :: vsksw real(kind=real64) :: tauf real(kind=real64) :: tauc1_0 real(kind=real64) :: tauc2 real(kind=real64) :: tauc2_0 real :: vcme0kmPs real(kind=real64) :: vcme0","tags":"","url":"proc/inorout.html"},{"title":"walk3d – Fortran Program","text":"subroutine walk3d(iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, ino, bv0, nsplvl) Uses fb param Arguments Type Intent Optional Attributes Name integer :: iseed real(kind=8) :: rp0 (5) real(kind=8) :: rpb (5) real(kind=8) :: ck real(kind=8) :: fs real(kind=8) :: t0 real(kind=8) :: t real(kind=8) :: tsp integer :: ns integer :: ino real(kind=8) :: bv0 (3) integer :: nsplvl Common Blocks sim3d_em (program) \">\n           common /seed/ Type Attributes Name Initial integer :: nseeds (nseedmax) read_param (subroutine) split (subroutine) walk3d (subroutine) walk3d (subroutine) \">\n           common /nlambdaconst/ Type Attributes Name Initial integer :: nlambdaconst read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=8) :: densw0 real(kind=8) :: vsw real(kind=8) :: k4ok2 real(kind=8) :: k6ok2 real(kind=8) :: omega real(kind=8) :: b1au real(kind=8) :: vom real(kind=8) :: facip read_param (subroutine) split (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=8) :: t0org real(kind=8) :: te real(kind=8) :: tdl real(kind=8) :: dmapjul real(kind=8) :: tcme0 e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=8) :: rnz real(kind=8) :: rnm preparefb (subroutine) f0mod (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=8) :: rb0 real(kind=8) :: rmax real(kind=8) :: rk real(kind=8) :: deltat real(kind=8) :: tc real(kind=8) :: tl real(kind=8) :: tmodel0 integer :: nfbconst preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=8) :: sp real(kind=8) :: sp0 real(kind=8) :: gp real(kind=8) :: ap real(kind=8) :: trgtfs (4) real(kind=8) :: scanw real(kind=8) :: h0","tags":"","url":"proc/walk3d.html"},{"title":"walk3d – Fortran Program","text":"subroutine walk3d(iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, dnsk0, bv0, nsplvl) Uses fb param Arguments Type Intent Optional Attributes Name integer :: iseed real(kind=real64) :: rp0 (5) real(kind=real64) :: rpb (5) real(kind=real64) :: ck real(kind=real64) :: fs real(kind=real64) :: t0 real(kind=real64) :: t real(kind=real64) :: tsp integer :: ns real(kind=real64) :: dnsk0 real(kind=real64) :: bv0 (3) integer :: nsplvl Common Blocks read_param (subroutine) split (subroutine) walk3d (subroutine) walk3d (subroutine) \">\n           common /nlambdaconst/ Type Attributes Name Initial integer :: nlambdaconst read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip read_param (subroutine) split (subroutine) walk3d (subroutine) sim3d_em (program) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm preparefb (subroutine) f0mod (subroutine) walk3d (subroutine) sim3d_em (program) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0","tags":"","url":"proc/walk3d~2.html"},{"title":"sksurface – Fortran Program","text":"subroutine sksurface(tsh, x, n) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tsh real(kind=real64), intent(out) :: x (6) integer, intent(in) :: n Common Blocks preparecme (subroutine) inorout (subroutine) \">\n           common /cmesk/ Type Attributes Name Initial real(kind=real64) :: vskf0 real(kind=real64) :: acsk real(kind=real64) :: tska (20) real(kind=real64) :: pska (20,8) integer :: nsk read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 preparecme (subroutine) inorout (subroutine) sim3d (program) \">\n           common /vsksw/ Type Attributes Name Initial real(kind=real64) :: vsksw real(kind=real64) :: tauf real(kind=real64) :: tauc1_0 real(kind=real64) :: tauc2 real(kind=real64) :: tauc2_0 real :: vcme0kmPs real(kind=real64) :: vcme0","tags":"","url":"proc/sksurface.html"},{"title":"fs0 – Fortran Program","text":"public  function fs0(tacc, xpk, bm, u1, densw, ob, amach, rsh, vth, pinj, pc) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tacc real(kind=real64), intent(in) :: xpk (6) real(kind=real64), intent(in) :: bm real(kind=real64), intent(in) :: u1 real(kind=real64), intent(in) :: densw real(kind=real64), intent(in) :: ob real(kind=real64), intent(in) :: amach real(kind=real64), intent(in) :: rsh real(kind=real64), intent(in) :: vth real(kind=real64), intent(inout) :: pinj real(kind=real64), intent(inout) :: pc Return Value real(kind=real64) Common Blocks read_param (subroutine) \">\n           common /acc/ Type Attributes Name Initial real(kind=real64) :: ecrmax real(kind=real64) :: ecrmin real(kind=real64) :: ob0 real(kind=real64) :: obw real(kind=real64) :: etinj real(kind=real64) :: fampb real(kind=real64) :: ratkp e2p (function) rp2e (function) rp2beta (function) beta2p (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm","tags":"","url":"proc/fs0.html"},{"title":"fb0 – Fortran Program","text":"public  function fb0(torg, rpb) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: torg real(kind=real64), intent(in) :: rpb (5) Return Value real(kind=real64)","tags":"","url":"proc/fb0.html"},{"title":"preparefb – Fortran Program","text":"public  subroutine preparefb() Arguments None Common Blocks f0mod (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0 Namelists Namelist fb Variables Name Type Default Description rb0 real(kind=real64) None rmax real(kind=real64) None rk real(kind=real64) None deltat real(kind=real64) None tc real(kind=real64) None tl real(kind=real64) None tmodel0 real(kind=real64) None nfbconst integer None sclat real(kind=real64) None sclong real(kind=real64) None scanw real(kind=real64) None","tags":"","url":"proc/preparefb.html"},{"title":"vfunc – Fortran Program","text":"function vfunc(t, r, pol) result(v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: pol Return Value real(kind=real64), (3)","tags":"","url":"proc/vfunc.html"},{"title":"magfield – Fortran Program","text":"function magfield(rvec) result(b) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rvec (3) Return Value real(kind=real64), (3)","tags":"","url":"proc/magfield~2.html"},{"title":"solarwindtemp – Fortran Program","text":"public  function solarwindtemp(r) result(temp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64)","tags":"","url":"proc/solarwindtemp.html"},{"title":"compress – Fortran Program","text":"public  function compress(amach, smach, ob) result(rsh) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: amach real(kind=real64), intent(in) :: smach real(kind=real64), intent(in) :: ob Return Value real(kind=real64), (3)","tags":"","url":"proc/compress.html"},{"title":"solarwind1 – Fortran Program","text":"public  function solarwind1(r) result(vpl) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64), (3) Common Blocks read_param (subroutine) cofm (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip","tags":"","url":"proc/solarwind1.html"},{"title":"f0mod – Fortran Program","text":"public  subroutine f0mod(r, pa, f0, df0, ddf0, df0dmu, ddf0dmu2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: pa real(kind=real64), intent(out) :: f0 real(kind=real64), intent(out) :: df0 (3) real(kind=real64), intent(out) :: ddf0 (3,3) real(kind=real64), intent(out) :: df0dmu real(kind=real64), intent(out) :: ddf0dmu2 Common Blocks preparefb (subroutine) prepareptcl (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0 read_param (subroutine) cofm (subroutine) solarwind1 (function) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip preparefb (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst","tags":"","url":"proc/f0mod.html"},{"title":"split – Fortran Program","text":"public recursive subroutine split(iseed, rpb, ck, fs, t, nsplvl, dnsk, bv0, flx, dflx, walk3d, nsts) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iseed real(kind=real64), intent(in) :: rpb (5) real(kind=real64), intent(inout) :: ck real(kind=real64), intent(inout) :: fs real(kind=real64), intent(in) :: t integer, intent(inout) :: nsplvl real(kind=real64), intent(inout) :: dnsk real(kind=real64), intent(inout) :: bv0 (3) real(kind=real64), intent(inout) :: flx real(kind=real64), intent(inout) :: dflx real :: walk3d integer, intent(in) :: nsts Common Blocks sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /svsp/ Type Attributes Name Initial integer :: nodr (NSPMAX) real(kind=real64) :: t0sv (2**(NSPMAX+1)) real(kind=real64) :: cksv (2**(NSPMAX+1)) real(kind=real64) :: rpbsv (5,2**(NSPMAX+1)) real(kind=real64) :: fssv (2**(NSPMAX+1)) real(kind=real64) :: dnsksv (2**(NSPMAX+1)) real(kind=real64) :: bv0sv (3,2**(NSPMAX+1)) prepareptcl (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 common /rb0max/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax read_param (subroutine) walk3d (subroutine) walk3d (subroutine) walk3d (subroutine) \">\n           common /nlambdaconst/ Type Attributes Name Initial integer :: nlambdaconst read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip read_param (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0","tags":"","url":"proc/split.html"},{"title":"vfunc – Fortran Program","text":"public  subroutine vfunc(t, xpk, dxpkdt, du, gxw2, gxw3, bv0, densw, vpl, gper, b1s) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t real(kind=real64), intent(in) :: xpk (6) real(kind=real64), intent(out) :: dxpkdt (6) real(kind=real64) :: du real(kind=real64), intent(out) :: gxw2 (3) real(kind=real64), intent(out) :: gxw3 (3) real(kind=real64), intent(out) :: bv0 (3) real(kind=real64) :: densw real(kind=real64) :: vpl (3) real(kind=real64), intent(out) :: gper real(kind=real64) :: b1s Common Blocks e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0 read_param (subroutine) get_rlambda0 (function) set_rlambda (subroutine) shockfront (program) sim3d (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu","tags":"","url":"proc/vfunc~2.html"},{"title":"solarwind – Fortran Program","text":"public  subroutine solarwind(r, vpl, gvpl, densw) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(out) :: vpl (3) real(kind=real64), intent(out) :: gvpl (3,3) real(kind=real64), intent(out) :: densw Common Blocks read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip","tags":"","url":"proc/solarwind.html"},{"title":"drvbmag – Fortran Program","text":"public  subroutine drvbmag(r1, b, bmag, cvtu, gbmag, bxgb2, dbbds, pol, b1rs, gb1rs) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r1 (3) real(kind=real64), intent(out) :: b (3) real(kind=real64), intent(out) :: bmag real(kind=real64), intent(out) :: cvtu (3) real(kind=real64), intent(out) :: gbmag (3) real(kind=real64), intent(out) :: bxgb2 (3) real(kind=real64), intent(out) :: dbbds real(kind=real64), intent(out) :: pol real(kind=real64), intent(out) :: b1rs real(kind=real64), intent(out) :: gb1rs (3) Common Blocks read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip","tags":"","url":"proc/drvbmag.html"},{"title":"e2p – Fortran Program","text":"public  function e2p(e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64) Common Blocks rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm","tags":"","url":"proc/e2p.html"},{"title":"rp2e – Fortran Program","text":"public  function rp2e(rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64) Common Blocks e2p (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm","tags":"","url":"proc/rp2e.html"},{"title":"rp2beta – Fortran Program","text":"public  function rp2beta(rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64) Common Blocks e2p (function) rp2e (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm","tags":"","url":"proc/rp2beta.html"},{"title":"rp2v – Fortran Program","text":"public  function rp2v(rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64)","tags":"","url":"proc/rp2v.html"},{"title":"e2beta – Fortran Program","text":"public  function e2beta(e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64)","tags":"","url":"proc/e2beta.html"},{"title":"beta2gamma – Fortran Program","text":"public pure function beta2gamma(beta) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: beta Return Value real(kind=real64)","tags":"","url":"proc/beta2gamma.html"},{"title":"e2gamma – Fortran Program","text":"public  function e2gamma(e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64)","tags":"","url":"proc/e2gamma.html"},{"title":"e2v – Fortran Program","text":"public  function e2v(e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64)","tags":"","url":"proc/e2v.html"},{"title":"v2p – Fortran Program","text":"public  function v2p(v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v Return Value real(kind=real64)","tags":"","url":"proc/v2p.html"},{"title":"beta2p – Fortran Program","text":"public  function beta2p(beta) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: beta Return Value real(kind=real64) Common Blocks e2p (function) rp2e (function) rp2beta (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm","tags":"","url":"proc/beta2p.html"},{"title":"is_leap_year – Fortran Program","text":"public pure function is_leap_year(year) returns if a function is a Gregorian leap year Arguments Type Intent Optional Attributes Name integer, intent(in) :: year Return Value logical","tags":"","url":"proc/is_leap_year.html"},{"title":"seconds_of_year – Fortran Program","text":"public  function seconds_of_year() result(total_seconds) return how many seconds have passed since the year started Arguments None Return Value integer","tags":"","url":"proc/seconds_of_year.html"},{"title":"gregorian – Fortran Program","text":"public pure function gregorian(julian) This routine converts Julian day number to calendar (Gregorian) date. Arguments Type Intent Optional Attributes Name integer, intent(in) :: julian Julian day (integer) Return Value type( gregorian_date )","tags":"","url":"proc/gregorian.html"},{"title":"modjulianday – Fortran Program","text":"public  function modjulianday(year, month, day, fracday) calculate the julian day from day, month, year and fraction of a day Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day real(kind=real64), intent(in) :: fracday Return Value real(kind=real64)","tags":"","url":"proc/modjulianday.html"},{"title":"julday – Fortran Program","text":"public  function julday(mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mm integer, intent(in) :: id integer, intent(in) :: iyyy Return Value integer","tags":"","url":"proc/julday.html"},{"title":"caldate – Fortran Program","text":"public  subroutine caldate(jday, iyear, iyday) This routine takes the modified Julian date and\nconverts it to a date and time string. Calls:  GREGORIAN Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: jday modified Julian day (integer) integer, intent(out) :: iyear year (integer) integer, intent(out) :: iyday year day (integer)","tags":"","url":"proc/caldate.html"},{"title":"dmumuAH – Fortran Program","text":"public  function dmumuAH(p, pa, bm, ddu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: ddu Return Value real(kind=real64) Common Blocks read_dmumuAH (subroutine) \">\n           common /dmumuAHcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: b1 real(kind=real64) :: a1","tags":"","url":"proc/dmumuah.html"},{"title":"dmumuBK – Fortran Program","text":"public  function dmumuBK(p, pa, v, bm, ddu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: v real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: ddu Return Value real(kind=real64) Common Blocks read_dmumuBK (subroutine) \">\n           common /dmumuBKcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: b1 real(kind=real64) :: a1 real(kind=real64) :: qindx real(kind=real64) :: sigma real(kind=real64) :: h","tags":"","url":"proc/dmumubk.html"},{"title":"sign_my – Fortran Program","text":"public pure elemental function sign_my(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","url":"proc/sign_my.html"},{"title":"dmumuDG1 – Fortran Program","text":"public  function dmumuDG1(v, rmu, ddmumuDG1) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v real(kind=real64), intent(inout) :: rmu real(kind=real64), intent(out) :: ddmumuDG1 Return Value real(kind=real64) Common Blocks read_dmumuDG (subroutine) set_rlambda (subroutine) \">\n           common /dmumuDGcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: rnu real(kind=real64) :: delta real(kind=real64) :: va","tags":"","url":"proc/dmumudg1.html"},{"title":"dmumuDG – Fortran Program","text":"public  function dmumuDG(v, rmu0, ddmumuDG) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v real(kind=real64), intent(inout) :: rmu0 real(kind=real64), intent(out) :: ddmumuDG Return Value real(kind=real64)","tags":"","url":"proc/dmumudg.html"},{"title":"preparedmumu – Fortran Program","text":"public  subroutine preparedmumu(ndmumu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndmumu","tags":"","url":"proc/preparedmumu.html"},{"title":"cofdu – Fortran Program","text":"public  subroutine cofdu(p, pa, beta, bm, du, ddu, ndmumu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(inout) :: pa real(kind=real64), intent(in) :: beta real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: du real(kind=real64), intent(out) :: ddu integer, intent(in) :: ndmumu","tags":"","url":"proc/cofdu.html"},{"title":"set_du0AH – Fortran Program","text":"public  subroutine set_du0AH(du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0","tags":"","url":"proc/set_du0ah.html"},{"title":"set_du0BK – Fortran Program","text":"public  subroutine set_du0BK(du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0","tags":"","url":"proc/set_du0bk.html"},{"title":"set_du0DG – Fortran Program","text":"public  subroutine set_du0DG(du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0","tags":"","url":"proc/set_du0dg.html"},{"title":"read_dmumuDG – Fortran Program","text":"public  subroutine read_dmumuDG() Arguments None Common Blocks dmumuDG1 (function) set_rlambda (subroutine) \">\n           common /dmumuDGcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: rnu real(kind=real64) :: delta real(kind=real64) :: va read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir Namelists Namelist inputdmumuDG Variables Name Type Default Description du0 real(kind=real64) None rnu real(kind=real64) None delta real(kind=real64) None va real(kind=real64) None","tags":"","url":"proc/read_dmumudg.html"},{"title":"read_dmumuAH – Fortran Program","text":"public  subroutine read_dmumuAH() Arguments None Common Blocks dmumuAH (function) \">\n           common /dmumuAHcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: b1 real(kind=real64) :: a1 read_dmumuDG (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir Namelists Namelist inputdmumuAH Variables Name Type Default Description du0 real(kind=real64) None b1 real(kind=real64) None a1 real(kind=real64) None","tags":"","url":"proc/read_dmumuah.html"},{"title":"read_dmumuBK – Fortran Program","text":"public  subroutine read_dmumuBK() Arguments None Common Blocks dmumuBK (function) \">\n           common /dmumuBKcnst/ Type Attributes Name Initial real(kind=real64) :: du0 real(kind=real64) :: b1 real(kind=real64) :: a1 real(kind=real64) :: qindx real(kind=real64) :: sigma real(kind=real64) :: h read_dmumuDG (subroutine) read_dmumuAH (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir Namelists Namelist inputdmumuBK Variables Name Type Default Description du0 real(kind=real64) None rlambda real(kind=real64) None nlambda integer None b1 real(kind=real64) None a1 real(kind=real64) None qindx real(kind=real64) None sigma real(kind=real64) None h real(kind=real64) None","tags":"","url":"proc/read_dmumubk.html"},{"title":"walk3d – Fortran Program","text":"subroutine walk3d(iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, dnsk0, bv0, nsplvl) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iseed real(kind=real64), intent(in) :: rp0 (5) real(kind=real64), intent(out) :: rpb (5) real(kind=real64), intent(inout) :: ck real(kind=real64), intent(inout) :: fs real(kind=real64), intent(in) :: t0 real(kind=real64), intent(out) :: t real(kind=real64), intent(in) :: tsp integer, intent(out) :: ns real(kind=real64), intent(inout) :: dnsk0 real(kind=real64), intent(inout) :: bv0 (3) integer, intent(in) :: nsplvl Common Blocks read_param (subroutine) split (subroutine) walk3d (subroutine) walk3d (subroutine) \">\n           common /nlambdaconst/ Type Attributes Name Initial integer :: nlambdaconst read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip read_param (subroutine) split (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm preparefb (subroutine) f0mod (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0","tags":"","url":"proc/walk3d~3.html"},{"title":"norm2 – Fortran Program","text":"public  function norm2(arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) Return Value real(kind=real64)","tags":"","url":"proc/norm2.html"},{"title":"cartesian2spherical – Fortran Program","text":"public  function cartesian2spherical(x) result(r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64), (3)","tags":"","url":"proc/cartesian2spherical.html"},{"title":"spherical2cartesian – Fortran Program","text":"public  function spherical2cartesian(r) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64), (3)","tags":"","url":"proc/spherical2cartesian.html"},{"title":"mxptr – Fortran Program","text":"public  function mxptr(gm) result(xptr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: gm Return Value real(kind=real64), (3,3)","tags":"","url":"proc/mxptr.html"},{"title":"dmxptr – Fortran Program","text":"public  function dmxptr(gm, dgm) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: gm real(kind=real64), intent(in) :: dgm Return Value real(kind=real64), (3,3)","tags":"","url":"proc/dmxptr.html"},{"title":"mbtr – Fortran Program","text":"public  function mbtr(uax1, uax2, uax3) result(b2r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: uax1 (3) real(kind=real64), intent(in) :: uax2 (3) real(kind=real64), intent(in) :: uax3 (3) Return Value real(kind=real64), (3,3)","tags":"","url":"proc/mbtr.html"},{"title":"mrtx – Fortran Program","text":"public  function mrtx(sintheta, costheta, sinphi, cosphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: sintheta real(kind=real64), intent(in) :: costheta real(kind=real64), intent(in) :: sinphi real(kind=real64), intent(in) :: cosphi Return Value real(kind=real64), (3,3)","tags":"","url":"proc/mrtx.html"},{"title":"dmrtx – Fortran Program","text":"public  function dmrtx(sintheta, costheta, sinphi, cosphi, dtheta, dphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: sintheta real(kind=real64), intent(in) :: costheta real(kind=real64), intent(in) :: sinphi real(kind=real64), intent(in) :: cosphi real(kind=real64), intent(in) :: dtheta real(kind=real64), intent(in) :: dphi Return Value real(kind=real64), (3,3)","tags":"","url":"proc/dmrtx.html"},{"title":"trilinear – Fortran Program","text":"public  function trilinear(phic, x) result(phi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: phic (2,2,2) real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64)","tags":"","url":"proc/trilinear.html"},{"title":"trilineardif – Fortran Program","text":"public  function trilineardif(phic, x) result(dphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: phic (2,2,2) real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64), (3)","tags":"","url":"proc/trilineardif.html"},{"title":"prepareptcl – Fortran Program","text":"public  subroutine prepareptcl(tf, rf, ef, rmuf, np, nf) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), allocatable :: tf (:) real(kind=real64), intent(out), allocatable :: rf (:,:) real(kind=real64), intent(out), allocatable :: ef (:) real(kind=real64), intent(out), allocatable :: rmuf (:) integer :: np integer :: nf Common Blocks split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm preparefb (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0","tags":"","url":"proc/prepareptcl.html"},{"title":"rksolvers – Fortran Program","text":"Uses iso_fortran_env Interfaces interface public  function odefun(x, y, p) result(v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y (3) real(kind=real64), intent(in) :: p Return Value real(kind=real64), (3) Functions public  function rk4 (f, x0, y0, h, odefun_param) result(yout) Arguments Type Intent Optional Attributes Name procedure( odefun ) :: f real(kind=real64) :: x0 real(kind=real64) :: y0 (:) real(kind=real64) :: h real(kind=real64) :: odefun_param Return Value real(kind=real64), allocatable, (:)","tags":"","url":"module/rksolvers.html"},{"title":"random – Fortran Program","text":"Uses iso_fortran_env Functions public impure function gasdev (idum) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idum Return Value real(kind=real64) public  function ran2 (idum) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: idum Return Value real(kind=real64)","tags":"","url":"module/random.html"},{"title":"file_op – Fortran Program","text":"Uses iso_fortran_env param Subroutines public  subroutine fl_open (nfl, nsts) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nfl integer, intent(out) :: nsts public  subroutine record_nodes (nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes public  subroutine write_head (nfl, nf) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfl integer, intent(in) :: nf public  subroutine open_file_from_environment (env_var_name, fileunit, file_form, file_status) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: env_var_name integer, intent(out) :: fileunit character(len=*), intent(in) :: file_form character(len=*), intent(in), optional :: file_status public  subroutine read_param (nodes, nseeds) Arguments Type Intent Optional Attributes Name integer, intent(out) :: nodes integer, intent(out), allocatable :: nseeds (:) public  subroutine read_seeds (n, nseeds) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(out), allocatable :: nseeds (:) public  subroutine read_b1rs (b1rsgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: b1rsgrid (0:N_R,0:N_THETA,0:N_PHI) public  subroutine read_maggrid (magfieldgrid, gbgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: magfieldgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), intent(out) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3) public  subroutine read_shtc (g, h, n) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: g (0:n,0:n) real(kind=real64), intent(out) :: h (0:n,0:n) integer, intent(in) :: n public  subroutine write_maggrid (bgrid, gbgrid) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: bgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), intent(in) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3) public  subroutine write_b1rs (b1rs, map) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: b1rs (0:N_R,0:N_THETA,0:N_PHI,2) integer, intent(in) :: map (0:N_R,0:N_THETA,0:N_PHI)","tags":"","url":"module/file_op.html"},{"title":"dxx – Fortran Program","text":"Uses iso_fortran_env epv param dmumu Functions public  function get_rlambdax () Arguments None Return Value real(kind=real64) public  function get_rlambda0 (e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64) public  function get_rlambdax0 (e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64) public  function get_rlambday0 (e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 Return Value real(kind=real64) public  function get_rlambda () Arguments None Return Value real(kind=real64) Subroutines public  subroutine preparedxx (ndxx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndxx public  subroutine cofm (r, p, pa, beta, bv, bm, cvtu, gbm, dbbds, b1s, gb1s, g, dg) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: beta real(kind=real64), intent(in) :: bv (3) real(kind=real64), intent(in) :: bm real(kind=real64), intent(in) :: cvtu (3) real(kind=real64), intent(in) :: gbm (3) real(kind=real64), intent(in) :: dbbds real(kind=real64), intent(in) :: b1s real(kind=real64), intent(in) :: gb1s (3) real(kind=real64), intent(out) :: g (3) real(kind=real64), intent(out) :: dg (3) public  subroutine read_dxx (ndxx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndxx public  subroutine set_rlambdax (e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0 public  subroutine set_rlambda (e0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e0","tags":"","url":"module/dxx.html"},{"title":"cme_cross – Fortran Program","text":"Uses param datetime_utils iso_fortran_env mtrx file_op sim3d_utils Functions public  function locate (xx, n, x) result(j) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: xx (n) integer, intent(in) :: n real(kind=real64), intent(in) :: x Return Value integer Subroutines public  subroutine preparecme () =======if using data or observation at 1au to calculate Va and Vs=======\nbm densw,tempsw could be replaced with those from observation Read more… Arguments None public  subroutine inorout (tsh, x, dnsk, vsk, vnx) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tsh real(kind=real64), intent(in) :: x (6) real(kind=real64), intent(inout) :: dnsk real(kind=real64), intent(out) :: vsk real(kind=real64), intent(out) :: vnx (3)","tags":"","url":"module/cme_cross.html"},{"title":"fb – Fortran Program","text":"Uses iso_fortran_env param ieee_arithmetic Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: OMGP1 = 574745 real(kind=real64), public, parameter :: OMGE1 = 1055307413 Functions public  function fs0 (tacc, xpk, bm, u1, densw, ob, amach, rsh, vth, pinj, pc) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tacc real(kind=real64), intent(in) :: xpk (6) real(kind=real64), intent(in) :: bm real(kind=real64), intent(in) :: u1 real(kind=real64), intent(in) :: densw real(kind=real64), intent(in) :: ob real(kind=real64), intent(in) :: amach real(kind=real64), intent(in) :: rsh real(kind=real64), intent(in) :: vth real(kind=real64), intent(inout) :: pinj real(kind=real64), intent(inout) :: pc Return Value real(kind=real64) public  function fb0 (torg, rpb) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: torg real(kind=real64), intent(in) :: rpb (5) Return Value real(kind=real64) Subroutines public  subroutine preparefb () Arguments None","tags":"","url":"module/fb.html"},{"title":"param – Fortran Program","text":"Uses iso_fortran_env Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: PI = 3.14159265358979323846d0 real(kind=real64), public, parameter :: TWOPI = 2.d0*PI real(kind=real64), public, parameter :: CSPEED = 25.8441774d0 real(kind=real64), public, parameter :: QoMSI = 9.57883376d7 real(kind=real64), public, parameter :: EP = 0.938d0 real(kind=real64), public, parameter :: EE = 0.510998918d-3 real(kind=real64), public, parameter :: GAMMA_CS = 1.6666666666666666666d0 integer, public, parameter :: NSEEDMAX = 2001 integer, public, parameter :: NFMAX = 200 integer(kind=int64), public, parameter :: NBASE = 40 integer(kind=int64), public, parameter :: NSPMAX = 20 real(kind=real64), public, parameter :: RSS = 2.5d0 integer, public, parameter :: N_R = 150 integer, public, parameter :: N_THETA = 180 integer, public, parameter :: N_PHI = 360 real(kind=real64), public :: bgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), public :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64), public :: b1rsgrid (0:N_R,0:N_THETA,0:N_PHI) real(kind=real64), public, parameter :: epsilon (4) = [0.04, 0.01, 0.04, 0.003] real(kind=real64), public, parameter :: RAD_TO_DEG = 180d0/pi real(kind=real64), public, parameter :: DEG_TO_RAD = pi/180d0 real(kind=real64), public, parameter :: RS_PER_MIN_TO_KM_PER_SEC = 6.96340d5/60.0","tags":"","url":"module/param.html"},{"title":"sim3d_utils – Fortran Program","text":"Uses param iso_fortran_env fb epv mtrx Functions public  function solarwindtemp (r) result(temp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64) public  function compress (amach, smach, ob) result(rsh) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: amach real(kind=real64), intent(in) :: smach real(kind=real64), intent(in) :: ob Return Value real(kind=real64), (3) public  function solarwind1 (r) result(vpl) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64), (3) Subroutines public  subroutine f0mod (r, pa, f0, df0, ddf0, df0dmu, ddf0dmu2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: pa real(kind=real64), intent(out) :: f0 real(kind=real64), intent(out) :: df0 (3) real(kind=real64), intent(out) :: ddf0 (3,3) real(kind=real64), intent(out) :: df0dmu real(kind=real64), intent(out) :: ddf0dmu2 public recursive subroutine split (iseed, rpb, ck, fs, t, nsplvl, dnsk, bv0, flx, dflx, walk3d, nsts) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iseed real(kind=real64), intent(in) :: rpb (5) real(kind=real64), intent(inout) :: ck real(kind=real64), intent(inout) :: fs real(kind=real64), intent(in) :: t integer, intent(inout) :: nsplvl real(kind=real64), intent(inout) :: dnsk real(kind=real64), intent(inout) :: bv0 (3) real(kind=real64), intent(inout) :: flx real(kind=real64), intent(inout) :: dflx real :: walk3d integer, intent(in) :: nsts public  subroutine vfunc (t, xpk, dxpkdt, du, gxw2, gxw3, bv0, densw, vpl, gper, b1s) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t real(kind=real64), intent(in) :: xpk (6) real(kind=real64), intent(out) :: dxpkdt (6) real(kind=real64) :: du real(kind=real64), intent(out) :: gxw2 (3) real(kind=real64), intent(out) :: gxw3 (3) real(kind=real64), intent(out) :: bv0 (3) real(kind=real64) :: densw real(kind=real64) :: vpl (3) real(kind=real64), intent(out) :: gper real(kind=real64) :: b1s public  subroutine solarwind (r, vpl, gvpl, densw) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(out) :: vpl (3) real(kind=real64), intent(out) :: gvpl (3,3) real(kind=real64), intent(out) :: densw public  subroutine drvbmag (r1, b, bmag, cvtu, gbmag, bxgb2, dbbds, pol, b1rs, gb1rs) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r1 (3) real(kind=real64), intent(out) :: b (3) real(kind=real64), intent(out) :: bmag real(kind=real64), intent(out) :: cvtu (3) real(kind=real64), intent(out) :: gbmag (3) real(kind=real64), intent(out) :: bxgb2 (3) real(kind=real64), intent(out) :: dbbds real(kind=real64), intent(out) :: pol real(kind=real64), intent(out) :: b1rs real(kind=real64), intent(out) :: gb1rs (3)","tags":"","url":"module/sim3d_utils.html"},{"title":"epv – Fortran Program","text":"Uses iso_fortran_env param Functions public  function e2p (e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64) public  function rp2e (rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64) public  function rp2beta (rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64) public  function rp2v (rp) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rp Return Value real(kind=real64) public  function e2beta (e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64) public pure function beta2gamma (beta) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: beta Return Value real(kind=real64) public  function e2gamma (e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64) public  function e2v (e) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: e Return Value real(kind=real64) public  function v2p (v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v Return Value real(kind=real64) public  function beta2p (beta) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: beta Return Value real(kind=real64)","tags":"","url":"module/epv.html"},{"title":"datetime_utils – Fortran Program","text":"Uses iso_fortran_env Derived Types type, public :: gregorian_date Components Type Visibility Attributes Name Initial integer, public :: iday integer, public :: month integer, public :: iyear integer, public :: iyday Functions public pure function is_leap_year (year) returns if a function is a Gregorian leap year Arguments Type Intent Optional Attributes Name integer, intent(in) :: year Return Value logical public  function seconds_of_year () result(total_seconds) return how many seconds have passed since the year started Arguments None Return Value integer public pure function gregorian (julian) This routine converts Julian day number to calendar (Gregorian) date. Arguments Type Intent Optional Attributes Name integer, intent(in) :: julian Julian day (integer) Return Value type( gregorian_date ) public  function modjulianday (year, month, day, fracday) calculate the julian day from day, month, year and fraction of a day Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day real(kind=real64), intent(in) :: fracday Return Value real(kind=real64) public  function julday (mm, id, iyyy) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mm integer, intent(in) :: id integer, intent(in) :: iyyy Return Value integer Subroutines public  subroutine caldate (jday, iyear, iyday) This routine takes the modified Julian date and\nconverts it to a date and time string. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: jday modified Julian day (integer) integer, intent(out) :: iyear year (integer) integer, intent(out) :: iyday year day (integer)","tags":"","url":"module/datetime_utils.html"},{"title":"dmumu – Fortran Program","text":"Uses iso_fortran_env param Functions public  function dmumuAH (p, pa, bm, ddu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: ddu Return Value real(kind=real64) public  function dmumuBK (p, pa, v, bm, ddu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(in) :: pa real(kind=real64), intent(in) :: v real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: ddu Return Value real(kind=real64) public pure elemental function sign_my (x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) public  function dmumuDG1 (v, rmu, ddmumuDG1) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v real(kind=real64), intent(inout) :: rmu real(kind=real64), intent(out) :: ddmumuDG1 Return Value real(kind=real64) public  function dmumuDG (v, rmu0, ddmumuDG) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v real(kind=real64), intent(inout) :: rmu0 real(kind=real64), intent(out) :: ddmumuDG Return Value real(kind=real64) Subroutines public  subroutine preparedmumu (ndmumu) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ndmumu public  subroutine cofdu (p, pa, beta, bm, du, ddu, ndmumu) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: p real(kind=real64), intent(inout) :: pa real(kind=real64), intent(in) :: beta real(kind=real64), intent(in) :: bm real(kind=real64), intent(out) :: du real(kind=real64), intent(out) :: ddu integer, intent(in) :: ndmumu public  subroutine set_du0AH (du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0 public  subroutine set_du0BK (du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0 public  subroutine set_du0DG (du0rt, du0) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: du0rt real(kind=real64), intent(inout) :: du0 public  subroutine read_dmumuDG () Arguments None public  subroutine read_dmumuAH () Arguments None public  subroutine read_dmumuBK () Arguments None","tags":"","url":"module/dmumu.html"},{"title":"mtrx – Fortran Program","text":"Uses param dmumu iso_fortran_env epv dxx file_op Functions public  function norm2 (arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: arr (:) Return Value real(kind=real64) public  function cartesian2spherical (x) result(r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64), (3) public  function spherical2cartesian (r) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: r (3) Return Value real(kind=real64), (3) public  function mxptr (gm) result(xptr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: gm Return Value real(kind=real64), (3,3) public  function dmxptr (gm, dgm) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: gm real(kind=real64), intent(in) :: dgm Return Value real(kind=real64), (3,3) public  function mbtr (uax1, uax2, uax3) result(b2r) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: uax1 (3) real(kind=real64), intent(in) :: uax2 (3) real(kind=real64), intent(in) :: uax3 (3) Return Value real(kind=real64), (3,3) public  function mrtx (sintheta, costheta, sinphi, cosphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: sintheta real(kind=real64), intent(in) :: costheta real(kind=real64), intent(in) :: sinphi real(kind=real64), intent(in) :: cosphi Return Value real(kind=real64), (3,3) public  function dmrtx (sintheta, costheta, sinphi, cosphi, dtheta, dphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: sintheta real(kind=real64), intent(in) :: costheta real(kind=real64), intent(in) :: sinphi real(kind=real64), intent(in) :: cosphi real(kind=real64), intent(in) :: dtheta real(kind=real64), intent(in) :: dphi Return Value real(kind=real64), (3,3) public  function trilinear (phic, x) result(phi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: phic (2,2,2) real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64) public  function trilineardif (phic, x) result(dphi) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: phic (2,2,2) real(kind=real64), intent(in) :: x (3) Return Value real(kind=real64), (3)","tags":"","url":"module/mtrx.html"},{"title":"loadptcl – Fortran Program","text":"Uses iso_fortran_env file_op Subroutines public  subroutine prepareptcl (tf, rf, ef, rmuf, np, nf) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out), allocatable :: tf (:) real(kind=real64), intent(out), allocatable :: rf (:,:) real(kind=real64), intent(out), allocatable :: ef (:) real(kind=real64), intent(out), allocatable :: rmuf (:) integer :: np integer :: nf","tags":"","url":"module/loadptcl.html"},{"title":"maggrid – Fortran Program","text":"Uses param iso_fortran_env fgsl mtrx file_op Variables Type Attributes Name Initial integer, parameter :: NS = 40 real(kind=real64) :: rvec (3) real(kind=real64) :: b (3) real(kind=real64) :: cvtu (3) real(kind=real64) :: gbmag (3) real(kind=real64) :: g (0:NS,0:NS) real(kind=real64) :: h (0:NS,0:NS) real(kind=real64) :: srfctrtl (NS,NS) real(kind=real64) :: bmag real(kind=real64) :: dbbds integer :: id integer :: chunk real(kind=real64) :: starttime real(kind=real64) :: stoptime integer :: i integer :: j integer :: k real(kind=real64) :: bgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64) :: ALP_TABLE (0:N_THETA,0:NS,0:NS) real(kind=real64) :: DALP_TABLE (0:N_THETA,0:NS,0:NS) real(kind=real64) :: D2ALP_TABLE (0:N_THETA,0:NS,0:NS) Functions function plgndr (l, m, x) Arguments Type Intent Optional Attributes Name integer, intent(in) :: l integer, intent(in) :: m real(kind=real64), intent(in) :: x Return Value real(kind=real64) Subroutines subroutine factorialratio (fac_table) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: fac_table (NS,NS) subroutine magfield (rvec, b, bmag, cvtu, gbmag, dbbds, srfctrtl, g, h) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rvec (3) real(kind=real64), intent(out) :: b (3) real(kind=real64), intent(out) :: bmag real(kind=real64), intent(out) :: cvtu (3) real(kind=real64), intent(out) :: gbmag (3) real(kind=real64), intent(out) :: dbbds real(kind=real64), intent(in) :: srfctrtl (NS,NS) real(kind=real64), intent(in) :: g (0:NS,0:NS) real(kind=real64), intent(in) :: h (0:NS,0:NS) subroutine init_aplm (alp_arr, dalp_arr, d2alp_arr) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(out) :: alp_arr (0:N_THETA,0:NS,0:NS) real(kind=real64), intent(out) :: dalp_arr (0:N_THETA,0:NS,0:NS) real(kind=real64), intent(out) :: d2alp_arr (0:N_THETA,0:NS,0:NS)","tags":"","url":"program/maggrid.html"},{"title":"histogram – Fortran Program","text":"Uses iso_fortran_env Variables Type Attributes Name Initial real(kind=real64), parameter :: twopi = 2.d0*3.14159265358979323846d0 real(kind=real64), parameter :: rss = 2.5 real(kind=real64), parameter :: rs = 6.96e5 real(kind=real64), parameter :: vsw = 400.0/rs*60 real(kind=real64), parameter :: omega = twopi/(27.27*24*60) real(kind=real64), parameter :: k4ok2 = 12.4242 real(kind=real64), parameter :: k6ok2 = 242.4242 real(kind=real64) :: al (8) real(kind=real64) :: ra real(kind=real64) :: theta real(kind=real64) :: phi real(kind=real64) :: hist (91,46) real(kind=real64) :: hs (91,46) real(kind=real64) :: tpsw real(kind=real64) :: xmu integer :: n integer :: nn integer :: ns integer :: nz integer :: i integer :: j integer :: ii integer :: jj integer :: jjj integer :: iy integer :: ix","tags":"","url":"program/histogram.html"},{"title":"seedgen – Fortran Program","text":"Uses file_op random datetime_utils param Variables Type Attributes Name Initial integer :: iseed integer :: i integer :: j integer :: nran (NSEEDMAX) integer :: seeds_outfileunit integer :: iran","tags":"","url":"program/seedgen.html"},{"title":"sim3d_em – Fortran Program","text":"Uses loadptcl cme_cross param datetime_utils dmumu epv fb random mtrx dxx file_op sim3d_utils Common Blocks e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=8) :: rnz real(kind=8) :: rnm shockfront (program) sim3d (program) \">\n           common /nsucmin/ Type Attributes Name Initial integer :: nsucmin shockfront (program) sim3d (program) \">\n           common /npmax/ Type Attributes Name Initial integer :: npmax preparefb (subroutine) f0mod (subroutine) walk3d (subroutine) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=8) :: rb0 real(kind=8) :: rmax real(kind=8) :: rk real(kind=8) :: deltat real(kind=8) :: tc real(kind=8) :: tl real(kind=8) :: tmodel0 integer :: nfbconst read_param (subroutine) split (subroutine) walk3d (subroutine) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt split (subroutine) shockfront (program) sim3d (program) \">\n           common /svsp/ Type Attributes Name Initial integer :: nodr (NSPMAX) real(kind=8) :: t0sv (2**(NSPMAX+1)) real(kind=8) :: cksv (2**(NSPMAX+1)) real(kind=8) :: rpbsv (5,2**(NSPMAX+1)) prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=8) :: t0org real(kind=8) :: te real(kind=8) :: tdl real(kind=8) :: dmapjul real(kind=8) :: tcme0 common /ldptcl/ Type Attributes Name Initial real(kind=8) :: tf (NFMAX) real(kind=8) :: rf (3,NFMAX) real(kind=8) :: ef (NFMAX) real(kind=8) :: rmuf (NFMAX) integer :: np integer :: nf read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) shockfront (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir fl_open (subroutine) shockfront (program) sim3d (program) \">\n           common /rankstr/ Type Attributes Name Initial character(len=2) :: rankstr walk3d (subroutine) \">\n           common /seed/ Type Attributes Name Initial integer :: nseeds (nseedmax) read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=8) :: densw0 real(kind=8) :: vsw real(kind=8) :: k4ok2 real(kind=8) :: k6ok2 real(kind=8) :: omega real(kind=8) :: b1au real(kind=8) :: vom real(kind=8) :: facip preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=8) :: sp real(kind=8) :: sp0 real(kind=8) :: gp real(kind=8) :: ap real(kind=8) :: trgtfs (4) real(kind=8) :: scanw real(kind=8) :: h0 Variables Type Attributes Name Initial real(kind=8) :: rpb (5) real(kind=8) :: rp0 (5) real(kind=8) :: rp0org (5) real(kind=8) :: r0 (3) real(kind=8) :: rb (3) real(kind=8) :: x0 (6) real(kind=8) :: rnz real(kind=8) :: rnm integer :: nfbconst integer :: ndpdt integer :: num (3) real(kind=8) :: rb0 real(kind=8) :: rmax real(kind=8) :: rk real(kind=8) :: deltat real(kind=8) :: tc real(kind=8) :: tl real(kind=8) :: tmodel0 real(kind=8) :: t0org real(kind=8) :: te real(kind=8) :: tdl real(kind=8) :: dmapjul real(kind=8) :: tcme0 integer :: nodes integer :: chunk integer :: id integer :: iseed integer :: nseeds (nseedmax) real(kind=8) :: densw0 real(kind=8) :: vsw real(kind=8) :: k4ok2 real(kind=8) :: k6ok2 real(kind=8) :: omega real(kind=8) :: b1au real(kind=8) :: vom real(kind=8) :: facip real(kind=8) :: trgtfs (4) real(kind=8) :: sp real(kind=8) :: sp0 real(kind=8) :: gp real(kind=8) :: ap real(kind=8) :: scanw real(kind=8) :: h0 real(kind=8) :: df0 (3) real(kind=8) :: ddf0 (3,3) real(kind=8) :: b1s real(kind=8) :: gb1s (3) integer :: nsplvl real(kind=8) :: bv0 (3) real(kind=8) :: bm real(kind=8) :: cvtu (3) real(kind=8) :: gbmag (3) real(kind=8) :: bxgb2 (3) real(kind=8) :: dbbds real(kind=8) :: pol integer :: ino integer :: ino0 integer :: i integer :: npp integer :: n1 integer :: ns integer :: itjul integer :: iyear integer :: iyday real(kind=8) :: dnsk real(kind=8) :: vsk real(kind=8) :: vnr (3) real(kind=8) :: vnx (3) real(kind=8) :: ck real(kind=8) :: fs real(kind=8) :: t0 real(kind=8) :: tsp real(kind=8) :: e0 real(kind=8) :: flx real(kind=8) :: dflx real(kind=8) :: tnp real(kind=8) :: lsp real(kind=8) :: pa0 real(kind=8) :: df0dmu real(kind=8) :: ddf0dmu2 character(len=*), parameter :: writefmt = \"(e15.7,7(1pe13.5),i3,i3,i3)\" real(kind=8) :: t real(kind=8) :: pab real(kind=8) :: rate real(kind=8) :: hb real(kind=8) :: treal real(kind=8) :: tod real(kind=8) :: doy real(kind=8) :: tb real(kind=8) :: fb_ real(kind=8) :: dino Subroutines subroutine walk3d (iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, ino, bv0, nsplvl) Arguments Type Intent Optional Attributes Name integer :: iseed real(kind=8) :: rp0 (5) real(kind=8) :: rpb (5) real(kind=8) :: ck real(kind=8) :: fs real(kind=8) :: t0 real(kind=8) :: t real(kind=8) :: tsp integer :: ns integer :: ino real(kind=8) :: bv0 (3) integer :: nsplvl","tags":"","url":"program/sim3d_em.html"},{"title":"combon – Fortran Program","text":"Uses iso_fortran_env file_op Variables Type Attributes Name Initial real(kind=real64) :: b (3) real(kind=real64) :: cv (3) real(kind=real64) :: gb (3) real(kind=real64) :: b1rs integer :: i integer :: j integer :: k integer :: b1rs_infileunit integer :: maggrid_infileunit integer :: maggrid_outfileunit","tags":"","url":"program/combon.html"},{"title":"shockfront – Fortran Program","text":"Uses loadptcl cme_cross param datetime_utils dmumu iso_fortran_env epv fb random mtrx dxx file_op sim3d_utils ! force nodes = 1\n SHARED(cvgrid) Common Blocks e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) arriv_time (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm sim3d_em (program) sim3d (program) \">\n           common /nsucmin/ Type Attributes Name Initial integer :: nsucmin sim3d_em (program) sim3d (program) \">\n           common /npmax/ Type Attributes Name Initial integer :: npmax preparefb (subroutine) f0mod (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) walk3d (subroutine) sim3d (program) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst read_param (subroutine) split (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) walk3d (subroutine) sim3d (program) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt split (subroutine) sim3d_em (program) sim3d (program) \">\n           common /svsp/ Type Attributes Name Initial integer :: nodr (NSPMAX) real(kind=real64) :: t0sv (2**(NSPMAX+1)) real(kind=real64) :: cksv (2**(NSPMAX+1)) real(kind=real64) :: rpbsv (5,2**(NSPMAX+1)) prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) walk3d (subroutine) sim3d (program) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) sim3d (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir fl_open (subroutine) sim3d_em (program) sim3d (program) \">\n           common /rankstr/ Type Attributes Name Initial character(len=2) :: rankstr read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) walk3d (subroutine) sim3d (program) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) walk3d (subroutine) sim3d (program) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0 read_param (subroutine) get_rlambda0 (function) set_rlambda (subroutine) vfunc (subroutine) sim3d (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu read_param (subroutine) get_rlambdax (function) cofm (subroutine) set_rlambdax (subroutine) sim3d (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx Variables Type Attributes Name Initial integer, parameter :: NM1 = 16 integer, parameter :: NMXID = 40 real(kind=real64) :: rpb (5) real(kind=real64) :: rp0 (5) real(kind=real64) :: rp0org (5) real(kind=real64) :: r0 (3) real(kind=real64) :: rb (3) real(kind=real64) :: x0 (6) real(kind=real64) :: rnz real(kind=real64) :: rnm integer :: npp integer :: n1 integer :: num (3) real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst real(kind=real64) :: t0 real(kind=real64) :: t real(kind=real64) :: tnp integer :: ndpdt real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 real(kind=real64), allocatable :: tf (:) real(kind=real64), allocatable :: rf (:,:) real(kind=real64), allocatable :: ef (:) real(kind=real64), allocatable :: rmuf (:) integer :: np integer :: nf integer :: nodes integer :: chunk integer :: id integer :: iseed integer, allocatable :: nseeds (:) real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip real(kind=real64) :: trgtfs (4) real(kind=real64) :: ap real(kind=real64) :: h0 real(kind=real64) :: gp real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: scanw real(kind=real64) :: df0 (3) real(kind=real64) :: ddf0 (3,3) integer :: nsplvl real(kind=real64) :: bv0 (3) real(kind=real64) :: bm real(kind=real64) :: cvtu (3) real(kind=real64) :: gbmag (3) real(kind=real64) :: bxgb2 (3) real(kind=real64) :: dbbds real(kind=real64) :: pol real(kind=real64) :: b1s real(kind=real64) :: gb1s (3) real(kind=real64) :: dnsk0 real(kind=real64) :: vsk real(kind=real64) :: vnr (3) real(kind=real64) :: vnx (3) integer :: i integer :: j integer :: lsp integer :: ns real(kind=real64) :: df0dmu real(kind=real64) :: ddf0dmu2 real(kind=real64) :: dflux real(kind=real64) :: dflx real(kind=real64) :: doy real(kind=real64) :: flx real(kind=real64) :: flux real(kind=real64) :: e0 real(kind=real64) :: f1 real(kind=real64) :: pa0 real(kind=real64) :: ck real(kind=real64) :: fs real(kind=real64) :: pab real(kind=real64) :: hb real(kind=real64) :: rate real(kind=real64) :: tsp real(kind=real64) :: tb real(kind=real64) :: fb_ real(kind=real64) :: rdf real(kind=real64) :: treal real(kind=real64) :: tod integer :: itjul integer :: iyear integer :: iyday character(len=*), parameter :: writefmt = \"(i1,i3,8(1pe13.5),i3)\" integer :: nfl integer :: nsts Subroutines subroutine walk3d (iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, dnsk0, bv0, nsplvl) Arguments Type Intent Optional Attributes Name integer :: iseed real(kind=real64) :: rp0 (5) real(kind=real64) :: rpb (5) real(kind=real64) :: ck real(kind=real64) :: fs real(kind=real64) :: t0 real(kind=real64) :: t real(kind=real64) :: tsp integer :: ns real(kind=real64) :: dnsk0 real(kind=real64) :: bv0 (3) integer :: nsplvl subroutine sksurface (tsh, x, n) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: tsh real(kind=real64), intent(out) :: x (6) integer, intent(in) :: n","tags":"","url":"program/shockfront.html"},{"title":"mapb2s – Fortran Program","text":"Uses param iso_fortran_env rksolvers mtrx file_op Variables Type Attributes Name Initial real(kind=real64), parameter :: RSS = 2.5d0 real(kind=real64) :: magfieldgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64) :: gbgrid (0:N_R,0:N_THETA,0:N_PHI,3) real(kind=real64) :: b1rs (0:N_R,0:N_THETA,0:N_PHI,2) real(kind=real64) :: pol real(kind=real64) :: bmag real(kind=real64) :: bmag0 real(kind=real64) :: t real(kind=real64) :: dt real(kind=real64) :: r0 (3) real(kind=real64) :: r1 (3) real(kind=real64) :: r (3) real(kind=real64) :: b (3) real(kind=real64) :: dr integer :: n integer :: i integer :: j integer :: k integer :: chunk integer :: lr integer :: ltheta integer :: lphi real(kind=real64) :: rmin (3) real(kind=real64) :: rmin1 (3) integer :: map (0:N_R,0:N_THETA,0:N_PHI) integer :: n1 Functions function vfunc (t, r, pol) result(v) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t real(kind=real64), intent(in) :: r (3) real(kind=real64), intent(in) :: pol Return Value real(kind=real64), (3) function magfield (rvec) result(b) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rvec (3) Return Value real(kind=real64), (3)","tags":"","url":"program/mapb2s.html"},{"title":"arriv_time – Fortran Program","text":"Uses iso_fortran_env epv Common Blocks e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) sim3d (program) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm Variables Type Attributes Name Initial real(kind=real64) :: e real(kind=real64) :: v","tags":"","url":"program/arriv_time.html"},{"title":"sim3d – Fortran Program","text":"Uses loadptcl cme_cross param datetime_utils dmumu iso_fortran_env epv fb random mtrx dxx file_op sim3d_utils $OMP& SHARED(cvgrid) Common Blocks e2p (function) rp2e (function) rp2beta (function) beta2p (function) fs0 (function) prepareptcl (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) arriv_time (program) walk3d (subroutine) \">\n           common /specie/ Type Attributes Name Initial real(kind=real64) :: rnz real(kind=real64) :: rnm sim3d_em (program) shockfront (program) \">\n           common /nsucmin/ Type Attributes Name Initial integer :: nsucmin sim3d_em (program) shockfront (program) \">\n           common /npmax/ Type Attributes Name Initial integer :: npmax preparefb (subroutine) f0mod (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) \">\n           common /fbcnst/ Type Attributes Name Initial real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst read_param (subroutine) split (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) \">\n           common /ndpdt/ Type Attributes Name Initial integer :: ndpdt split (subroutine) sim3d_em (program) shockfront (program) \">\n           common /svsp/ Type Attributes Name Initial integer :: nodr (NSPMAX) real(kind=real64) :: t0sv (2**(NSPMAX+1)) real(kind=real64) :: cksv (2**(NSPMAX+1)) real(kind=real64) :: rpbsv (5,2**(NSPMAX+1)) prepareptcl (subroutine) split (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) \">\n           common /tmprm/ Type Attributes Name Initial real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 read_dmumuDG (subroutine) read_dmumuAH (subroutine) read_dmumuBK (subroutine) preparefb (subroutine) read_param (subroutine) read_dxx (subroutine) prepareptcl (subroutine) preparecme (subroutine) sim3d_em (program) shockfront (program) \">\n           common /dir/ Type Attributes Name Initial character(len=256) :: dir fl_open (subroutine) sim3d_em (program) shockfront (program) \">\n           common /rankstr/ Type Attributes Name Initial character(len=2) :: rankstr read_param (subroutine) cofm (subroutine) solarwind1 (function) f0mod (subroutine) split (subroutine) vfunc (subroutine) solarwind (subroutine) drvbmag (subroutine) preparecme (subroutine) inorout (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) sksurface (subroutine) shockfront (program) walk3d (subroutine) \">\n           common /bpark/ Type Attributes Name Initial real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip preparefb (subroutine) prepareptcl (subroutine) f0mod (subroutine) split (subroutine) vfunc (subroutine) walk3d (subroutine) sim3d_em (program) walk3d (subroutine) shockfront (program) walk3d (subroutine) \">\n           common /srcmod/ Type Attributes Name Initial real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: trgtfs (4) real(kind=real64) :: scanw real(kind=real64) :: h0 preparecme (subroutine) inorout (subroutine) sksurface (subroutine) \">\n           common /vsksw/ Type Attributes Name Initial real(kind=real64) :: vsksw real(kind=real64) :: tauf real(kind=real64) :: tauc1_0 real(kind=real64) :: tauc2 real(kind=real64) :: tauc2_0 real :: vcme0kmPs real(kind=real64) :: vcme0 read_param (subroutine) get_rlambda0 (function) set_rlambda (subroutine) vfunc (subroutine) shockfront (program) \">\n           common /ndmumu/ Type Attributes Name Initial integer :: ndmumu read_param (subroutine) get_rlambdax (function) cofm (subroutine) set_rlambdax (subroutine) shockfront (program) \">\n           common /ndxx/ Type Attributes Name Initial integer :: ndxx Variables Type Attributes Name Initial integer, parameter :: NM1 = 16 integer, parameter :: NMXID = 40 real(kind=real64) :: rpb (5) real(kind=real64) :: rp0 (5) real(kind=real64) :: r0 (3) real(kind=real64) :: rb (3) real(kind=real64) :: x0 (6) real(kind=real64) :: rnz real(kind=real64) :: rnm integer :: npp integer :: num (3) real(kind=real64) :: t0 real(kind=real64) :: t real(kind=real64) :: tnp real(kind=real64) :: rb0 real(kind=real64) :: rmax real(kind=real64) :: rk real(kind=real64) :: deltat real(kind=real64) :: tc real(kind=real64) :: tl real(kind=real64) :: tmodel0 integer :: nfbconst integer :: ndpdt real(kind=real64) :: t0org real(kind=real64) :: te real(kind=real64) :: tdl real(kind=real64) :: dmapjul real(kind=real64) :: tcme0 real(kind=real64), allocatable :: tf (:) real(kind=real64), allocatable :: rf (:,:) real(kind=real64), allocatable :: ef (:) real(kind=real64), allocatable :: rmuf (:) integer :: np integer :: nf integer :: nodes integer :: chunk integer :: id integer :: iseed integer, allocatable :: nseeds (:) real(kind=real64) :: densw0 real(kind=real64) :: vsw real(kind=real64) :: k4ok2 real(kind=real64) :: k6ok2 real(kind=real64) :: omega real(kind=real64) :: b1au real(kind=real64) :: vom real(kind=real64) :: facip real(kind=real64) :: trgtfs (4) real(kind=real64) :: sp real(kind=real64) :: sp0 real(kind=real64) :: gp real(kind=real64) :: ap real(kind=real64) :: scanw real(kind=real64) :: h0 integer :: nsplvl real(kind=real64) :: df0 (3) real(kind=real64) :: ddf0 (3,3) real(kind=real64) :: b1s real(kind=real64) :: gb1s (3) real(kind=real64) :: bv0 (3) real(kind=real64) :: bm real(kind=real64) :: cvtu (3) real(kind=real64) :: gbmag (3) real(kind=real64) :: bxgb2 (3) real(kind=real64) :: dbbds real(kind=real64) :: pol real(kind=real64) :: dnsk0 real(kind=real64) :: dnsk00 real(kind=real64) :: vsk real(kind=real64) :: vnx (3) real(kind=real64) :: vcme0kmPs integer :: i integer :: j integer :: lsp integer :: ns real(kind=real64) :: df0dmu real(kind=real64) :: ddf0dmu2 real(kind=real64) :: flux real(kind=real64) :: dflux real(kind=real64) :: flx real(kind=real64) :: dflx real(kind=real64) :: doy real(kind=real64) :: e0 real(kind=real64) :: f1 real(kind=real64) :: pa0 real(kind=real64) :: ck real(kind=real64) :: fs real(kind=real64) :: pab real(kind=real64) :: hb real(kind=real64) :: rate real(kind=real64) :: tsp real(kind=real64) :: tb real(kind=real64) :: fb_ real(kind=real64) :: rdf real(kind=real64) :: treal real(kind=real64) :: tod integer :: itjul integer :: iyear integer :: iyday character(len=*), parameter :: writefmt = \"(i1,i3,8(1pe13.5),i3)\" integer :: nfl integer :: nsts Subroutines subroutine walk3d (iseed, rp0, rpb, ck, fs, t0, t, tsp, ns, dnsk0, bv0, nsplvl) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: iseed real(kind=real64), intent(in) :: rp0 (5) real(kind=real64), intent(out) :: rpb (5) real(kind=real64), intent(inout) :: ck real(kind=real64), intent(inout) :: fs real(kind=real64), intent(in) :: t0 real(kind=real64), intent(out) :: t real(kind=real64), intent(in) :: tsp integer, intent(out) :: ns real(kind=real64), intent(inout) :: dnsk0 real(kind=real64), intent(inout) :: bv0 (3) integer, intent(in) :: nsplvl","tags":"","url":"program/sim3d.html"},{"title":"average – Fortran Program","text":"Uses iso_fortran_env ieee_arithmetic Variables Type Attributes Name Initial real(kind=real64) :: t real(kind=real64) :: fl real(kind=real64) :: fl2 real(kind=real64) :: ar (9) integer :: na integer :: i","tags":"","url":"program/average.html"},{"title":"  input – Fortran Program\n","text":"Variables Name Type Default Description vswSI real(kind=real64) None rsSI real(kind=real64) None bemNT real(kind=real64) None TsunDAY real(kind=real64) None facip real(kind=real64) None","tags":"","url":"namelist/input.html"},{"title":"  io – Fortran Program\n","text":"Variables Name Type Default Description f1n character(len=256) None f2n character(len=256) None","tags":"","url":"namelist/io.html"},{"title":"  dpdt – Fortran Program\n","text":"Variables Name Type Default Description ndpdt integer None","tags":"","url":"namelist/dpdt.html"},{"title":"  dmumu – Fortran Program\n","text":"Variables Name Type Default Description rlambda real(kind=real64) None nlambda integer None ndmumu integer None nlambdaconst integer None","tags":"","url":"namelist/dmumu.html"},{"title":"  dxx – Fortran Program\n","text":"Variables Name Type Default Description rlambdax real(kind=real64) None rlambday real(kind=real64) None ndxx integer None nlambdax integer None","tags":"","url":"namelist/dxx.html"},{"title":"  shkacc – Fortran Program\n","text":"Variables Name Type Default Description ecrmax real(kind=real64) None ecrmin real(kind=real64) None ob0 real(kind=real64) None obw real(kind=real64) None etinj real(kind=real64) None fampb real(kind=real64) None ratkp real(kind=real64) None","tags":"","url":"namelist/shkacc.html"},{"title":"  inputdxx – Fortran Program\n","text":"Variables Name Type Default Description gperCMS real(kind=real64) None bper real(kind=real64) None aper real(kind=real64) None","tags":"","url":"namelist/inputdxx.html"},{"title":"  fb – Fortran Program\n","text":"Variables Name Type Default Description rb0 real(kind=real64) None rmax real(kind=real64) None rk real(kind=real64) None deltat real(kind=real64) None tc real(kind=real64) None tl real(kind=real64) None tmodel0 real(kind=real64) None nfbconst integer None sclat real(kind=real64) None sclong real(kind=real64) None scanw real(kind=real64) None","tags":"","url":"namelist/fb.html"},{"title":"  inputdmumuDG – Fortran Program\n","text":"Variables Name Type Default Description du0 real(kind=real64) None rnu real(kind=real64) None delta real(kind=real64) None va real(kind=real64) None","tags":"","url":"namelist/inputdmumudg.html"},{"title":"  inputdmumuAH – Fortran Program\n","text":"Variables Name Type Default Description du0 real(kind=real64) None b1 real(kind=real64) None a1 real(kind=real64) None","tags":"","url":"namelist/inputdmumuah.html"},{"title":"  inputdmumuBK – Fortran Program\n","text":"Variables Name Type Default Description du0 real(kind=real64) None rlambda real(kind=real64) None nlambda integer None b1 real(kind=real64) None a1 real(kind=real64) None qindx real(kind=real64) None sigma real(kind=real64) None h real(kind=real64) None","tags":"","url":"namelist/inputdmumubk.html"},{"title":"rksolvers.f90 – Fortran Program","text":"Source Code MOdule rksolvers use iso_fortran_env , only : real64 implicit none interface function odefun ( x , y , p ) result ( v ) use iso_fortran_env , only : real64 implicit none real ( kind = real64 ) :: v ( 3 ) real ( kind = real64 ), intent ( in ) :: x real ( kind = real64 ), intent ( in ) :: y ( 3 ) real ( kind = real64 ), intent ( in ) :: p end function end interface contains !function rk4(y, dydx, n, x, h, f, param) result(yout) !  integer, intent(in)            :: n !  real(kind=real64), intent(in)  :: h, x, dydx(n), y(n) !  procedure(odefun)              :: f !  real(kind=real64)              :: yout(n) !  !real(kind=real64), dimension(3), external :: odefun !  integer                        :: i !  real(kind=real64)              :: hh, xh, dym(n), dyt(n), yt(n) !  real(kind=real64)              :: param !  hh = h * 0.5 !  xh = x + hh !  yt(:) = y(:) + hh * dydx(:) !  dyt = f(xh, yt, param) !  yt(:) = y(:) + hh * dyt(:) !  dym = f(xh, yt, param) !  yt(:) = y(:) + h*dym(:) !  dym(:) = dyt(1:n) + dym(:) !  dyt = f(x+h, yt, param) !  yout(1:n) = y(:) + (h/6.0) * (dydx(:) + dyt(:) + 2.0*dym(:)) !end function ! single step of RK4 function rk4 ( f , x0 , y0 , h , odefun_param ) result ( yout ) procedure ( odefun ) :: f real ( kind = real64 ) :: x0 real ( kind = real64 ) :: y0 (:) real ( kind = real64 ) :: h real ( kind = real64 ) :: odefun_param real ( kind = real64 ), allocatable :: yout (:) integer :: n real ( kind = real64 ), allocatable :: k1 (:), k2 (:), k3 (:), k4 (:) n = size ( y0 ) allocate ( k1 ( n ), k2 ( n ), k3 ( n ), k4 ( n ), yout ( n )) ! basically just lifted from wikipedia k1 = f ( x0 , y0 , odefun_param ) k2 = f ( x0 + h / 2 , y0 + h / 2 * k1 , odefun_param ) k3 = f ( x0 + h / 2 , y0 + h / 2 * k2 , odefun_param ) k4 = f ( x0 + h , y0 + h * k3 , odefun_param ) yout = y0 + h / 6 * ( k1 + 2 * k2 + 2 * k3 + k4 ) end function end module","tags":"","url":"sourcefile/rksolvers.f90.html"},{"title":"maggrid.f90 – Fortran Program","text":"Source Code program maggrid ! USES environment variables !     SHTC_FILE !     MAGGRID_FILE use iso_fortran_env , only : real64 , output_unit use fgsl , only : fgsl_sf_legendre_Plm use param , only : pi , N_R , N_THETA , N_PHI , DEG_TO_RAD !, bgrid, gbgrid, cvgrid use mtrx , only : norm2 use file_op , only : read_shtc , write_maggrid implicit none include 'omp_lib.h' integer , parameter :: NS = 40 real ( kind = real64 ) :: rvec ( 3 ), b ( 3 ), cvtu ( 3 ), gbmag ( 3 ) real ( kind = real64 ) :: g ( 0 : NS , 0 : NS ), h ( 0 : NS , 0 : NS ) real ( kind = real64 ) :: srfctrtl ( NS , NS ) real ( kind = real64 ) :: bmag , dbbds integer :: id integer :: chunk real ( kind = real64 ) :: starttime , stoptime integer :: i , j , k ! bgrid and gbgrid must be manually specified, using the one in param segfaults real ( kind = real64 ) :: bgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) real ( kind = real64 ) :: gbgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) !Vector of lower-triangular matrices, where each matrix is of the form !```math !\\begin{bmatrix} !P_0&#94;0    & \\cdot    & \\cdot    & \\cdots & \\cdot       & \\cdot       & \\cdot  \\\\ !P_1&#94;0    & P_1&#94;1    & \\cdot    & \\cdots & \\cdot       & \\cdot       & \\cdot  \\\\ !P_2&#94;0    & P_2&#94;1    & P_2&#94;2    & \\cdots & \\cdot       & \\cdot       & \\cdot  \\\\ !\\vdots   & \\vdots   & \\vdots   & \\ddots & \\vdots      & \\vdots      & \\vdots \\\\ !P_{38}&#94;0 & P_{38}&#94;1 & P_{38}&#94;2 & \\cdots & P_{38}&#94;{38} & \\cdot       & \\cdot  \\\\ !P_{39}&#94;0 & P_{39}&#94;1 & P_{39}&#94;2 & \\cdots & P_{39}&#94;{38} & P_{39}&#94;{39} & \\cdot  \\\\ !P_{40}&#94;0 & P_{40}&#94;1 & P_{40}&#94;2 & \\cdots & P_{40}&#94;{38} & P_{40}&#94;{39} & P_{40}&#94;{40} !\\end{bmatrix} !``` !where each ``P_ℓ&#94;m`` is a matrix evaluated at an ``x`` given by the vector's !index, and each ``⋅`` signifies a zero entry in the matrix. real ( kind = real64 ) :: ALP_TABLE ( 0 : N_THETA , 0 : NS , 0 : NS ) ! first derivative real ( kind = real64 ) :: DALP_TABLE ( 0 : N_THETA , 0 : NS , 0 : NS ) ! second derivative real ( kind = real64 ) :: D2ALP_TABLE ( 0 : N_THETA , 0 : NS , 0 : NS ) chunk = 1 !  load spherical harmonic transform coefficients ! USES environment variable SHTC_FILE call read_shtc ( g , h , NS ) call factorialratio ( srfctrtl ) starttime = omp_get_wtime () !$OMP PARALLEL DEFAULT(private) SHARED(chunk,bgrid,gbgrid,g,h,srfctrtl) id = omp_get_thread_num () print * , __ FILE__ , \":\" , __ LINE__ , \": I am thread\" , id , \", Thread start time\" , starttime flush ( output_unit ) !$OMP DO SCHEDULE(STATIC,chunk) do i = 0 , N_R rvec ( 1 ) = 1.0 + i / 10 0.0 do j = 0 , N_THETA rvec ( 2 ) = j * pi / 18 0.0 do k = 0 , N_PHI rvec ( 3 ) = k * pi / 18 0.0 call magfield ( rvec , b , bmag , cvtu , gbmag , dbbds , srfctrtl , g , h ) bgrid ( i , j , k ,:) = b (:) !  curvature not needed !cvgrid(i,j,k,:) = cvtu(:) gbgrid ( i , j , k ,:) = gbmag (:) end do end do end do !$OMP END PARALLEL call write_maggrid ( bgrid , gbgrid ) stoptime = omp_get_wtime () print \"('elapsed time: ',f0.5,'s, my id: ',i0)\" , stoptime - starttime , id contains subroutine factorialratio ( fac_table ) real ( kind = real64 ), intent ( out ) :: fac_table ( NS , NS ) integer :: l , m ! we don't need the factor for l = 0 (which only has m = 0) or any m = 0 do l = 1 , NS do m = 1 , l ! say, S = srfctrtl ! then, S_{l,m} = sqrt(2 * (l-m)! / (l+m)!) ! but using gamma directly would cause an overflow ! LaTeX: S_{\\ell,m} = \\sqrt{2 \\frac{(\\ell - m)!}{(\\ell + m)!}} fac_table ( l , m ) = sqrt ( 2.d0 * exp ( & ! the actual ratio part (turns into subtraction for ln) log_gamma ( real ( l - m + 1 , kind = real64 )) - log_gamma ( real ( l + m + 1 , kind = real64 )) & )) end do end do end subroutine subroutine magfield ( rvec , b , bmag , cvtu , gbmag , dbbds , srfctrtl , g , h ) real ( kind = real64 ), intent ( in ) :: rvec ( 3 ) ! position vector real ( kind = real64 ), intent ( out ) :: b ( 3 ), bmag , cvtu ( 3 ), gbmag ( 3 ), dbbds real ( kind = real64 ), intent ( in ) :: srfctrtl ( NS , NS ) real ( kind = real64 ), intent ( in ) :: g ( 0 : NS , 0 : NS ), h ( 0 : NS , 0 : NS ) real ( kind = real64 ), parameter :: RSS = 2.5d0 ! spherical coordinates of position vector (radial, colatitude/inclination, azimuthal) real ( kind = real64 ) :: r , theta , phi real ( kind = real64 ) :: ab ( 3 ), db ( 3 , 3 ) !derivative of components only ! legendre polynomials real ( kind = real64 ) :: alp ( 0 : NS + 2 , 0 : NS + 2 ) real ( kind = real64 ) :: schmt , dalp , d2alp real ( kind = real64 ) :: costheta , sintheta real ( kind = real64 ) :: cosmphi , sinmphi real ( kind = real64 ) :: r0rl2 , rrs2l1 , r0rs2l1 , ghmf , dghmf integer :: l , m r = rvec ( 1 ) theta = rvec ( 2 ) phi = rvec ( 3 ) if ( r > RSS ) r = RSS costheta = cos ( theta ) sintheta = sin ( theta ) if ( sintheta <= 1.745d-4 ) then sintheta = 1.745d-4 costheta = sqrt ( 1.0 - sintheta ** 2 ) if ( theta > 1.57 ) costheta = - costheta end if !  Associated Legendre Polynomial alp = 0.0 do l = 0 , NS + 2 do m = 0 , l alp ( l , m ) = plgndr ( l , m , costheta ) end do end do b = 0.0 db = 0 do l = 1 , NS r0rl2 = r ** ( - 2 - l ) rrs2l1 = ( r / RSS ) ** ( 2 * l + 1 ) r0rs2l1 = RSS ** ( - 2 * l - 1 ) * l + 1 + l do m = 0 , l !  convert to Schmidt (semi-)normalized Associated Legendre Polynomial if ( m == 0 ) then schmt = 1 dalp = alp ( l , 1 ) d2alp = ( - ( l + 1 ) * l * alp ( l , 0 ) + alp ( l , 2 )) / 2.0 else schmt = ( - 1 ) ** m * srfctrtl ( l , m ) dalp = ( - ( l + m ) * ( l - m + 1 ) * alp ( l , m - 1 ) + alp ( l , m + 1 )) / 2.0 if ( m == 1 ) then d2alp = ( alp ( l , 3 ) - ( 3 * l * l - 3 * l - 2 ) * alp ( l , 1 )) / 4.0 else d2alp = (& alp ( l , m + 2 ) & - (( l + m + 1 ) * ( l - m ) + ( l + m ) * ( l - m + 1 )) * alp ( l , m ) & + ( l + m ) * ( l - m + 1 ) * ( l + m - 1 ) * ( l - m + 2 ) * alp ( l , m - 2 ) & ) / 4.0 end if end if cosmphi = cos ( m * phi ) sinmphi = sin ( m * phi ) ghmf = g ( l , m ) * cosmphi + h ( l , m ) * sinmphi dghmf = m * ( - g ( l , m ) * sinmphi + h ( l , m ) * cosmphi ) ab ( 1 ) = r0rl2 * ghmf * schmt * alp ( l , m ) * ( l + 1 + l * rrs2l1 ) / r0rs2l1 ab ( 2 ) = - r0rl2 * ghmf * schmt * dalp * ( 1 - rrs2l1 ) / r0rs2l1 ab ( 3 ) = - r0rl2 * dghmf * schmt * alp ( l , m ) / sintheta * ( 1 - rrs2l1 ) / r0rs2l1 b (:) = ab (:) + b (:) if ( ab ( 1 ) /= 0 ) then db ( 1 , 1 ) = db ( 1 , 1 ) - ab ( 1 ) * (( l + 2 ) * ( l + 1 ) - l * ( l - 1 ) * rrs2l1 ) / ( l + 1 + l * rrs2l1 ) / r db ( 2 , 1 ) = db ( 2 , 1 ) + ab ( 1 ) / alp ( l , m ) * dalp db ( 3 , 1 ) = db ( 3 , 1 ) + ab ( 1 ) / ghmf * dghmf end if if ( ab ( 2 ) /= 0 ) then db ( 1 , 2 ) = db ( 1 , 2 ) - ab ( 2 ) * ( l + 2 + ( l - 1 ) * rrs2l1 ) / ( 1 - rrs2l1 ) / r db ( 2 , 2 ) = db ( 2 , 2 ) + ab ( 2 ) / dalp * d2alp db ( 3 , 2 ) = db ( 3 , 2 ) + ab ( 2 ) / ghmf * dghmf end if if ( ab ( 3 ) /= 0 ) then db ( 1 , 3 ) = db ( 1 , 3 ) - ab ( 3 ) * ( l + 2 + ( l - 1 ) * rrs2l1 ) / ( 1 - rrs2l1 ) / r db ( 2 , 3 ) = db ( 1 , 3 ) + ab ( 3 ) / alp ( l , m ) * dalp - ab ( 3 ) * costheta / sintheta db ( 3 , 3 ) = db ( 1 , 3 ) + ab ( 3 ) / dghmf * m * m * ghmf end if end do end do bmag = norm2 ( b ) gbmag ( 1 ) = sum ( b ( 1 : 3 ) * db ( 1 , 1 : 3 )) / bmag gbmag ( 2 ) = sum ( b ( 1 : 3 ) * db ( 2 , 1 : 3 )) / ( bmag * r ) gbmag ( 3 ) = sum ( b ( 1 : 3 ) * db ( 3 , 1 : 3 )) / ( bmag * r * sintheta ) dbbds = sum ( b ( 1 : 3 ) * gbmag ( 1 : 3 )) / ( bmag * bmag ) cvtu ( 1 ) = ( & b ( 1 ) * db ( 1 , 1 ) + b ( 2 ) * db ( 2 , 1 ) / r & + b ( 3 ) * db ( 3 , 1 ) / r / sintheta - ( b ( 2 ) * b ( 2 ) + b ( 3 ) * b ( 3 )) / r & ) / bmag cvtu ( 2 ) = ( & b ( 1 ) * db ( 1 , 2 ) + b ( 2 ) * db ( 2 , 2 ) / r & + b ( 3 ) * db ( 3 , 2 ) / r / sintheta & + ( b ( 2 ) * b ( 1 ) - b ( 3 ) * b ( 3 ) * costheta / sintheta ) / r & ) / bmag cvtu ( 3 ) = ( & b ( 1 ) * db ( 1 , 3 ) + b ( 2 ) * db ( 2 , 3 ) / r & + b ( 3 ) * db ( 3 , 3 ) / r / sintheta & + ( b ( 3 ) * b ( 1 ) + b ( 3 ) * b ( 2 ) * costheta / sintheta ) / r & ) / bmag cvtu = ( cvtu - dbbds * b ) / bmag ! curvature perpendicular to B if ( rvec ( 1 ) > RSS ) then b ( 1 ) = b ( 1 ) * ( RSS / rvec ( 1 )) ** 2 bmag = norm2 ( b ) cvtu = 0.0 gbmag ( 1 ) = - 2 * bmag / rvec ( 1 ) gbmag ( 2 ) = gbmag ( 2 ) * ( RSS / rvec ( 1 )) ** 3 gbmag ( 3 ) = gbmag ( 3 ) * ( RSS / rvec ( 1 )) ** 3 dbbds = b ( 1 ) * gbmag ( 1 ) / bmag / bmag end if end subroutine real ( kind = real64 ) function plgndr ( l , m , x ) integer , intent ( in ) :: l , m real ( kind = real64 ), intent ( in ) :: x integer :: i ! iteration variable real ( kind = real64 ) :: pll real ( kind = real64 ) :: somx2 ! square root of 1 - x&#94;2 real ( kind = real64 ) :: pmm ! legendre polynomial of order (m, m) real ( kind = real64 ) :: pmmp1 ! legendre polynomial of order (m+1, m) if ( m < 0 . or . m > l . or . abs ( x ) > 1.0 ) then print * , 'bad arguments in plgndr' stop 1 end if pmm = 1.0 ! compute P_m&#94;m = (-1)&#94;m (1-x&#94;2)&#94;{m/2} \\prod_{i=1}&#94;m (2i+1) if ( m > 0 ) then somx2 = sqrt ( 1.0 - x * x ) ! compute \\prod_{i=1}&#94;m (2i+1) = (2m-1)!! do i = 1 , m pmm = pmm * ( 2 * i + 1 ) end do pmm = pmm * somx2 ** m if ( mod ( m , 2 ) == 1 ) pmm = - pmm ! factor of (-1)&#94;m end if if ( l == m ) then plgndr = pmm else pmmp1 = x * ( 2 * m + 1 ) * pmm ! compute P_{m+1}&#94;m = x (2m + 1) P_m&#94;m if ( l == m + 1 ) then plgndr = pmmp1 else do i = m + 2 , l pll = ( x * ( 2 * i - 1 ) * pmmp1 - ( i + m - 1 ) * pmm ) / ( i - m ) pmm = pmmp1 pmmp1 = pll end do plgndr = pll end if end if end function subroutine init_aplm ( alp_arr , dalp_arr , d2alp_arr ) ! populate alp, dalp, d2alp with the associated legendre polynomials, ! and its first and second derivatives respectively real ( kind = real64 ), intent ( out ) :: alp_arr ( 0 : N_THETA , 0 : NS , 0 : NS ) real ( kind = real64 ), intent ( out ) :: dalp_arr ( 0 : N_THETA , 0 : NS , 0 : NS ) real ( kind = real64 ), intent ( out ) :: d2alp_arr ( 0 : N_THETA , 0 : NS , 0 : NS ) integer :: j integer :: l , m real ( kind = real64 ) :: theta , costheta !alp(0,:,:) = 1 do j = 0 , N_THETA costheta = cos ( j * DEG_TO_RAD ) do l = 0 , NS do m = 0 , NS alp_arr ( j , l , m ) = fgsl_sf_legendre_Plm ( l , m , costheta ) end do end do end do end subroutine end program","tags":"","url":"sourcefile/maggrid.f90.html"},{"title":"random.f90 – Fortran Program","text":"Source Code module random use iso_fortran_env , only : real64 implicit none contains !real(kind=real64) function bindev(idum) !  integer, intent(in out) :: idum !  !U    USES ran2 !  if (ran2(idum) > 0.5d0) then !    bindev = 1.0 !  else !    bindev = -1.0 !  end if !end function real ( kind = real64 ) impure function gasdev ( idum ) ! This function uses Box-Muller transform to generate two normally ! distributed random numbers at a time integer , intent ( in out ) :: idum real ( kind = real64 ) :: fac , rsq , v1 , v2 !U    USES ran2 logical , save :: gaus_stored = . false . real ( kind = real64 ), save :: gset = 0 !$omp threadprivate(gset,gaus_stored) if ( gaus_stored ) then gasdev = gset gaus_stored = . false . else ! choose a point in the [-1, 1] x [-1, 1] square in the cartesian plane 1 v1 = 2.0 * ran2 ( idum ) - 1.0 v2 = 2.0 * ran2 ( idum ) - 1.0 ! if the point is also not within the unit circle, reject it and ! choose another point that will hopefully be better rsq = v1 ** 2 + v2 ** 2 if ( rsq >= 1.0 . or . rsq == 0.0 ) goto 1 ! the actual Box-Muller part fac = sqrt ( - 2.0 * log ( rsq ) / rsq ) gasdev = v1 * fac ! save this for the next time the function is called gset = v2 * fac gaus_stored = . true . end if end function real ( kind = real64 ) function ran2 ( idum ) ! this code is from WH Press's Numerical Recipes book integer , intent ( in out ) :: idum ! state of random number generator integer , parameter :: & IM1 = 2147483563 , IM2 = 2147483399 , IMM1 = IM1 - 1 , & IA1 = 40014 , IA2 = 40692 , & IQ1 = 53668 , IQ2 = 52774 , & IR1 = 12211 , IR2 = 3791 , & NTAB = 32 , NDIV = 1 + IMM1 / NTAB real ( kind = real64 ), parameter :: AM = 1 d0 / IM1 , EPS = 1.2d-7 real ( kind = real64 ), parameter :: RNMX = 1.d0 - EPS integer , save :: idum2 = 123456789 , iv ( NTAB ) = 0 , iy = 0 integer :: j , k !$omp threadprivate(idum2,iv,iy) if ( idum <= 0 ) then ! initialize idum = max ( - idum , 1 ) ! prevent idum = 0 idum2 = idum do j = NTAB + 8 , 1 , - 1 ! load shuffle table after 8 warm-ups k = idum / IQ1 idum = IA1 * ( idum - k * IQ1 ) - k * IR1 if ( idum < 0 ) idum = idum + IM1 if ( j <= NTAB ) iv ( j ) = idum end do iy = iv ( 1 ) end if k = idum / IQ1 idum = IA1 * ( idum - k * IQ1 ) - k * IR1 if ( idum < 0 ) idum = idum + IM1 k = idum2 / IQ2 idum2 = IA2 * ( idum2 - k * IQ2 ) - k * IR2 if ( idum2 < 0 ) idum2 = idum2 + IM2 j = 1 + iy / NDIV iy = iv ( j ) - idum2 iv ( j ) = idum if ( iy < 1 ) iy = iy + IMM1 ran2 = min ( AM * iy , RNMX ) end function end module random","tags":"","url":"sourcefile/random.f90.html"},{"title":"2damrhistss.f90 – Fortran Program","text":"Source Code program histogram !   build histogram use iso_fortran_env , only : real64 implicit none real ( kind = real64 ), parameter :: twopi = 2.d0 * 3.14159265358979323846d0 ! km real ( kind = real64 ), parameter :: rss = 2.5 , rs = 6.96e5 ! raw km/s converted to Rs/min real ( kind = real64 ), parameter :: vsw = 40 0.0 / rs * 60 ! angular frequency of sun's rotation real ( kind = real64 ), parameter :: omega = twopi / ( 2 7.27 * 24 * 60 ) real ( kind = real64 ), parameter :: k4ok2 = 1 2.4242 , k6ok2 = 24 2.4242 real ( kind = real64 ) :: al ( 8 ) real ( kind = real64 ) :: ra , theta , phi real ( kind = real64 ) :: hist ( 91 , 46 ), hs ( 91 , 46 ) real ( kind = real64 ) :: tpsw real ( kind = real64 ) :: xmu !integer                     :: aa(2) !integer                     :: specfile integer :: n , nn , ns , nz integer :: i , j , ii , jj , jjj , iy , ix !open(newunit=specfile, file='spec.dat_e00') !do i = 1,10 !  read(newunit=specfile,*) !end do !close(newunit=specfile) n = 0 hist = 0.0 do i = 1 , 1569000 read ( * , * , end = 99 ) al , nn if ( al ( 1 ) == - 100 0.00 ) exit ra = al ( 3 ) tpsw = & ( ra - rss ) & - rss * log ( ra / rss ) & + k4ok2 * ( 1 / rss / 2 - 1 / ra + rss / ra ** 2 / 2 ) & + k6ok2 * ( 1 / rss ** 3 / 12 - 1 / ra ** 3 / 3 + rss / ra ** 4 / 4 ) tpsw = tpsw / vsw theta = al ( 4 ) phi = al ( 5 ) + omega * tpsw phi = atan2 ( sin ( phi ), cos ( phi )) write ( 12 , * ) theta , phi if ( phi < 0 ) phi = phi + twopi n = n + 1 if ( ra >= 2.50 ) then xmu = cos ( theta ) iy = floor ( theta / twopi * 90 ) + 1 ix = floor ( phi / twopi * 90 ) + 1 hist ( ix , iy ) = hist ( ix , iy ) + 1 end if end do 99 continue !  smoothing hs = 0 do i = 1 , 45 do j = 1 , 90 if ( hist ( j , i ) < 10 ) then ! use 5x5 box smoothing ns = 0 nz = 0 do ii = i - 2 , i + 2 do jj = j - 2 , j + 2 if ( ii > 0 . and . ii < 46 ) then jjj = jj if ( jj < 1 ) jjj = 90 + jj if ( jj > 90 ) jjj = jj - 90 ns = ns + 1 if ( hist ( jjj , ii ) /= 0 ) nz = nz + 1 hs ( j , i ) = hs ( j , i ) + hist ( jjj , ii ) end if end do end do end if if ( 3 * nz > ns ) then hs ( j , i ) = hs ( j , i ) / ns else hs ( j , i ) = hist ( j , i ) end if if ( hist ( j , i ) > 10 . and . hist ( j , i ) < 100 ) then ! use 3x3 box ns = 0 do ii = i - 1 , i + 1 do jj = j - 1 , j + 1 if ( ii > 0 . and . ii < 46 ) then jjj = jj if ( jj < 1 ) jjj = 90 + jj if ( jj > 90 ) jjj = jj - 90 ns = ns + 1 if ( hist ( jjj , ii ) /= 0 ) nz = nz + 1 hs ( j , i ) = hs ( j , i ) + hist ( jjj , ii ) end if end do end do end if if ( 3 * nz > ns ) then hs ( j , i ) = hs ( j , i ) / ns else hs ( j , i ) = hist ( j , i ) end if if ( hist ( j , i ) >= 100 ) hs ( j , i ) = hist ( j , i ) end do end do hist = hs do i = 1 , 45 do j = 1 , 90 theta = ( i - 0.5 ) / 90 * twopi phi = ( j - 0.5 ) / 90 * 360 write ( * , \"(2f8.3,e12.4,f6.0)\" ) theta * 360 / twopi , phi , hist ( j , i ) / n / sin ( theta ), hist ( j , i ) end do end do end program","tags":"","url":"sourcefile/2damrhistss.f90.html"},{"title":"file_op.f90 – Fortran Program","text":"Source Code module file_op use iso_fortran_env , only : real64 , int64 , error_unit use param , only : TWOPI , NFMAX , NSEEDMAX , N_R , N_THETA , N_PHI , pi implicit none ! USES environment variables !     SEEDS_FILENAME !     PARAM_OUTDIR_PATH !     PARAM_NODES contains ! opens file pclfil and assigns to nsts and ! opens file anfil  and assigns to nfl ! pclfil and anfil is set in readparam subroutine fl_open ( nfl , nsts ) integer , intent ( out ) :: nfl , nsts character ( len = 256 ) :: pclfil , finfil , sucfil , nodesfil , anfil , anstfil common / filnm / pclfil , finfil , sucfil , nodesfil , anfil , anstfil character ( len = 2 ) :: pclfil_n integer :: nfinish common / nfinish / nfinish character ( len = 2 ) :: rankstr common / rankstr / rankstr nfinish = 0 open ( newunit = nsts , file = trim ( pclfil )) open ( newunit = nfl , file = trim ( anfil )) end subroutine subroutine record_nodes ( nodes ) integer , intent ( in ) :: nodes integer :: nnds character ( len = 256 ) :: pclfil , finfil , sucfil , nodesfil , anfil , anstfil common / filnm / pclfil , finfil , sucfil , nodesfil , anfil , anstfil open ( newunit = nnds , file = trim ( nodesfil )) write ( nnds , * ) nodes close ( nnds ) end subroutine !subroutine fl_close(nfl, nsts) !  integer, intent(in) :: nfl, nsts !  close(nfl) !  close(nsts) !end subroutine subroutine write_head ( nfl , nf ) integer , intent ( in ) :: nfl integer , intent ( in ) :: nf write ( nfl , '(a,i0)' ) 'nf = ' , nf write ( nfl , '(a)' ) 'Fluxes are calculated at the locations:' write ( nfl , '(a)' ) 'Time,postion(r theta phi),energy/n,\\mu,flux,dflux' end subroutine !subroutine update_finish !  integer, parameter  :: NSTEP = 10 !  character(len=256)  :: pclfil, finfil, sucfil, nodesfil, anfil, anstfil !  common/filnm/pclfil,finfil,sucfil,nodesfil,anfil,anstfil !  integer             :: np, nmu, nloc, nfinish !  common/ldptclnum/np,nmu,nloc !  common/nfinish/nfinish !  character(len=2)    :: rankstr !  common/rankstr/rankstr !  integer             :: nfin !  nfinish = nfinish + 1 !  open(newunit=nfin, file=trim(finfil)//rankstr(1:2)) !  write(nfin,*) nfinish, 'of', nmu*nloc !  close(nfin) !end subroutine subroutine open_file_from_environment (& env_var_name , fileunit , file_form , file_status ) use iso_fortran_env , only : error_unit ! get a file name from the environment, open it, and return the open unit, ! taking care of errors along the way (stopping the program) character ( len =* ), intent ( in ) :: env_var_name , file_form character ( len =* ), intent ( in ), optional :: file_status integer , intent ( out ) :: fileunit character ( len = 256 ) :: filename integer :: stat call get_environment_variable ( env_var_name , filename , status = stat ) if ( stat /= 0 ) then write ( error_unit , '(a)' ) & \"Error reading $\" // env_var_name // \" from the environment\" stop 1 end if if ( present ( file_status )) then open ( newunit = fileunit , file = trim ( filename ), & iostat = stat , form = file_form , status = file_status ) else open ( newunit = fileunit , file = trim ( filename ), & iostat = stat , form = file_form ) end if if ( stat /= 0 ) then write ( error_unit , '(a)' ) & \"Error opening \" // trim ( filename ) // & \" (filename obtained from $\" // env_var_name // \")\" stop 1 end if end subroutine ! THIS IS THE MOST EVIL FUNCTION YOU HAVE EVER SEEN. COMMON BLOCKS GALORE. ! YOU'LL NEED TO REFACTOR IT, BUT IT WILL NOT BE AN EASY TASK. HAVE FUN. ! AND GOOD LUCK. YOU'LL NEED IT. subroutine read_param ( nodes , nseeds ) ! USES environment variables !     PARAM_OUTDIR_PATH !     PARAM_NODES !integer, parameter :: timenum = 10 ! read in parameters to characterize particle species ! and solar wind and magnetic field condition integer , intent ( out ) :: nodes !common /magfield/b1au !common /heliosphere/r0,rau,vsw,omega real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 real ( kind = real64 ) :: omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip integer , allocatable , intent ( out ) :: nseeds (:) real ( kind = real64 ) :: vswSI , rsSI , bemNT , TsunDAY namelist / input / vswSI , rsSI , bemNT , TsunDAY , facip character ( len = 256 ) :: dir common / dir / dir character ( len = 256 ) :: f1n , f2n namelist / io / f1n , f2n character ( len = 256 ) :: pclfil , finfil , sucfil , nodesfil , anfil , anstfil common / filnm / pclfil , finfil , sucfil , nodesfil , anfil , anstfil real ( kind = real64 ) :: rlambda common / rlambda / rlambda real ( kind = real64 ) :: rlambdax , rlambday common / rlambdax / rlambdax , rlambday integer :: nlambda common / nlambda / nlambda integer :: nlambdaconst common / nlambdaconst / nlambdaconst integer :: nlambdax common / nlambdax / nlambdax integer :: ndmumu common / ndmumu / ndmumu integer :: ndxx common / ndxx / ndxx integer :: ndpdt common / ndpdt / ndpdt namelist / dpdt / ndpdt namelist / dmumu / rlambda , nlambda , ndmumu , nlambdaconst namelist / dxx / rlambdax , rlambday , ndxx , nlambdax real ( kind = real64 ) :: ecrmax , ecrmin , ob0 , obw , etinj , fampb , ratkp namelist / shkacc / ecrmax , ecrmin , ob0 , obw , etinj , fampb , ratkp common / acc / ecrmax , ecrmin , ob0 , obw , etinj , fampb , ratkp integer :: nfldfile ! Default constants ! character ( len =* ), parameter :: NMLFL = 'inputfld.nml' ! TODO ini this character ( len =* ), parameter :: DIRPATH_ENV = \"PARAM_OUTDIR_PATH\" character ( len =* ), parameter :: NODE_ENV = \"PARAM_NODES\" real ( kind = real64 ), parameter :: daySI = 8640 0.0 ! locals ! integer :: staterr real ( kind = real64 ) :: rsperdaySI character ( len = 256 ) :: tmp_env_buf ! there are two things in dir.dat (used in old implementation) ! the dir where to put other data files ! and the number of nodes. ! guess what they can be. that's right, environment variables. ! chocolate for you! call get_environment_variable ( DIRPATH_ENV , value = dir , status = staterr ) if ( staterr /= 0 ) then write ( error_unit , '(a)' ) \"Error reading $\" // DIRPATH_ENV // \" from environment\" stop 1 end if !print *, dir call get_environment_variable ( NODE_ENV , value = tmp_env_buf , status = staterr ) if ( staterr /= 0 ) then write ( error_unit , '(a)' ) \"Error reading $\" // NODE_ENV // \" from environment\" stop 1 end if ! parse into int read ( tmp_env_buf , * ) nodes call read_seeds ( nodes , nseeds ) open ( newunit = nfldfile , file = trim ( dir ) // NMLFL , status = 'old' , iostat = staterr ) read ( nfldfile , nml = input ) read ( nfldfile , nml = dmumu ) read ( nfldfile , nml = dxx ) read ( nfldfile , nml = shkacc ) read ( nfldfile , nml = dpdt ) read ( nfldfile , nml = io ) ! NOTE this is where pclfil and nfil comes from close ( nfldfile ) ! ! magnetic field at 1AU in the equator (nT) ! !write(stdout, nml=input) !write(stdout, nml=seeds) !Tsun = 26.27 ! ! Va=30 km/s, Rs=6.96e8 m ! rsperdaySI = rsSI / daySI vsw = vswSI / ( rsperdaySI * 24 * 60 ) omega = twopi / ( TsunDAY * 24 * 60 ) vom = vsw / omega ! distance in Rs now, time in min if ( facip == 0 ) facip = 1.0 b1au = bemNT / sqrt ( 1.0 + 1.0 / vom ** 2 ) pclfil = trim ( dir ) // trim ( f1n ) finfil = trim ( dir ) // 'finished_' sucfil = trim ( dir ) // 'success_' nodesfil = trim ( dir ) // 'nodes' anfil = trim ( dir ) // trim ( f2n ) anstfil = trim ( dir ) // 'anst.dat' end subroutine subroutine read_seeds ( n , nseeds ) ! USES environment variables !     SEEDS_FILENAME integer , intent ( in ) :: n integer , intent ( out ), allocatable :: nseeds (:) integer :: i , seeds_fileunit allocate ( nseeds ( n )) call open_file_from_environment ( \"SEEDS_FILE\" , seeds_fileunit , 'FORMATTED' ) do i = 1 , n read ( seeds_fileunit , * ) nseeds ( i ) end do close ( seeds_fileunit ) return end subroutine subroutine read_b1rs ( b1rsgrid ) ! USES environment variables !     MAGGRID_PROCESSED_INFILENAME real ( kind = real64 ), intent ( out ) :: b1rsgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI ) integer :: i , j , k integer :: b1rs_file_unit call open_file_from_environment ( \"B1RS_FILE\" , b1rs_file_unit , 'FORMATTED' ) do i = 0 , N_R do j = 0 , N_THETA do k = 0 , N_PHI read ( b1rs_file_unit , * ) b1rsgrid ( i , j , k ) end do end do end do close ( b1rs_file_unit ) end subroutine subroutine read_maggrid ( magfieldgrid , gbgrid ) ! USES environment variables !     MAPB2S_MAGGRID_INFILENAME real ( kind = real64 ), intent ( out ) :: magfieldgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) real ( kind = real64 ), intent ( out ) :: gbgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) integer :: i , j , k ! iteration variables integer :: maggrid_fileunit real ( kind = real64 ) :: r , theta , phi call open_file_from_environment (& \"MAGGRID_FILE\" , maggrid_fileunit , 'FORMATTED' ) do i = 0 , N_R do j = 0 , N_THETA do k = 0 , N_PHI read ( maggrid_fileunit , * ) r , theta , phi , magfieldgrid ( i , j , k ,:), gbgrid ( i , j , k ,:) end do end do end do close ( maggrid_fileunit ) end subroutine subroutine read_shtc ( g , h , n ) ! populate g(:,:), h(:,:) ! n is the size of g and h (see declaration) ! USES environment variables !     SHTC_FILE integer , intent ( in ) :: n real ( kind = real64 ), intent ( out ) :: g ( 0 : n , 0 : n ), h ( 0 : n , 0 : n ) integer :: infileunit integer :: l , m ! iteration variables integer :: ll , mm ! dummy storage call open_file_from_environment ( \"SHTC_FILE\" , infileunit , 'FORMATTED' ) do l = 0 , n do m = 0 , l read ( infileunit , * ) ll , mm , g ( l , m ), h ( l , m ) end do end do close ( infileunit ) end subroutine subroutine write_maggrid ( bgrid , gbgrid ) ! USES environment variables !     MAGGRID_OUTFILENAME ! maggrid_omp uses its own version of bgrid and gbgrid real ( kind = real64 ), intent ( in ) :: bgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) real ( kind = real64 ), intent ( in ) :: gbgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) integer :: i , j , k integer :: outfileunit real ( kind = real64 ) :: r , theta , phi call open_file_from_environment ( \"MAGGRID_FILE\" , outfileunit , 'FORMATTED' ) do i = 0 , N_R r = 1.0 + i / 10 0.0 do j = 0 , N_THETA theta = j * pi / 18 0.0 do k = 0 , N_PHI phi = k * pi / 18 0.0 write ( outfileunit , * ) r , theta , phi , bgrid ( i , j , k ,:), gbgrid ( i , j , k ,:) !write(outfileunit,*) bgrid(i,j,k,:), cvgrid(i,j,k,:), gbgrid(i,j,k,:) !print \"(3i4,6e14.6)\", i, j, k, bgrid(i,j,k,:), gbgrid(i,j,k,:) end do end do end do close ( outfileunit ) end subroutine subroutine write_b1rs ( b1rs , map ) ! USES environment variables !     MAPB2S_B1RS_OUTFILENAME real ( kind = real64 ), intent ( in out ) :: b1rs ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 2 ) integer , intent ( in ) :: map ( 0 : N_R , 0 : N_THETA , 0 : N_PHI ) integer :: i , j , k ! iteration variables integer :: lr , ltheta , lphi ! index storage integer :: b1rs_outfile integer :: nmap call open_file_from_environment ( \"B1RS_FILE\" , b1rs_outfile , \"FORMATTED\" ) do i = 0 , N_R do j = 0 , N_THETA do k = 0 , N_PHI if ( b1rs ( i , j , k , 1 ) == 0.0 ) then nmap = abs ( map ( i , j , k )) lphi = mod ( nmap , N_PHI + 1 ) nmap = floor ( real ( nmap ) / ( N_PHI + 1 )) ltheta = mod ( nmap , N_THETA + 1 ) lr = floor ( real ( nmap ) / ( N_THETA + 1 )) b1rs ( i , j , k , 1 ) = sign ( 1 , map ( i , j , k )) * abs ( b1rs ( lr , ltheta , lphi , 1 )) end if write ( b1rs_outfile , * ) b1rs ( i , j , k , 1 ) / b1rs ( i , j , k , 2 ) end do end do end do close ( b1rs_outfile ) end subroutine end module file_op","tags":"","url":"sourcefile/file_op.f90.html"},{"title":"seedgen.f90 – Fortran Program","text":"Source Code program seedgen ! USES environment variables !     SEEDS_FILENAME use datetime_utils , only : seconds_of_year use random , only : ran2 use file_op , only : open_file_from_environment use param , only : NSEEDMAX implicit none integer :: iseed ! store random state integer :: i , j ! iteration variables integer :: nran ( NSEEDMAX ) ! store all seeds integer :: seeds_outfileunit integer :: iran ! The random generator seed is -1 * Seconds of Year iseed = - 1 * seconds_of_year () print * , \"iseed = \" , iseed call open_file_from_environment (& \"SEEDS_FILE\" , seeds_outfileunit , 'FORMATTED' ) do i = 1 , NSEEDMAX ! get a new random number and store it 1 iran = int ( ran2 ( iseed ) * 2147483647 - 1 ) !print *,  \"iran = \", iran nran ( i ) = - iran ! make sure the random number hasn't already been generated do j = 1 , i - 1 if ( nran ( i ) == nran ( j )) goto 1 end do write ( seeds_outfileunit , * ) nran ( i ) end do close ( seeds_outfileunit ) end program","tags":"","url":"sourcefile/seedgen.f90.html"},{"title":"dxx.f90 – Fortran Program","text":"Source Code module dxx use iso_fortran_env , only : real64 use param , only : CSPEED use epv , only : e2p , rp2beta use dmumu , only : cofdu , set_du0DG , set_du0BK , set_du0AH implicit none contains subroutine preparedxx ( ndxx ) integer , intent ( in ) :: ndxx if ( ndxx == 1 ) call read_dxx ( ndxx ) end subroutine subroutine cofm ( r , p , pa , beta , bv , bm , cvtu , gbm , dbbds , b1s , gb1s , g , dg ) !   calculate diffusion coeficients in magnetic field coordinate !   and derivatives of g with respect to r, theta, phi !   2 perpendicular coeficients must equal to the poles real ( kind = real64 ), intent ( in ) :: p , pa , beta , bm , dbbds , b1s real ( kind = real64 ), intent ( in ) :: r ( 3 ), bv ( 3 ), cvtu ( 3 ), gbm ( 3 ), gb1s ( 3 ) real ( kind = real64 ), intent ( out ) :: g ( 3 ), dg ( 3 ) real ( kind = real64 ) :: ggper ( 3 ), dbb ( 3 ) real ( kind = real64 ) :: ab1s , vpl , dvpl , bdotggper real ( kind = real64 ) :: g0 ( 3 ), b ( 3 ), a ( 3 ) common / dxxcnst / g0 , b , a integer :: ndxx common / ndxx / ndxx real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip ab1s = abs ( b1s ) if ( ndxx == 1 ) then !  g in magnetic field - curvature coordinates g ( 1 ) = 0 !  adhoc GCR formula !g(2) = g0(2) * beta * p**b(2) / bm**a(2) !  particle following FLRW \\beta*c*B(1rs)<dx&#94;2>/(2*Vpl*B*<dt>) !   Vpl-plasma speed in km/s, use Leblanc et al (1998) model !   supergranulation dx=30000 km in dt=24hr. vpl = vsw / ( 1 + k4ok2 / r ( 1 ) ** 2 + k6ok2 / r ( 1 ) ** 4 ) dvpl = vpl * ( 2 * k4ok2 / r ( 1 ) ** 3 + 4 * k6ok2 / r ( 1 ) ** 5 ) / & ( 1 + k4ok2 / r ( 1 ) ** 2 + k6ok2 / r ( 1 ) ** 4 ) g ( 2 ) = g0 ( 2 ) * beta * ab1s * CSPEED / ( 2 * vpl ) !g0(2)=<dx&#94;2>/<dt> !g(2) = g(2) * sqrt(pa*pa) g ( 3 ) = g ( 2 ) !  g tensor = gper*(1-bb) !  divergence of g tensor in spherical coordinates b/c of all other divergence !   adhoc GCR !ggper = -a(2) * g(2) * gbm / bm !   FLRW ggper ( 1 ) = g ( 2 ) * gb1s ( 1 ) / ab1s - g ( 2 ) * dvpl / vpl ggper ( 2 ) = g ( 2 ) * gb1s ( 2 ) / ab1s ggper ( 3 ) = g ( 2 ) * gb1s ( 3 ) / ab1s bdotggper = ( bv ( 1 ) * ggper ( 1 ) + bv ( 2 ) * ggper ( 2 ) + bv ( 3 ) * ggper ( 3 )) / bm dbb = cvtu - dbbds * bv / bm dg = ggper - bdotggper * bv / bm - g ( 2 ) * dbb else g (:) = 0.0 dg (:) = 0.0 end if return end subroutine subroutine read_dxx ( ndxx ) integer , intent ( in ) :: ndxx real ( kind = real64 ) :: g0 ( 3 ), b ( 3 ), a ( 3 ) common / dxxcnst / g0 , b , a real ( kind = real64 ) :: gperCMS , bper , aper namelist / inputdxx / gperCMS , bper , aper character ( len = 256 ) :: dir common / dir / dir integer :: fileunit if ( ndxx == 1 ) then open ( newunit = fileunit , file = trim ( dir ) // 'inputdxx.nml' , status = 'old' ) read ( fileunit , nml = inputdxx ) close ( fileunit ) g0 ( 1 ) = 0.0 !  for p=1GV B=1G,beta=1,c*rg/3=1E+17 cm&#94;2/s g0 ( 2 ) = gperCMS * 1.2386e-20 !to rs&#94;2/min g0 ( 3 ) = g0 ( 2 ) b = [ 1 d0 , bper , bper ] a = [ 1 d0 , aper , aper ] end if end subroutine subroutine set_rlambdax ( e0 ) real ( kind = real64 ), intent ( in ) :: e0 integer :: nlambdax , ndxx common / nlambdax / nlambdax real ( kind = real64 ) :: rlambdax , rlambday common / rlambdax / rlambdax , rlambday common / ndxx / ndxx real ( kind = real64 ) :: rxl0 , ryl0 , g0rt if ( ndxx == 1 ) then rxl0 = get_rlambdax0 ( e0 ) ryl0 = get_rlambday0 ( e0 ) if ( nlambdax == 0 ) then rlambdax = rxl0 rlambday = ryl0 else g0rt = rxl0 / rlambdax !call set_dxx(g0rt) g0rt = ryl0 / rlambday !call set_dyy(g0rt) end if end if return end subroutine real ( kind = real64 ) function get_rlambdax () real ( kind = real64 ) :: rlambdax , rlambday common / rlambdax / rlambdax , rlambday integer :: ndxx common / ndxx / ndxx if ( ndxx == 1 ) then get_rlambdax = rlambdax else get_rlambdax = 0.0 end if end real ( kind = real64 ) function get_rlambda0 ( e0 ) real ( kind = real64 ), intent ( in ) :: e0 integer , parameter :: num = 20000 real ( kind = real64 ) :: rp , beta , v , bm real ( kind = real64 ) :: ddd , dmu , rmu , du , ddu , dmumu0 integer :: ndmumu common / ndmumu / ndmumu integer :: i rp = e2p ( e0 ) beta = rp2beta ( rp ) v = beta * CSPEED bm = 1.0 ddd = 0.0 dmu = 1.0 / num rmu = 0.0 do i = 1 , num call cofdu ( rp , rmu , beta , bm , du , ddu , ndmumu ) dmumu0 = du if ( dmumu0 /= 0 ) ddd = ddd + ( 1.0 - rmu * rmu ) ** 2 / ( 2 * dmumu0 ) rmu = rmu + dmu end do get_rlambda0 = 1.5 * v * ddd * dmu end function real ( kind = real64 ) function get_rlambdax0 ( e0 ) real ( kind = real64 ), intent ( in ) :: e0 real ( kind = real64 ) :: re ( 3 ), bv ( 3 ), cvtu ( 3 ), gbm ( 3 ), gb1s ( 3 ), g ( 3 ), dg ( 3 ) real ( kind = real64 ) :: rp , beta , v , bm , pa , p , dbbds , b1s rp = e2p ( e0 ) beta = rp2beta ( rp ) v = beta * CSPEED bm = 1.0 pa = 0.5 call cofm ( re , p , pa , beta , bv , bm , cvtu , gbm , dbbds , b1s , gb1s , g , dg ) get_rlambdax0 = 3.0 * g ( 2 ) / v end function real ( kind = real64 ) function get_rlambday0 ( e0 ) real ( kind = real64 ), intent ( in ) :: e0 real ( kind = real64 ) :: re ( 3 ), bv ( 3 ), cvtu ( 3 ), gbm ( 3 ), gb1s ( 3 ), g ( 3 ), dg ( 3 ) real ( kind = real64 ) :: rp , beta , v , bm , pa real ( kind = real64 ) :: p , dbbds , b1s rp = e2p ( e0 ) beta = rp2beta ( rp ) v = beta * CSPEED bm = 1.0 pa = 0.5 call cofm ( re , p , pa , beta , bv , bm , cvtu , gbm , dbbds , b1s , gb1s , g , dg ) get_rlambday0 = 3.0 * g ( 3 ) / v end function subroutine set_rlambda ( e0 ) real ( kind = real64 ), intent ( in ) :: e0 real ( kind = real64 ) :: du0rt , rl0 integer :: ndmumu common / ndmumu / ndmumu integer :: nlambda common / nlambda / nlambda real ( kind = real64 ) :: rlambda common / rlambda / rlambda ! only du0 needed real ( kind = real64 ) :: du0 , rnu , delta , va common / dmumuDGcnst / du0 , rnu , delta , va rl0 = get_rlambda0 ( e0 ) if ( nlambda == 0 ) then rlambda = rl0 else du0rt = rl0 / rlambda if ( ndmumu == 0 ) then call set_du0AH ( du0rt , du0 ) else if ( ndmumu == 1 ) then call set_du0BK ( du0rt , du0 ) else if ( ndmumu == 2 ) then call set_du0DG ( du0rt , du0 ) else stop end if end if end subroutine real ( kind = real64 ) function get_rlambda () real ( kind = real64 ) :: rlambda common / rlambda / rlambda get_rlambda = rlambda end function end module dxx","tags":"","url":"sourcefile/dxx.f90.html"},{"title":"cme_cross.f90 – Fortran Program","text":"Source Code module cme_cross use iso_fortran_env , only : real64 use param , only : PI , TWOPI use sim3d_utils , only : solarwindtemp use mtrx , only : drvbmag , solarwind , mrtx , mxptr , dmxptr , norm2 , dmrtx use datetime_utils , only : modjulianday use file_op , only : open_file_from_environment implicit none contains !  read in parameters for CME shock ellipsoid in Kwon's model subroutine preparecme real ( kind = real64 ) :: pexsk ( 0 : 144 , 8 ), vskf0 , acsk , tska ( 20 ), pska ( 20 , 8 ) integer :: nsk common / cmesk / pexsk , vskf0 , acsk , tska , pska , nsk real ( kind = real64 ) :: vskfska ( 20 ) integer :: jt character ( len = 256 ) :: dir common / dir / dir real ( kind = real64 ) :: prm ( 9 ) real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: vsw_real , rfnsk real ( kind = real64 ) :: vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC common / vsksw / vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC real ( kind = real64 ) :: a_tau , c_tau , rc1 , rc1sh_3d ( 3 ), rc1_3d ( 3 ), r1au ( 3 ) real ( kind = real64 ) :: bv ( 3 ), bm , cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ) real ( kind = real64 ) :: dbbds , pol , b1s , gb1s ( 3 ) real ( kind = real64 ) :: vpl ( 3 ), gvpl ( 3 , 3 ), densw integer :: ntauc2 real ( kind = real64 ) :: tsh1 , ca1 , cs1 , ca2 , cs2 , tpsw1 real ( kind = real64 ), parameter :: RS_PER_MIN_TO_KM_PER_SEC = 6.96340d5 / 6 0.0 real ( kind = real64 ), parameter :: gamma_cs = 1.6666666666666666666d0 character ( len =* ), parameter :: & writefmt = \"(10e18.10)\" , & !           YYYY - MM -  DD  T   HH :  MM :  SS.SSS readfmt = \"(i4,a1,i2,a1,i2, a1, i2,a1,i2,a1,f6.3,  3e15.5,4e18.7,f15.6,f15.3)\" , & readfmt2 = \"(i4,a1,i2,a1,i2, a1, i2,a1,i2,a1,f6.3)\" ! the following are dummy variables. they are to read in the hyphens and dashes ! that a datetime string might have, since fortran throws a hissy fit about ! having constant strings in read input formats character :: hyphen1 , hyphen2 , bigT , colon1 , colon2 integer :: iyr , imon , iday , ihr , imin , i , ii , jj real ( kind = real64 ) :: sec , fracday , hwinf , tmap0 , tcme , alinf real ( kind = real64 ) :: cm1sq , costhetahbv2 , dal real ( kind = real64 ) :: dphiskc , drskf , dso , dthetaskc , phic , phiskc , rskf real ( kind = real64 ) :: tauc1 , tcme1 real ( kind = real64 ) :: tempsw , theta_c , theta_skc , tsh real ( kind = real64 ) :: vtheta_c , vphic , vphic0 , vtheta_c0 , vskf , vsw0 integer :: cme_fileunit , cpm_fileunit , ecme_fileunit call open_file_from_environment ( \"CME_DATA_FILE\" , cme_fileunit , \"FORMATTED\" ) !open(newunit=cme_fileunit, file=trim(dir)//'cme.dat') read ( cme_fileunit , readfmt2 ) iyr , hyphen1 , imon , hyphen2 , iday , bigT , ihr , colon1 , imin , colon2 , sec fracday = ( ihr + imin / 6 0.0 + sec / 360 0.0 ) / 2 4.0 dmapjul = modjulianday ( iyr , imon , iday , fracday ) tmap0 = dmapjul * 1440 read ( cme_fileunit , * ) nsk , tauf , hwinf !tauf rising phase time;minutes case by case read ( cme_fileunit , * ) hwinf = hwinf / 18 0.0 * PI do i = 1 , nsk if ( nsk > 20 ) stop 'nsk too large' read ( cme_fileunit , readfmt ) & iyr , hyphen1 , imon , hyphen2 , iday , bigT , & ihr , colon1 , imin , colon2 , sec , prm fracday = ( ihr + imin / 6 0. + sec / 360 0. ) / 2 4.0 tcme = modjulianday ( iyr , imon , iday , fracday ) tcme = tcme * 1440 tska ( i ) = tcme - tmap0 pska ( i , 1 ) = prm ( 4 ) / 6.96340d8 pska ( i , 2 ) = acos ( prm ( 3 ) / norm2 ( prm )) pska ( i , 3 ) = atan2 ( prm ( 2 ), prm ( 1 )) ! transform to HEEQ+60 longitude at map time pska ( i , 3 ) = pska ( i , 3 ) - ( omega - 2.0d0 * PI / 5.256e5 ) * tska ( i ) + PI / 3 pska ( i , 4 ) = ( prm ( 5 ) + prm ( 6 )) / 2 / 6.96340d8 pska ( i , 5 ) = pska ( i , 4 ) pska ( i , 6 ) = prm ( 7 ) / 6.96340d8 pska ( i , 7 ) = 0.0 pska ( i , 8 ) = prm ( 9 ) / 180 * PI end do close ( cme_fileunit ) write ( * , * ) 'tska1,tska2' , tska ( 1 : 2 ) write ( * , * ) 'pska' , pska ( 1 , 6 ), pska ( 2 , 6 ), pska ( 1 , 1 ), pska ( 2 , 1 ) do i = 2 , nsk vskfska ( i ) = ( pska ( i , 6 ) + pska ( i , 1 ) - pska ( i - 1 , 6 ) - pska ( i - 1 , 1 )) / & ( tska ( i ) - tska ( i - 1 )) vskfska ( i ) = vskfska ( i ) * RS_PER_MIN_TO_KM_PER_SEC !km/s end do !  find the zero time of CME shock size when pska(6) is extrapolated to zero tcme0 = tska ( 1 ) - pska ( 1 , 6 ) / ( pska ( 2 , 6 ) - pska ( 1 , 6 )) * ( tska ( 2 ) - tska ( 1 )) !  find the zero time of CME front when pska(6)+pska(1) is one tcme1 = tska ( 1 ) - ( pska ( 1 , 6 ) + pska ( 1 , 1 ) - 1.0 ) / & ( pska ( 2 , 6 ) + pska ( 2 , 1 ) - pska ( 1 , 6 ) - pska ( 1 , 1 )) * & ( tska ( 2 ) - tska ( 1 )) if ( tcme0 < tcme1 ) tcme0 = tcme1 !  cme shock slow down last the last frame !  cme shock goes to vsw asymptotically !  cme shock pass 1 AU t1au since tska(nsk) rfnsk = pska ( nsk , 6 ) + pska ( nsk , 1 ) !LC last shock front !vsw_real = vsw/(1+k4ok2/rfnsk**2+k6ok2/rfnsk**4)!LC ! average shock front speed vskf0 = ( pska ( nsk , 6 ) + pska ( nsk , 1 ) - pska ( 1 , 6 ) - pska ( 1 , 1 )) / ( tska ( nsk ) - tska ( 1 )) !LC !    1.sum(vskfska(2:nsk))/(nsk-1) average speed from cme.dat 2.vskfska(nsk) last data point 3. observarion vcme0kmPs = sum ( vskfska ( 2 : nsk )) / ( nsk - 1 ) !vskf0*6.96340d5/60.!991.!km/s case by case vcme0 = vcme0kmPs / RS_PER_MIN_TO_KM_PER_SEC !Rs/min c_tau = 338 0. * ( tauf / 6 0. ) ** ( - 1.14 ) / ( vcme0kmPs - vsw * RS_PER_MIN_TO_KM_PER_SEC ) a_tau = vcme0 / vsw + 1.0 / sqrt ( c_tau ) * ( vcme0 / vsw - 1. ) tauc1 = a_tau * ( 1.0 + sqrt ( c_tau )) / ( a_tau - 1. ) * tauf !min !critical time for CME leading edge rc1 = pska ( 1 , 6 ) + pska ( 1 , 1 ) + vcme0 * tauc1 !critical r for CME leading edge !rc1 = pska(1,1)+vcme0*tauc1 !critical r for CME leading edge if ( tauc1 + tska ( 1 ) < tska ( nsk )) then jt = locate ( tska , nsk , tauc1 + tska ( 1 )) else jt = nsk - 1 end if drskf = ( pska ( jt + 1 , 1 ) + pska ( jt + 1 , 6 ) - pska ( 1 , 1 ) - pska ( 1 , 6 )) / & ( tska ( jt + 1 ) - tska ( 1 )) rskf = pska ( jt , 1 ) + pska ( jt , 6 ) + ( tauc1 + tska ( 1 ) - tska ( jt )) * drskf !dso1 = pska(nsk,1)-pska(nsk,6) !standoff distance ! temporary dthetaskc = ( pska ( jt + 1 , 2 ) - pska ( 1 , 2 )) / ( tska ( jt + 1 ) - tska ( 1 )) theta_skc = pska ( jt , 2 ) + ( tauc1 + tska ( 1 ) - tska ( jt )) * dthetaskc dphiskc = pska ( jt + 1 , 3 ) - pska ( jt , 3 ) if ( dphiskc > PI ) dphiskc = dphiskc - TWOPI if ( dphiskc < - PI ) dphiskc = dphiskc + TWOPI dphiskc = dphiskc / ( tska ( jt + 1 ) - tska ( jt )) phiskc = pska ( jt , 3 ) + ( tauc1 + tska ( 1 ) - tska ( jt )) * dphiskc !!=======if using data or observation at 1au to calculate Va and Vs======= !!bm densw,tempsw could be replaced with those from observation !r1au(1) = 215.032 !r1au(2) = theta_skc !tpsw = ((r1au(1)-k4ok2/r1au(1)-k6ok2/r1au(1)**3/3) !&   -(rc1 - k4ok2/rc1 - k6ok2/rc1**3/3))/vsw ! r1au(3) = phiskc - omega*tpsw ! call drvbmag(r1au, bv, bm, cvtu, gbmag, bxgb2, dbbds, pol, b1s, gb1s) ! call solarwind(r1au, vpl, gvpl, densw) ! va1au = 187.8*bm/sqrt(densw) ! tempsw = solarwindtemp(r1au) ! vs1au = 7.83e-6 * sqrt(gamma_cs*tempsw) ! ca1 = va1au*r1au(1)/rc1* !&  sqrt((vsw+(rc1 - 2.)*omega)/(vsw+(r1au(1)-2.)*omega)) ! cs1 = vs1au*(r1au(1)/rc1)**(gamma_cs - 1) ! costhetahbv2 = vsw**2/(vsw**2+((r1au(1)-2.)*omega)**2) !!=======if using data at rc1 to calculate Va and Vs directly===== vsw0 = vsw rc1_3d ( 1 ) = rc1 rc1_3d ( 2 ) = theta_skc rc1_3d ( 3 ) = phiskc call drvbmag ( rc1_3d , bv , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) call solarwind ( rc1_3d , vpl , gvpl , densw ) ca1 = 18 7.8 * bm / sqrt ( densw ) tempsw = solarwindtemp ( rc1_3d ) cs1 = 7.83e-6 * sqrt ( gamma_cs * tempsw ) ! cm1sq: square of mach number at rc1 !!magnetosonic speed (Vms): Vms**2 = 0.5 * {Va**2 + Vs**2 + [(Va**2 + Vs**2)**2 - !! 4 * Va**2 * Vs**2 * (cos (theta))**2]**0.5} costhetahbv2 = vpl ( 1 ) ** 2 / ( vpl ( 1 ) ** 2 + vpl ( 2 ) ** 2 ) cm1sq = 2. * ( vcme0 - vsw ) ** 2 / ( ca1 ** 2 + cs1 ** 2 + & sqrt (( ca1 ** 2 + cs1 ** 2 ) ** 2 - 4 * ca1 ** 2 * cs1 ** 2 * costhetahbv2 )) r1au ( 1 ) = 21 5.032 dso = 0.264 * r1au ( 1 ) * & (( gamma_cs - 1 ) * cm1sq + 2 ) / (( gamma_cs + 1 ) * ( cm1sq - 1 )) * & ( rc1 / r1au ( 1 )) ** 0.78 !standoff distance rc1sh_3d ( 1 ) = rc1 + dso / 2 !sheath position at CME leading edge critical time rc1sh_3d ( 2 ) = theta_skc tpsw1 = (( rc1sh_3d ( 1 ) - k4ok2 / rc1sh_3d ( 1 ) - k6ok2 / rc1sh_3d ( 1 ) ** 3 / 3 )& - ( rc1 - k4ok2 / rc1 - k6ok2 / rc1 ** 3 / 3 )) / vsw rc1sh_3d ( 3 ) = phiskc - omega * tpsw1 call drvbmag ( rc1sh_3d , bv , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) call solarwind ( rc1sh_3d , vpl , gvpl , densw ) ca2 = 18 7.8 * bm / sqrt ( densw ) tempsw = solarwindtemp ( rc1sh_3d ) cs2 = 7.83e-6 * sqrt ( gamma_cs * tempsw ) ! bm densw tempsw from model (or observation) !cm1sq = (vcme0 - vsw)**2/cs2**2 tauc2 = dso / sqrt ( ca2 ** 2 + cs2 ** 2 ) + tauc1 !min !critical time for CME shock front tauc2_0 = tauc2 + tska ( 1 ) tauc1_0 = tauc1 + tska ( 1 ) !!==================================================== call open_file_from_environment (& \"CME_PROP_MODEL_FILE\" , cpm_fileunit , \"FORMATTED\" ) !open (newunit=cpm_fileunit, file = trim(dir)//'cmepropmodel.dat') write ( cpm_fileunit , '(A)' ) 'tauf(min): rising phase time ' write ( cpm_fileunit , '(A)' ) 'tcme0(min): zero time of CME shock' write ( cpm_fileunit , '(A)' ) 'tauc1_0:critical time of CME leading edge' write ( cpm_fileunit , '(A)' ) 'tauc2_0:critical time of CME shock front' write ( cpm_fileunit , '(A)' ) 'rc1:position at critical time of CME leading edge' write ( cpm_fileunit , '(A)' ) 'dso(RS): standoff distance' write ( cpm_fileunit , '(A)' ) 'ca1,cs1(Rs/min): Alfven and sound speed at rc1 ' write ( cpm_fileunit , '(A)' ) 'ca2,cs2(Rs/min): Alfven and sound speed at the shealth rc1+dso/2' write ( cpm_fileunit , '(A)' ) '==============================================' write ( cpm_fileunit , '(A)' ) 'Calculated variables:' write ( cpm_fileunit , '(A,F5.1)' ) 'tauf(min)=' , tauf write ( cpm_fileunit , '(A,3F8.1)' ) 'rc1(Rs,deg,deg)=' ,& rc1_3d ( 1 ), rc1_3d ( 2 ) / PI * 18 0. , rc1_3d ( 3 ) / PI * 18 0. write ( cpm_fileunit , '(A,F5.1)' ) 'dso(Rs)=' , dso write ( cpm_fileunit , '(3(A,F15.1,2x))' ) & 'tcme0=' , tcme0 , ', tauc1_0=' , tauc1_0 , ', tauc2_0=' , tauc2_0 write ( cpm_fileunit , '(4(A,F8.4,2x))' ) 'CA1=' , ca1 , ',CS1=' , cs1 ,& ',CA2=' , ca2 , ',CS2=' , cs2 write ( cpm_fileunit , '(A,F5.1)' ) 'Mach number at rc1=' , sqrt ( cm1sq ) write ( cpm_fileunit , '(A,F7.2)' ) 'Half Angle at 21.5 Rs= ' , hwinf * 5 7.29578 write ( cpm_fileunit , '(A)' ) '==============================================' !==============comment this part if just using tauc2 from the new model==== !----------------find tauc2 from cme.dat---------------------- ntauc2 = nsk do i = ( nsk - 2 ), 2 , - 1 if ( vskfska ( i + 1 ) < vskfska ( i ) . and . vskfska ( i + 2 ) < vskfska ( i + 1 )) then ntauc2 = i end if end do !!----------choose smaller one----------------------------------- ! if (tauc2_0>tska(ntauc2)) then !     write(cpm_fileunit,'(2(A,F8.1,2x))')& !        'Calculated tauc2_0=', tauc2_0, & !        ' is larger than tauc2_0 from cme.dat', tska(ntauc2) !     write(cpm_fileunit,'(A)')'tauc2_0 from cme.dat is adopted' !     tauc2_0 = tska(ntauc2)+0.01 ! else !     write(cpm_fileunit,'(A)')'tauc2_0 from shock model is adopted' !  end if ! write(cpm_fileunit,'(A,F8.3)')'adopted tauc2_0 is',tauc2_0 !---ignore cme.data where tska>tauc2_0 if tauc2_0<tska(nsk)---------------- !!if (tauc2_0<tska(nsk)) then !!write(cpm_fileunit,'(A)')'==============================================' !!write(cpm_fileunit,'(A)')'tauc2_0 is less than tska(nsk).' !!write(cpm_fileunit,'(A,i3)')'original nsk=',nsk !!jt = locate(tska,nsk,tauc2_0) !!if (jt>1) then !!  nsk = jt !update nsk !!else !!  nsk = 2 !!  tauc2_0 = tska(2)+0.01   !update nsk and tauc2_0 !!end if !!write(cpm_fileunit,'(A,i3)')'ignore cme.dat where nsk>',nsk !!write(cpm_fileunit,'(A,i3)')'updated nsk=',nsk !!write(cpm_fileunit,'(A)')'==============================================' !!end if !=========================================================== !---------------- calculate t,vskf at 1au------------------ rskf = 0.0 vskf0 = ( pska ( nsk , 6 ) + pska ( nsk , 1 ) - pska ( 1 , 6 ) - pska ( 1 , 1 )) / ( tska ( nsk ) - tska ( 1 )) vcme0 = vskf0 tsh1 = tauc2_0 do while ( rskf < 21 5.032 ) if ( tauc2_0 > tska ( nsk )) then rskf = 3.0 / 2.0 * ( vcme0 - vsw0 ) * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 )& ** ( 2.0 / 3.0 ) - 1.0d0 ) + vsw0 * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 ) - 1.0d0 )& + pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tauc2_0 - tska ( nsk )) !LC else rskf = 3.0 / 2.0 * ( vcme0 - vsw0 ) * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 & ) - (( tska ( nsk ) - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )) + vsw0 * ( tsh1 - tska ( nsk ))& + pska ( nsk , 1 ) + pska ( nsk , 6 ) end if vskf = ( vcme0 - vsw0 ) * ((( tsh1 - tska ( 1 )) / tauc2 ) ** ( - 1.0d0 / 3.0d0 )) + vsw0 tsh1 = tsh1 + 0.5 end do write ( cpm_fileunit , '(A,4F8.1)' ) 't1au(min),vcme0,vskf1au,vsw0(km/s)=' , & tsh1 , vcme0kmPs , vskf * RS_PER_MIN_TO_KM_PER_SEC , vsw0 * RS_PER_MIN_TO_KM_PER_SEC !call flush(cpm_fileunit) flush ( cpm_fileunit ) close ( cpm_fileunit ) !------------------------------------------------------------------------ !  Use the propagation model to calculate the radial, lat and long !  motion and save to an array up to 3days pexsk ( 0 ,:) = pska ( nsk ,:) theta_c = pexsk ( 0 , 2 ) phic = 0.0 !relative to pska(nsk,3) dthetaskc = ( pska ( nsk , 2 ) - pska ( 1 , 2 )) / ( tska ( nsk ) - tska ( 1 )) dphiskc = pska ( nsk , 3 ) - pska ( nsk - 1 , 3 ) if ( dphiskc > PI ) dphiskc = dphiskc - TWOPI if ( dphiskc < - PI ) dphiskc = dphiskc + TWOPI dphiskc = dphiskc / ( tska ( nsk ) - tska ( nsk - 1 )) vtheta_c0 = ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * dthetaskc vphic0 = ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * ( dphiskc + omega ) * sin ( theta_c ) ! limiting shock size to hwinf (after 21.5 Rs) !    hwinf = pska(nsk,6) * sin(alinf) / (pska(nsk,6)*cos(alinf)+pska(nsk,1)) alinf = hwinf dal = 1.0 do while ( dal * dal > 0.0001 ) dal = ( hwinf * ( pska ( nsk , 6 ) * cos ( alinf ) + pska ( nsk , 1 )) - pska ( nsk , 6 ) * sin ( alinf ))& / ( pska ( nsk , 6 ) * cos ( alinf ) + hwinf * pska ( nsk , 6 ) * sin ( alinf )) alinf = alinf + dal end do do i = 1 , 43200 tsh1 = tska ( nsk ) + 0.1 * i if ( tsh1 < tauc2_0 ) then rskf = pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tsh1 - tska ( nsk )) else if ( tauc2_0 > tska ( nsk )) then rskf = 3.0 / 2.0 * ( vcme0 - vsw0 ) * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 )& ** ( 2.0 / 3.0 ) - 1.0d0 ) + vsw0 * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 ) - 1.0d0 )& + pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tauc2_0 - tska ( nsk )) !LC else rskf = 3.0 / 2.0 * ( vcme0 - vsw0 ) * tauc2 * ((( tsh1 - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 & ) - (( tska ( nsk ) - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )) + vsw0 * ( tsh - tska ( nsk ))& + pska ( nsk , 1 ) + pska ( nsk , 6 ) end if end if if ( tsh1 < tauc2_0 ) then vtheta_c = vtheta_c0 vphic = vphic0 else vtheta_c = vtheta_c0 * (( tsh1 - tska ( 1 )) / tauc2 ) ** ( - 1.0 / 3.0 ) vphic = vphic0 * (( tsh1 - tska ( 1 )) / tauc2 ) ** ( - 1.0 / 3.0 ) end if theta_c = theta_c + vtheta_c / rskf * 0.1 !integration time step is 0.1 min phic = phic + vphic / rskf / sin ( theta_c ) * 0.1 !fixed frame if ( mod ( i , 300 ) == 0 ) then ii = i / 300 pexsk ( ii , 1 ) = pska ( nsk , 1 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * rskf pexsk ( ii , 2 ) = theta_c pexsk ( ii , 3 ) = phic + pska ( nsk , 3 ) - omega * ( tsh1 - tska ( nsk )) pexsk ( ii , 4 ) = pska ( nsk , 4 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * rskf pexsk ( ii , 5 ) = pska ( nsk , 5 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * rskf pexsk ( ii , 6 ) = pska ( nsk , 6 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) * rskf pexsk ( ii , 7 ) = 0. if ( pexsk ( ii , 6 ) * cos ( alinf ) + pexsk ( ii , 1 ) > 2 1.5 ) then pexsk ( ii , 8 ) = alinf else jj = ii end if end if end do do ii = 1 , jj pexsk ( ii , 8 ) = pexsk ( 0 , 8 ) + ( alinf - pexsk ( 0 , 8 )) / jj * ii end do call open_file_from_environment (& \"EXTENDED_CME_DATA_FILE\" , ecme_fileunit , \"FORMATTED\" ) !open(newunit=ecme_fileunit, file=trim(dir)//'extended_cme.dat') write ( ecme_fileunit , '(A)' ) 'Time Maptime, 8 perameters in Rs as in cme.dat' do i = 1 , nsk write ( ecme_fileunit , writefmt ) tska ( i ), pska ( i , 1 : 8 ) end do do i = 0 , 144 write ( ecme_fileunit , writefmt ) tska ( nsk ) + i * 30 , pexsk ( i ,:) end do !call flush(ecme_fileunit) flush ( ecme_fileunit ) close ( ecme_fileunit ) end subroutine ! find which side of CME shock a particle is !  if crossed, calculate distance to shock, shock speed and normal subroutine inorout ( tsh , x , dnsk , vsk , vnx ) real ( kind = real64 ), intent ( in ) :: tsh , x ( 6 ) real ( kind = real64 ), intent ( in out ) :: dnsk real ( kind = real64 ), intent ( out ) :: vsk , vnx ( 3 ) real ( kind = real64 ) :: ra real ( kind = real64 ) :: dnsk0 !copy of input !  dnsk = distance to shock outside +; inside - !  vsk = shock speed, !  vnx = normal to shock in xyz real ( kind = real64 ) :: pexsk ( 0 : 144 , 8 ), vskf0 , acsk , tska ( 20 ), pska ( 20 , 8 ) integer :: nsk common / cmesk / pexsk , vskf0 , acsk , tska , pska , nsk real ( kind = real64 ) :: rskc , drskc , rskmax , rskmin , ask ( 3 ), dask ( 3 ) real ( kind = real64 ) :: theta_skc , phiskc , gmsk , dthetaskc , dphiskc , dgmsk real ( kind = real64 ) :: sinthetask , costhetask , sinphisk , cosphisk real ( kind = real64 ) :: r2xsk ( 3 , 3 ), dr2xsk ( 3 , 3 ) real ( kind = real64 ) :: xp2r ( 3 , 3 ), xp2x ( 3 , 3 ), dxp2r ( 3 , 3 ), dxp2x ( 3 , 3 ) real ( kind = real64 ) :: xskc ( 3 ), dxskc ( 3 ), dxpskc ( 3 ), xc ( 3 ), xpc ( 3 ), rho , vnm , vnxp ( 3 ) real ( kind = real64 ) :: grf1 ( 3 ), grf2 ( 3 ), grf3 ( 3 ), grf2m , drxc ( 3 ) real ( kind = real64 ) :: dot1 , dot2 , dot3 , dot4 real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC common / vsksw / vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC integer :: i , j , jt , jt1 real ( kind = real64 ) :: dtzskmin , tzskmin , rac , rbc , rhclf , rskf , vskf , tsh1 dnsk0 = dnsk if ( tsh < tska ( nsk )) then jt = locate ( tska , nsk , tsh ) if ( jt == 0 ) jt = 1 !  maximum shock radial distance for quick search drskc = ( pska ( jt + 1 , 1 ) - pska ( jt , 1 )) / ( tska ( jt + 1 ) - tska ( jt )) rskc = pska ( jt , 1 ) + ( tsh - tska ( jt )) * drskc dask ( 3 ) = ( pska ( jt + 1 , 6 ) - pska ( jt , 6 )) / ( tska ( jt + 1 ) - tska ( jt )) ask ( 3 ) = pska ( jt , 6 ) + ( tsh - tska ( jt )) * dask ( 3 ) !vskf = vskf0 !only for fort.58; useless !rskf = pska(jt,1)+pska(jt,6)!only for fort.58; useless dthetaskc = ( pska ( jt + 1 , 2 ) - pska ( jt , 2 )) / ( tska ( jt + 1 ) - tska ( jt )) theta_skc = pska ( jt , 2 ) + ( tsh - tska ( jt )) * dthetaskc dphiskc = ( pska ( jt + 1 , 3 ) - pska ( jt , 3 )) if ( dphiskc > PI ) dphiskc = dphiskc - TWOPI if ( dphiskc < - PI ) dphiskc = dphiskc + TWOPI dphiskc = dphiskc / ( tska ( jt + 1 ) - tska ( jt )) phiskc = pska ( jt , 3 ) + ( tsh - tska ( jt )) * dphiskc else jt = nsk - 1 vcme0 = vskf0 if ( tsh < tauc2_0 ) then rskf = pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tsh - tska ( nsk )) !LC vskf = vcme0 else if ( tauc2_0 > tska ( nsk )) then rskf = 3.0 / 2.0 * ( vcme0 - vsw ) * tauc2 * ((( tsh - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )& - 1.0d0 ) + vsw * tauc2 * ((( tsh - tska ( 1 )) / tauc2 ) - 1.0d0 )& + pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tauc2_0 - tska ( nsk )) !LC else rskf = 3.0 / 2.0 * ( vcme0 - vsw ) * tauc2 * ((( tsh - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )& - (( tska ( nsk ) - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )) + vsw * ( tsh - tska ( nsk ))& + pska ( nsk , 1 ) + pska ( nsk , 6 ) end if vskf = ( vcme0 - vsw ) * ((( tsh - tska ( 1 )) / tauc2 ) ** ( - 1.0d0 / 3.0d0 )) + vsw end if rhclf = pska ( nsk , 6 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) rskc = ( 1 - rhclf ) * rskf drskc = ( 1 - rhclf ) * vskf if (( pska ( nsk , 1 ) - pska ( nsk - 1 , 1 )) < 1.e-3 ) then drskc = 0.0 rskc = pska ( nsk , 1 ) end if ask ( 3 ) = rhclf * rskf dask ( 3 ) = rhclf * vskf end if rskmax = rskc + ask ( 3 ) rskmin = rskc - ask ( 3 ) ra = norm2 ( x ( 1 : 3 )) !write(58,\"(f14.8,3(1pe12.4))\") tsh,ra,rskf,vskf if (( rskmax < ra * . 99 ) . or . ( rskmin > ra * 1.01 )) then dnsk = 0.01 * ra ! use step size as a minimum if ( dnsk0 * dnsk >= 0.0 ) then vsk = 1 d - 6 vnx = 0.57735026918962576450d0 return end if end if if ( tsh < tska ( nsk )) then dthetaskc = ( pska ( jt + 1 , 2 ) - pska ( jt , 2 )) / ( tska ( jt + 1 ) - tska ( jt )) theta_skc = pska ( jt , 2 ) + ( tsh - tska ( jt )) * dthetaskc dphiskc = pska ( jt + 1 , 3 ) - pska ( jt , 3 ) if ( dphiskc > PI ) dphiskc = dphiskc - TWOPI if ( dphiskc < - PI ) dphiskc = dphiskc + TWOPI dphiskc = dphiskc / ( tska ( jt + 1 ) - tska ( jt )) phiskc = pska ( jt , 3 ) + ( tsh - tska ( jt )) * dphiskc dgmsk = ( pska ( jt + 1 , 7 ) - pska ( jt , 7 )) / ( tska ( jt + 1 ) - tska ( jt )) gmsk = pska ( jt , 7 ) + ( tsh - tska ( jt )) * dgmsk dask ( 1 ) = ( pska ( jt + 1 , 4 ) - pska ( jt , 4 )) / ( tska ( jt + 1 ) - tska ( jt )) ask ( 1 ) = pska ( jt , 4 ) + ( tsh - tska ( jt )) * dask ( 1 ) dask ( 2 ) = ( pska ( jt + 1 , 5 ) - pska ( jt , 5 )) / ( tska ( jt + 1 ) - tska ( jt )) ask ( 2 ) = pska ( jt , 5 ) + ( tsh - tska ( jt )) * dask ( 2 ) dtzskmin = ( pska ( jt + 1 , 8 ) - pska ( jt , 8 )) / ( tska ( jt + 1 ) - tska ( jt )) tzskmin = pska ( jt , 8 ) + ( tsh - tska ( jt )) * dtzskmin else tsh1 = tsh - tska ( nsk ) jt1 = floor ( tsh1 / 30 ) dthetaskc = ( pexsk ( jt1 + 1 , 2 ) - pexsk ( jt1 , 2 )) / 30 theta_skc = pexsk ( jt1 , 2 ) + ( tsh1 - 30 * jt1 ) * dthetaskc dphiskc = pexsk ( jt1 + 1 , 3 ) - pexsk ( jt1 , 3 ) if ( dphiskc > PI ) dphiskc = dphiskc - TWOPI if ( dphiskc < - PI ) dphiskc = dphiskc + TWOPI dphiskc = dphiskc / 30 phiskc = pexsk ( jt1 , 3 ) + ( tsh1 - 30 * jt1 ) * dphiskc dgmsk = ( pexsk ( jt1 + 1 , 7 ) - pexsk ( jt1 , 7 )) / 30 gmsk = pexsk ( jt1 , 7 ) + ( tsh1 - 30 * jt1 ) * dgmsk rac = pska ( nsk , 4 ) / pska ( nsk , 6 ) ask ( 1 ) = rhclf * rskf * rac dask ( 1 ) = rhclf * vskf * rac rbc = pska ( nsk , 5 ) / pska ( nsk , 6 ) ask ( 2 ) = rhclf * rskf * rbc dask ( 2 ) = rhclf * vskf * rbc dtzskmin = ( pexsk ( jt1 + 1 , 8 ) - pexsk ( jt1 , 8 )) / 30 tzskmin = pexsk ( jt1 , 8 ) + ( tsh1 - 30 * jt1 ) * dtzskmin end if tzskmin = cos ( tzskmin ) !tzskmin = -0.866 ! write(*,*) rskc, drskc, ask, dask !  theta_skc is colatitude sinthetask = sin ( theta_skc ) costhetask = cos ( theta_skc ) sinphisk = sin ( phiskc ) cosphisk = cos ( phiskc ) r2xsk = mrtx ( sinthetask , costhetask , sinphisk , cosphisk ) !  r2xsk matrix to convert r-the-phi of shock ellipsoid center to xyz of !    of HEEQ. r = z theta = x, phi = y call mxptr ( gmsk , xp2r ) !xp2x = matmul(r2xsk, xp2r) do i = 1 , 3 xp2x ( i , 1 : 3 ) = r2xsk ( i , 1 ) * xp2r ( 1 , 1 : 3 ) + r2xsk ( i , 2 ) * xp2r ( 2 , 1 : 3 ) + & r2xsk ( i , 3 ) * xp2r ( 3 , 1 : 3 ) end do ! Convert spherical coordinates to Cartesian xskc ( 1 ) = rskc * sinthetask * cosphisk xskc ( 2 ) = rskc * sinthetask * sinphisk xskc ( 3 ) = rskc * costhetask xc ( 1 : 3 ) = x ( 1 : 3 ) - xskc ( 1 : 3 ) xpc ( 1 : 3 ) = xc ( 1 ) * xp2x ( 1 , 1 : 3 ) + xc ( 2 ) * xp2x ( 2 , 1 : 3 ) + xc ( 3 ) * xp2x ( 3 , 1 : 3 ) !  distance to the shock grf1 ( 1 : 3 ) = xpc ( 1 : 3 ) / ask ( 1 : 3 ) rho = norm2 ( grf1 ( 1 : 3 )) grf2 ( 1 : 3 ) = grf1 ( 1 : 3 ) / ask ( 1 : 3 ) grf3 ( 1 : 3 ) = grf1 ( 1 : 3 ) * grf1 ( 1 : 3 ) grf2m = norm2 ( grf2 ( 1 : 3 )) dnsk = ( rho - 1 ) / grf2m if ( dnsk0 * dnsk < 0. ) then ! crossed shock if ( grf1 ( 3 ) < tzskmin ) then !No shock on the backside vsk = 1 d - 6 vnx = 0.57735026918962576450d0 return end if !   shock normal vnxp = grf2 / grf2m vnx = matmul ( xp2x , vnxp ) !  calculate shock velocity (normal) dr2xsk = dmrtx ( sinthetask , costhetask , sinphisk , cosphisk , dthetaskc , dphiskc ) dxp2r = dmxptr ( gmsk , dgmsk ) do i = 1 , 3 do j = 1 , 3 dxp2x ( i , j ) = dot_product ( dr2xsk ( i , 1 : 3 ), xp2r ( 1 : 3 , j )) + & dot_product ( r2xsk ( i , 1 : 3 ), dxp2r ( 1 : 3 , j )) end do end do dot1 = dot_product ( grf2 , vnxp ) dot2 = dot_product ( grf3 , dask (:) / ask (:)) dxskc ( 1 ) = drskc * sinthetask * cosphisk & + rskc * costhetask * dthetaskc * cosphisk & - rskc * sinthetask * sinphisk * dphiskc dxskc ( 2 ) = drskc * sinthetask * sinphisk & + rskc * costhetask * dthetaskc * sinphisk & + rskc * sinthetask * cosphisk * dphiskc dxskc ( 3 ) = drskc * costhetask - rskc * sinthetask * dthetaskc do i = 1 , 3 dxpskc ( i ) = dot_product ( dxskc , xp2x (:, i )) end do dot3 = dot_product ( grf2 , dxpskc ) do i = 1 , 3 drxc ( i ) = dot_product ( xc , dxp2x ( 1 : 3 , i )) end do dot4 = dot_product ( grf2 ( 1 : 3 ), drxc ( 1 : 3 )) vsk = ( dot2 + dot3 - dot4 ) / dot1 else vsk = 1.d-6 vnx = 0.57735026918962576450d0 end if !write(60,\"(f14.6,11(1pe12.4))\") tsh, ra, rskc, vsk, vnx, ask, rskf, vskf return end subroutine integer function locate ( xx , n , x ) result ( j ) integer , intent ( in ) :: n real ( kind = real64 ), intent ( in ) :: xx ( n ) real ( kind = real64 ), intent ( in ) :: x integer :: jl , jm , ju jl = 0 ju = n + 1 10 if ( ju - jl > 1 ) then jm = ( ju + jl ) / 2 if (( xx ( n ) > xx ( 1 )) . eqv . ( x > xx ( jm ))) then jl = jm else ju = jm end if goto 10 end if j = jl end function end module","tags":"","url":"sourcefile/cme_cross.f90.html"},{"title":"sim3d_em.f90 – Fortran Program","text":"Source Code program sim3d_em !  Source injection at shocks !  time backward simulation to calculate fluxes at locations in IP !  pfss magnetic field model !  calculation is done in corotation reference frame !  pitch angle with outward magnetic field line !  pitch angle diffusion (symmetric D_{\\mu\\mu}) !  perpendicular diffusion added use datetime_utils , only : caldate use param , only : PI , NSPMAX , NFMAX , nseedmax , bgrid , gbgrid , epsilon !use param, only: nnds, nfl, nsts use cme_cross , only : inorout , preparecme use sim3d_utils , only : f0mod , compress , solarwindtemp , split use epv , only : rp2e , e2p use fb , only : fb0 , preparefb use mtrx , only : loadmaggrid_processed , norm2 , vfunc , mrtx , drvbmag use loadptcl , only : prepareptcl use dmumu , only : preparedmumu use dxx , only : preparedxx , set_rlambda , set_rlambdax use file_op , only : readparam , record_nodes , fl_open , fl_close , writehead use random , only : gasdev implicit none include 'omp_lib.h' real * 8 :: rpb ( 5 ), rp0 ( 5 ), rp0org ( 5 ), r0 ( 3 ), rb ( 3 ), x0 ( 6 ) real * 8 :: rnz , rnm common / specie / rnz , rnm !common/sptm/sptm integer :: npmax , nsucmin , nfbconst , ndpdt , num ( 3 ) real * 8 :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 common / nsucmin / nsucmin common / npmax / npmax common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst common / ndpdt / ndpdt real * 8 :: t0sv ( 2 ** ( NSPMAX + 1 )), cksv ( 2 ** ( NSPMAX + 1 )) real * 8 :: rpbsv ( 5 , 2 ** ( NSPMAX + 1 )) integer :: nodr ( NSPMAX ) common / svsp / nodr , t0sv , cksv , rpbsv real * 8 :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 integer :: np , nf real * 8 :: tf ( NFMAX ), rf ( 3 , NFMAX ), ef ( NFMAX ), rmuf ( NFMAX ) common / ldptcl / tf , rf , ef , rmuf , np , nf character ( len = 256 ) :: dir common / dir / dir integer :: nodes , chunk integer :: id character ( len = 2 ) :: rankstr common / rankstr / rankstr integer :: iseed , nseeds ( nseedmax ) common / seed / nseeds real * 8 :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip data densw0 / 16641 0.0 / !332820.d0/ data k4ok2 / 1 2.4242d0 / , k6ok2 / 24 2.4242d0 / real * 8 :: trgtfs ( 4 ), sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 real * 8 :: df0 ( 3 ), ddf0 ( 3 , 3 ), b1s , gb1s ( 3 ) integer :: nsplvl real * 8 :: bv0 ( 3 ), bm , cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), dbbds , pol integer :: ino , ino0 , i , npp , n1 , ns , itjul , iyear , iyday real * 8 :: dnsk , vsk , vnr ( 3 ), vnx ( 3 ), ck , fs , t0 , tsp real * 8 :: e0 , flx , dflx , tnp , lsp , pa0 , df0dmu , ddf0dmu2 character ( len =* ), parameter :: writefmt = \"(e15.7,7(1pe13.5),i3,i3,i3)\" real * 8 :: t , pab , rate , hb , treal , tod , doy , tb , fb_ real * 8 :: dino nodes = 39 !<100 for # of output files chunk = 1 call readparam ( nodes ) call loadmaggrid_processed call prepareptcl call preparedmumu call preparedxx call preparefb call record_nodes ( nnds , nodes ) write ( * , * ) 'nodes=' , nodes !   normalize mean free path at 1 GV e0 = rp2e ( 1.0d0 ) call set_rlambda ( e0 ) call set_rlambdax ( e0 ) call preparecme num = 1 iseed = - 1 te = 0.0 id = 0 write ( rankstr , \"(i0.2)\" ) id call fl_open ( nfl , nsts ) call writehead do i = 1 , nf flx = 0.0 dflx = 0.0 tnp = 0.0 rp0 ( 1 ) = rf ( 1 , i ) rp0 ( 2 ) = rf ( 2 , i ) * PI / 180 rp0 ( 3 ) = rf ( 3 , i ) * PI / 180 rp0 ( 4 ) = e2p ( ef ( i )) rp0 ( 5 ) = rmuf ( i ) t0org = tf ( i ) te = t0org - tcme0 !time from cme onset lsp = floor ( te / tdl ) npp = np / 2 ** lsp if ( npp <= 0 ) npp = 1 sp = gp - ( gp - sp0 ) / 2 ** lsp !call setasgp(t0org,rp0) r0 ( 1 : 3 ) = rp0 ( 1 : 3 ) pa0 = rp0 ( 5 ) call f0mod ( r0 , pa0 , h0 , df0 , ddf0 , df0dmu , ddf0dmu2 ) call drvbmag ( r0 , bv0 , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) x0 ( 1 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * cos ( r0 ( 3 )) x0 ( 2 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * sin ( r0 ( 3 )) x0 ( 3 ) = r0 ( 1 ) * cos ( r0 ( 2 )) !call inorout(t0org, x0, ino0, dnsk, vsk, vnx) call inorout ( t0org , x0 , dnsk , vsk , vnx ) write ( nsts , * ) 'For flux at point' , i write ( nsts , * ) 'Time,postion,energy/n,\\mu' write ( nsts , \"(f12.5,3f11.4,e13.5,f9.5,2(1pe13.5))\" ) tf ( i ), rf ( 1 : 3 , i ), ef ( i ), rmuf ( i ) write ( nsts , \"(' sp = ',1pe12.4,'; ap = ',1pe12.4)\" ) sp , ap write ( nsts , * ) 'Sample source injection location output are:' write ( nsts , * ) 'tlast,exp(ck-hb+h0),rpb,ns,nsplvl' call flush ( nsts ) !$OMP  PARALLEL NUM_THREADS(nodes) DEFAULT(firstprivate)& !$OMP& SHARED(rp0,h0,chunk,np,nseeds,bgrid,flx,dflx) id = OMP_GET_THREAD_NUM () iseed = nseeds ( id + 1 ) !$OMP DO SCHEDULE(DYNAMIC,chunk) REDUCTION(+:flx,dflx) do n1 = 1 , npp ck = 0.0 fs = 0.0 nsplvl = 0 t0 = 0.0 tsp = t0 + tdl ns = 0 ino = ino0 if ( tsp > te ) tsp = te call walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , ino , bv0 , nsplvl ) if ( ns == - 1 . and . tsp < te ) then dino = real ( ino , kind ( 1.0d0 )) call split ( iseed , rpb , ck , fs , t , nsplvl , dino , bv0 , flx , dflx , walk3d ) else rb ( 1 : 3 ) = rpb ( 1 : 3 ) pab = rpb ( 5 ) call f0mod ( rb , pab , hb , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hb + h0 ) if ( ns >= 0 ) ns = 1 !write(nsts, writefmt) t0org-t, rate, rpb, fs, ns, nsplvl !call flush(nsts) fb_ = fb0 ( tb , rpb ) * rate / 2 ** nsplvl flx = flx + ( fs + fb_ ) dflx = dflx + ( fs + fb_ ) * ( fs + fb_ ) end if end do !$OMP END DO !$OMP BARRIER !$OMP END PARALLEL write ( nsts , writefmt ) - 100 0. , 1. , 1. , 1. , 1. , 1. , 1. , 1. , - 9 , - 1 call flush ( nsts ) if ( rnm > 0.5 ) then flx = flx / npp * rnm / rnz * rp0 ( 4 ) ** 2 * 3e7 !flux in 1/(cm&#94;2 s sr MeV/n) dflx = sqrt ( dflx ) / npp * rnm / rnz * rp0 ( 4 ) ** 2 * 3e7 else flx = flx / npp * rp0 ( 4 ) ** 2 * 3e7 !flux in 1/(cm&#94;2 s sr MeV) dflx = sqrt ( dflx ) / npp * rp0 ( 4 ) ** 2 * 3e7 end if treal = dmapjul + tf ( i ) / 144 0.0 itjul = floor ( treal ) call caldate ( treal , iyear , iyday ) tod = treal - itjul doy = iyday + tod write ( nfl , \"(i4,f12.7,7(1pe12.4))\" ) iyear , doy , rf ( 1 : 3 , i ), ef ( i ), rmuf ( i ), flx , dflx call flush ( nfl ) end do call fl_close ( nfl , nsts ) contains !  random walk of energetic particles in magnetic !  variables: t, xp(5) !  x - spatial coordinators !  p - momentum !  pa - pitch angle subroutine walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , ino , bv0 , nsplvl ) ! rp0,rpb = (r,theta, phi, p, pa)  theta=const, phi follows Parker spiral ! initial or boundary value use param , only : cspeed , gamma use fb , only : fs0 implicit none real * 8 :: ck , fs , t0 , t , tsp integer :: ns , nsplvl , ino integer :: id real * 8 , parameter :: rdpmax = 100 integer :: is ( 3 ) real * 8 :: rp0 ( 5 ), rpb ( 5 ) real * 8 :: xpk ( 6 ), x ( 3 ), r ( 3 ), vx ( 3 ), bv ( 3 ), bv0 ( 3 ) real * 8 :: dxpkdt ( 6 ), gxw2 ( 3 ), gxw3 ( 3 ), gxw2m , gxw3m , gxwmax real * 8 :: dxpkdt1 ( 6 ), gxw2s ( 3 ), gxw3s ( 3 ) real * 8 :: dxpk1 ( 6 ), dxpk2 ( 6 ), dxpk ( 6 ), xpk1 ( 6 ) real * 8 :: cvtu ( 3 ), cvtu0 ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), b1s , gb1s ( 3 ) real * 8 :: culper ( 3 ), culpar ( 3 ) real * 8 :: uax1 ( 3 ), uax2 ( 3 ), uax3 ( 3 ), uax20 ( 3 ) real * 8 :: e ( 2 ), sqrte ( 2 ) real * 8 :: dw ( 3 ), bw ( 3 ) real * 8 :: gb ( 3 ), gr ( 3 , 3 ), dgr ( 3 ), dgx ( 3 ) real * 8 :: b2x ( 3 , 3 ), r2x ( 3 , 3 ), b2r ( 3 , 3 ) real * 8 :: vpl ( 3 ), gvpl ( 3 , 3 ) integer :: iseed , nseeds ( nseedmax ) common / seed / nseeds real * 8 :: vd ( 3 ) integer :: nlambdaconst common / nlambdaconst / nlambdaconst real * 8 :: densw0 , vsw , k4ok2 , k6ok2 , vom , facip , b1au , omega common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip integer :: ndpdt common / ndpdt / ndpdt !data e/5e-6, 0.005/ data e / 5e-8 , 0.005 / real * 8 :: p , pa , p0 , pa0 , pas , hs real * 8 :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real * 8 :: rnz , rnm common / specie / rnz , rnm real * 8 :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real * 8 :: trgtfs ( 4 ), sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: iw , n , isp , kf real * 8 :: df0 ( 3 ), ddf0 ( 3 , 3 ) real * 8 :: dnsk , vsk , vnr ( 3 ), vnx ( 3 ) real * 8 :: rsh ( 3 ), fs1 , dt , srdt , du , densw , gper , tsh , ob , vswn real * 8 :: dtmax , dtmin1 , dtmin2 , dtmin3 , dtmin4 , dtmin5 real * 8 :: u1 , amach , costheta2 , sintheta2 , va , vs , smach , tempsw , tacc real * 8 :: dlt , dtsk , dxdtn , g2n , fs2 , pinj , pc , rbf , rshf , rprs real * 8 :: tempds , vthds r ( 1 : 3 ) = rp0 ( 1 : 3 ) ! Convert spherical coordinates to Cartesian xpk ( 1 ) = r ( 1 ) * dsin ( r ( 2 )) * dcos ( r ( 3 )) xpk ( 2 ) = r ( 1 ) * dsin ( r ( 2 )) * dsin ( r ( 3 )) xpk ( 3 ) = r ( 1 ) * dcos ( r ( 2 )) p0 = rp0 ( 4 ) pa0 = rp0 ( 5 ) p = p0 pa = pa0 fs1 = 0.0 xpk ( 4 ) = p xpk ( 5 ) = pa xpk ( 6 ) = ck t = t0 !0.0 ns = 0 !write(*,*)'t=',t !ck=ck0 !0.0 n = 0 iw = 1 isp = 1 sqrte ( 1 : 2 ) = sqrt ( e ( 1 : 2 )) dt = e ( isp ) srdt = sqrte ( isp ) do while ( iw == 1 ) !write(59,\"(f14.6,12(1pe14.5))\") t,xpk,fs1,fs call vfunc ( t , xpk , dxpkdt , du , gxw2 , gxw3 , bv0 , densw , vpl , gper , b1s ) dtmax = epsilon ( 2 ) * r ( 1 ) / CSPEED dt = dtmax dtmin1 = epsilon ( 1 ) ** 2 / ( 2 * du ) if ( dt > dtmin1 ) dt = dtmin1 dtmin2 = abs ( epsilon ( 1 ) / dxpkdt ( 5 )) if ( dt > dtmin2 ) dt = dtmin2 gxw2m = norm2 ( gxw2 ( 1 : 3 )) gxw3m = norm2 ( gxw3 ( 1 : 3 )) gxwmax = max ( gxw3m , gxw3m ) dtmin3 = ( epsilon ( 2 ) * r ( 1 )) ** 2 / ( 2. * gxwmax ) if ( dt > dtmin3 ) dt = dtmin3 dtmin4 = epsilon ( 2 ) * r ( 1 ) / norm2 ( dxpkdt ( 1 : 3 )) if ( dt > dtmin4 ) dt = dtmin4 dtmin5 = epsilon ( 4 ) / abs ( dxpkdt ( 6 )) if ( dt > dtmin5 ) dt = dtmin5 dt = dt / 2 srdt = sqrt ( dt ) !write(98,\"(10e12.4)\") r(1),dtmax,dtmin1,dtmin2,dtmin3,dtmin4,dtmin5 !  use EM scheme dw ( 1 ) = gasdev ( iseed ) dxpk = dxpkdt * dt dxpk ( 5 ) = dxpk ( 5 ) + sqrt ( 2 * du ) * dw ( 1 ) * srdt xpk = xpk + dxpk if ( xpk ( 5 ) > 1.0 ) xpk ( 5 ) = 0.99999 if ( xpk ( 5 ) < - 1.0 ) xpk ( 5 ) = - 0.99999 !    g1,2,3 ---- kappa z,x,y !   step forward stochastic differential equation (Euler scheme) !   calculate Wiener noise for spatial diffusion dw ( 2 ) = gasdev ( iseed ) dw ( 3 ) = gasdev ( iseed ) !   calculate increments due to spatial diffusion term xpk ( 1 : 3 ) = xpk ( 1 : 3 ) + ( gxw2 ( 1 : 3 ) * dw ( 2 ) + gxw3 ( 1 : 3 ) * dw ( 3 )) * srdt t = t + dt n = n + 1 ! Convert Cartesian coordinates to spherical coordinates r ( 1 ) = norm2 ( xpk ( 1 : 3 )) r ( 2 ) = dacos ( xpk ( 3 ) / r ( 1 )) r ( 3 ) = datan2 ( xpk ( 2 ), xpk ( 1 )) !  sum source tsh = t0org - t !call inorout(tsh, xpk, ino, dnsk, vsk, vnx) call inorout ( tsh , xpk , dnsk , vsk , vnx ) if ( b1s > 0 . and . dnsk > 0 ) then bm = norm2 ( bv0 ( 1 : 3 )) call mrtx ( sin ( r ( 2 )), cos ( r ( 2 )), sin ( r ( 3 )), cos ( r ( 3 )), r2x ) vnr ( 1 : 3 ) = vnx ( 1 ) * r2x ( 1 , 1 : 3 ) + vnx ( 2 ) * r2x ( 2 , 1 : 3 ) + vnx ( 3 ) * r2x ( 3 , 1 : 3 ) ob = acos ( abs ( bv0 ( 1 ) * vnr ( 1 ) + bv0 ( 2 ) * vnr ( 2 ) + bv0 ( 3 ) * vnr ( 3 )) / bm ) vswn = sum ( vpl * vnr ) u1 = vsk - vswn !if (u1 < 0) write(*,*) 'NaN1' va = 18 7.8 * bm / sqrt ( densw ) amach = u1 / va call solarwindtemp ( r , tempsw ) vs = 7.83e-6 * sqrt ( gamma * tempsw ) smach = u1 / vs if ( amach > 1.0 ) then call compress ( amach , smach , ob , rsh ) costheta2 = cos ( ob ) ** 2 sintheta2 = 1 - costheta2 rshf = 1 do kf = 1 , 3 rbf = rsh ( kf ) * ( amach * amach - costheta2 ) / ( amach * amach - rsh ( kf ) * costheta2 ) if ( rbf > 1.0000001d0 . and . rsh ( kf ) > 1.0000001d0 ) rshf = rsh ( kf ) end do rprs = 1 + gamma * smach * smach * ( rshf - 1 ) / rshf * ( 1 - rshf * sintheta2 * (( rshf + 1 )& * amach * amach - 2 * rshf * costheta2 ) / 2 / ( amach * amach - rshf * costheta2 ) ** 2 ) tempds = tempsw / rshf * rprs vthds = 7.83e-6 * sqrt ( 2 * tempds ) !    vthds ~ Vsh due to shock heating (mainly protons) if ( dxpkdt ( 4 ) > 0 ) then tacc = xpk ( 4 ) / dxpkdt ( 4 ) else tacc = 1e10 end if dtsk = tsh - tcme0 if ( tacc > dtsk ) tacc = dtsk fs1 = fs0 ( tacc , xpk , bm , u1 , densw , ob , amach , rshf , vthds , pinj , pc ) pas = xpk ( 5 ) ck = xpk ( 6 ) call f0mod ( r , pas , hs , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hs + h0 ) g2n = gper * sin ( ob ) ** 2 dxdtn = dxpkdt ( 1 ) * vnx ( 1 ) + dxpkdt ( 2 ) * vnx ( 2 ) + dxpkdt ( 3 ) * vnx ( 3 ) dlt = dnsk / ( g2n + dxdtn ** 2 * dt / 2 ) fs2 = fs1 * dlt * rate / 2 ** nsplvl fs = fs + fs2 !if (fs1 == 0) write(nsts,\"(e15.7,15(1pe14.5e3))\") dtsk, xpk, fs1, rate, dlt, u1, amach, smach, ob !   if local shock acceleration injection cutoff, add to p instead source if ( pc < xpk ( 4 )) xpk ( 4 ) = xpk ( 4 ) * ( 1 - u1 * ( 1 - 1 / rshf ) / 3 * dlt ) end if end if if (( xpk ( 4 ) < rp0 ( 4 ) / rdpmax ) . or . ( xpk ( 4 ) > rdpmax * rp0 ( 4 ))) then iw = 0 ns = - 2 end if if ( r ( 1 ) > rmax ) then iw = 0 ns = - 3 end if if ( r ( 1 ) < rb0 ) then iw = 0 ns = n end if if ( t > tsp ) then iw = 0 ns = - 1 end if if ( t > te ) then iw = 0 ns = - 4 end if end do rpb ( 1 : 3 ) = r ( 1 : 3 ) rpb ( 4 : 5 ) = xpk ( 4 : 5 ) ck = xpk ( 6 ) end subroutine walk3d end program","tags":"","url":"sourcefile/sim3d_em.f90.html"},{"title":"combiner.f90 – Fortran Program","text":"Source Code program combon ! USES environment variables !     COMBINER_B1RS_INFILENAME !     COMBINER_MAGGRID_INFILENAME !     COMBINER_MAGGRID_OUTFILENAME use iso_fortran_env , only : real64 use file_op , only : open_file_from_environment implicit none real ( kind = real64 ) :: b ( 3 ), cv ( 3 ), gb ( 3 ), b1rs integer :: i , j , k integer :: b1rs_infileunit integer :: maggrid_infileunit , maggrid_outfileunit call open_file_from_environment (& \"COMBINER_B1RS_INFILENAME\" , b1rs_infileunit , 'FORMATTED' ) call open_file_from_environment (& \"COMBINER_MAGGRID_INFILENAME\" , maggrid_infileunit , 'FORMATTED' ) call open_file_from_environment (& \"COMBINER_MAGGRID_OUTFILENAME\" , maggrid_outfileunit , 'FORMATTED' ) do k = 0 , 150 do i = 0 , 180 do j = 0 , 360 read ( b1rs_infileunit , * ) b1rs read ( maggrid_infileunit , * ) b ( 1 : 3 ), gb ( 1 : 3 ) write ( maggrid_outfileunit , * ) b ( 1 : 3 ), gb ( 1 : 3 ), b1rs !read(f2) b(1:3), cv(1:3), gb(1:3) !write(f3) b(1:3), cv(1:3), gb(1:3), b1rs(1:2) end do end do end do close ( b1rs_infileunit ) close ( maggrid_infileunit ) close ( maggrid_outfileunit ) end program combon","tags":"","url":"sourcefile/combiner.f90.html"},{"title":"shockfront.f90 – Fortran Program","text":"Source Code program shockfront !  Source injection at shocks !  time backward simulation to calculate fluxes at locations in IP !  pfss magnetic field model !  calculation is done in corotation reference frame !  pitch angle with outward magnetic field line !  pitch angle diffusion (symmetric D_{\\mu\\mu}) !  perpendicular diffusion added use iso_fortran_env , only : real64 use datetime_utils , only : caldate use param , only : PI , GAMMA_CS , NSPMAX , NFMAX , NSEEDMAX , & N_R , N_THETA , N_PHI , epsilon , bgrid , gbgrid , b1rsgrid !, cvgrid use epv , only : rp2e , e2p use cme_cross , only : inorout , preparecme , locate use fb , only : fb0 , preparefb use sim3d_utils , only : f0mod , compress , solarwindtemp , split use mtrx , only : drvbmag , vfunc , mrtx , mxptr , norm2 use file_op , only : read_maggrid , read_b1rs , read_param , record_nodes , fl_open , write_head use loadptcl , only : prepareptcl use dmumu , only : preparedmumu use dxx , only : preparedxx , set_rlambda , set_rlambdax use random , only : gasdev implicit none include 'omp_lib.h' integer , parameter :: NM1 = 16 , NMXID = 40 real ( kind = real64 ) :: rpb ( 5 ), rp0 ( 5 ), rp0org ( 5 ) real ( kind = real64 ) :: r0 ( 3 ), rb ( 3 ) real ( kind = real64 ) :: x0 ( 6 ) real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm integer :: nsucmin common / nsucmin / nsucmin integer :: npmax common / npmax / npmax integer :: npp , n1 , num ( 3 ) real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real ( kind = real64 ) :: t0 , t , tnp integer :: ndpdt common / ndpdt / ndpdt real ( kind = real64 ) :: t0sv ( 2 ** ( NSPMAX + 1 )), cksv ( 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: rpbsv ( 5 , 2 ** ( NSPMAX + 1 )) integer :: nodr ( NSPMAX ) common / svsp / nodr , t0sv , cksv , rpbsv real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ), allocatable :: tf (:), rf (:,:), ef (:), rmuf (:) !real(kind=real64)   :: tf(NFMAX), rf(3, NFMAX), ef(NFMAX), rmuf(NFMAX) integer :: np , nf !common/ldptcl/tf,rf,ef,rmuf,np,nf character ( len = 256 ) :: dir common / dir / dir integer :: nodes , chunk , id character ( len = 2 ) :: rankstr common / rankstr / rankstr integer :: iseed integer , allocatable :: nseeds (:) real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: trgtfs ( 4 ), ap , h0 , gp , sp , sp0 , scanw common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: ndmumu common / ndmumu / ndmumu integer :: ndxx common / ndxx / ndxx real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) integer :: nsplvl real ( kind = real64 ) :: bv0 ( 3 ), bm , cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), dbbds real ( kind = real64 ) :: pol , b1s , gb1s ( 3 ) real ( kind = real64 ) :: dnsk0 , vsk , vnr ( 3 ), vnx ( 3 ) integer :: i , j , lsp , ns real ( kind = real64 ) :: df0dmu , ddf0dmu2 , dflux , dflx , doy , flx , flux real ( kind = real64 ) :: e0 , f1 , pa0 , ck real ( kind = real64 ) :: fs , pab , hb , rate , tsp , tb real ( kind = real64 ) :: fb_ real ( kind = real64 ) :: rdf , treal , tod integer :: itjul , iyear , iyday character ( len =* ), parameter :: writefmt = \"(i1,i3,8(1pe13.5),i3)\" integer :: nfl , nsts !real(kind=real64) :: bgrid(0:N_R, 0:N_THETA, 0:N_PHI, 3) !real(kind=real64) :: gbgrid(0:N_R, 0:N_THETA, 0:N_PHI, 3) !real(kind=real64) :: b1rsgrid(0:N_R, 0:N_THETA, 0:N_PHI) ! dummy storage densw0 = 6641 0.0 !332820.d0 k4ok2 = 1 2.4242d0 k6ok2 = 24 2.4242d0 nodes = 1 ! default, will be read in readparm from 'dir.dat' if ( nodes > NMXID ) stop 'nodes > NMXID' chunk = 1 call read_param ( nodes , nseeds ) nodes = 1 !!! force nodes = 1 call read_maggrid ( bgrid , gbgrid ) call read_b1rs ( b1rsgrid ) call prepareptcl ( tf , rf , ef , rmuf , np , nf ) call preparedmumu ( ndmumu ) call preparedxx ( ndxx ) call preparefb call record_nodes ( nodes ) write ( * , * ) 'nodes =' , nodes !   normalize mean free path at 1 GV e0 = rp2e ( 1.0d0 ) call set_rlambda ( e0 ) call set_rlambdax ( e0 ) call preparecme num = 1 iseed = - 1 te = 0.0 id = 0 write ( rankstr , \"(i0.2)\" ) id call fl_open ( nfl , nsts ) call write_head ( nfl , np ) ! ========== force 1 particle and no split ============================= np = 1 tdl = 1.e10 ! ======================================= do i = 1 , nf flx = 0.0 dflx = 0.0 tnp = 0.0 rp0 ( 1 ) = rf ( 1 , i ) rp0 ( 2 ) = rf ( 2 , i ) * PI / 180 rp0 ( 3 ) = rf ( 3 , i ) * PI / 180 rp0 ( 4 ) = e2p ( ef ( i )) rp0 ( 5 ) = rmuf ( i ) t0org = tf ( i ) te = t0org - tcme0 !time from cme onset lsp = floor ( te / tdl ) npp = ceiling ( 1.d0 * np * ( lsp + 1 ) / ( 2.0 ** ( lsp + 1 ) - 1 )) if ( npp <= 0 ) npp = 1 sp = sp0 + ( gp - sp0 ) * log ( 1. + te / 18 0. ) !call setasgp(t0org,rp0) r0 ( 1 : 3 ) = rp0 ( 1 : 3 ) pa0 = rp0 ( 5 ) call f0mod ( r0 , pa0 , h0 , df0 , ddf0 , df0dmu , ddf0dmu2 ) call drvbmag ( r0 , bv0 , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) x0 ( 1 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * cos ( r0 ( 3 )) x0 ( 2 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * sin ( r0 ( 3 )) x0 ( 3 ) = r0 ( 1 ) * cos ( r0 ( 2 )) call inorout ( t0org , x0 , dnsk0 , vsk , vnx ) write ( nsts , * ) 'For flux at point' , i write ( nsts , * ) 'Time,postion,energy/n,\\mu' write ( nsts , \"(f12.5,3f11.4,e13.5,f9.5,2(1pe13.5))\" ) tf ( i ), rf ( 1 : 3 , i ), ef ( i ), rmuf ( i ) write ( nsts , \"(' sp = ',1pe12.4,'; ap = ',1pe12.4)\" ) sp , ap write ( nsts , * ) 'number of original particles npp = ' , npp write ( nsts , * ) 'Nonzero source or boundary value list (f1)' write ( nsts , * ) 'Indicator: 0=summed,1=source,2=boundary value' write ( nsts , * ) 'List may be longer than npp due to split' !call flush(nsts) flush ( nsts ) !$OMP  PARALLEL NUM_THREADS(nodes) DEFAULT(firstprivate)& !$OMP& SHARED(rp0,h0,chunk,np,nseeds,bgrid,gbgrid,flx,dflx) !! SHARED(cvgrid) id = OMP_GET_THREAD_NUM () iseed = nseeds ( id + 1 ) !$OMP DO SCHEDULE(DYNAMIC,chunk) REDUCTION(+:flx,dflx) do n1 = 1 , npp ck = 0.0 fs = 0.0 nsplvl = 0 t0 = 0.0 tsp = t0 + tdl ns = 0 if ( tsp > te ) tsp = te call walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , dnsk0 , bv0 , nsplvl ) if ( ns == - 1 . and . tsp < te ) then call split ( iseed , rpb , ck , fs , t , nsplvl , dnsk0 , bv0 , flx , dflx , walk3d , nsts ) else rb ( 1 : 3 ) = rpb ( 1 : 3 ) pab = rpb ( 5 ) call f0mod ( rb , pab , hb , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hb + h0 ) if ( ns >= 0 ) ns = 1 fb_ = fb0 ( tb , rpb ) * rate f1 = ( fs + fb_ ) / 2 ** nsplvl if ( fs > 1.d-40 ) write ( nsts , writefmt ) 0 , nsplvl , fs !if (fb_ > 1.d-30) write(nsts,writefmt) 2,nsplvl,fb_,t0org-t,rate,rpb,ns !call flush(nsts) flush ( nsts ) !OMP CRITICAL sum flx = flx + f1 dflx = dflx + f1 * f1 !OMP END CRITICAL sum end if end do !$OMP END DO !$OMP BARRIER !$OMP END PARALLEL !write(nsts,*) 'end of list' !call flush(nsts) flush ( nsts ) flux = flx / npp dflux = sqrt ( dflx ) / npp rdf = dflux / flux flux = flux * rp0 ( 4 ) ** 2 * 3e7 !flux in 1/(cm&#94;2 s sr MeV/n) dflux = dflux * rp0 ( 4 ) ** 2 * 3e7 if ( rnm > 0.5 ) then flux = flux * rnm / rnz dflux = dflux * rnm / rnz end if treal = dmapjul + tf ( i ) / 144 0.0 itjul = floor ( treal ) call caldate ( treal , iyear , iyday ) tod = treal - itjul doy = iyday + tod write ( nfl , \"(i4,f12.7,7(1pe12.4))\" ) iyear , doy , rf (:, i ), ef ( i ), rmuf ( i ), flux , dflux !call flush(nfl) flush ( nfl ) end do close ( nfl ) close ( nsts ) close ( 54 ) contains !  random walk of energetic particles in magnetic !  variables: t, xp(5) !  x - spatial coordinators !  p - momentum !  pa - pitch angle subroutine walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , dnsk0 , bv0 , nsplvl ) ! rp0,rpb = (r,theta, phi, p, pa)  theta=const, phi follows Parker spiral ! initial or boundary value use param , only : CSPEED use fb , only : fs0 implicit none real ( kind = real64 ) :: ck , fs , t0 , t , tsp integer :: ns , nsplvl integer :: id real ( kind = real64 ), parameter :: rdpmax = 100 integer :: is ( 3 ) real ( kind = real64 ) :: rp0 ( 5 ), rpb ( 5 ) real ( kind = real64 ) :: xpk ( 6 ), x ( 3 ), r ( 3 ), vx ( 3 ), bv ( 3 ), bv0 ( 3 ) real ( kind = real64 ) :: dxpkdt ( 6 ), gxw2 ( 3 ), gxw3 ( 3 ) real ( kind = real64 ) :: dxpkdt1 ( 6 ), gxw2s ( 3 ), gxw3s ( 3 ) real ( kind = real64 ) :: dxpk1 ( 6 ), dxpk2 ( 6 ), dxpk ( 6 ), xpk1 ( 6 ) real ( kind = real64 ) :: cvtu ( 3 ), cvtu0 ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), b1s , gb1s ( 3 ) real ( kind = real64 ) :: culper ( 3 ), culpar ( 3 ) real ( kind = real64 ) :: uax1 ( 3 ), uax2 ( 3 ), uax3 ( 3 ), uax20 ( 3 ) real ( kind = real64 ) :: e ( 2 ), sqrte ( 2 ) real ( kind = real64 ) :: dw ( 3 ), bw ( 3 ) real ( kind = real64 ) :: gb ( 3 ), gr ( 3 , 3 ), dgr ( 3 ), dgx ( 3 ) real ( kind = real64 ) :: b2x ( 3 , 3 ), r2x ( 3 , 3 ), b2r ( 3 , 3 ) real ( kind = real64 ) :: vpl ( 3 ), gvpl ( 3 , 3 ) integer :: iseed real ( kind = real64 ) :: vd ( 3 ) integer :: nlambdaconst common / nlambdaconst / nlambdaconst real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , vom , facip , b1au , omega common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip integer :: ndpdt common / ndpdt / ndpdt !data e/5e-6, 0.005/ data e / 5e-8 , 0.005 / real ( kind = real64 ) :: p , pa , p0 , pa0 , pas , hs real ( kind = real64 ) :: te , tdl , tcme0 , dmapjul , t0org common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real ( kind = real64 ) :: trgtfs ( 4 ), sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: iw real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) real ( kind = real64 ) :: dnsk0 , dnsk , vsk , vnr ( 3 ), vnx ( 3 ) real ( kind = real64 ) :: rsh ( 3 ) real ( kind = real64 ) :: fs1 , dt , srdt , tsh , vptc integer :: n , isp , i , kf real ( kind = real64 ) :: du , densw , gper , dtmax , dtmin1 , dtmin2 , dtmin3 , dtmin4 , dtmin5 real ( kind = real64 ) :: bm , ob , amach , va , u1 , vswn , costheta2 , sintheta2 , df0dmu , ddf0dmu2 , dlt real ( kind = real64 ) :: vs , tempsw , dtsk , dxdtn , g2n , pinj , pc , rate , rbf , rprs , rshf real ( kind = real64 ) :: smach , tacc , tempds , vthds r ( 1 : 3 ) = rp0 ( 1 : 3 ) xpk ( 1 ) = r ( 1 ) * dsin ( r ( 2 )) * dcos ( r ( 3 )) xpk ( 2 ) = r ( 1 ) * dsin ( r ( 2 )) * dsin ( r ( 3 )) xpk ( 3 ) = r ( 1 ) * dcos ( r ( 2 )) p0 = rp0 ( 4 ) pa0 = rp0 ( 5 ) p = p0 pa = pa0 fs1 = 0. xpk ( 4 ) = p xpk ( 5 ) = pa xpk ( 6 ) = ck dnsk = dnsk0 t = t0 !0.0 ns = 0 !write(*,*)'t =',t !ck = ck0 !0.0 n = 0 iw = 1 isp = 1 sqrte ( 1 : 2 ) = sqrt ( e ( 1 : 2 )) dt = e ( isp ) srdt = sqrte ( isp ) do while ( iw == 1 ) if ( n == 64440 ) then close ( 69 ) stop end if t = t0org + 9 0.0 - 0.05 * n tsh = t0org - t call sksurface ( tsh , xpk , mod ( n , 2 )) !write(59,\"(f14.6,12(1pe14.5))\") t,xpk,fs1,fs call vfunc ( t , xpk , dxpkdt , du , gxw2 , gxw3 , bv0 , densw , vpl , gper , b1s ) dtmax = epsilon ( 2 ) * r ( 1 ) / CSPEED dt = dtmax dtmin1 = epsilon ( 1 ) ** 2 / ( 2 * du ) if ( dt > dtmin1 ) dt = dtmin1 dtmin2 = abs ( epsilon ( 1 ) / dxpkdt ( 5 )) if ( dt > dtmin2 ) dt = dtmin2 dtmin3 = ( epsilon ( 2 ) * r ( 1 )) ** 2 / ( 2. * gper ) if ( dt > dtmin3 ) dt = dtmin3 vptc = sqrt ( dxpkdt ( 1 ) ** 2 + dxpkdt ( 2 ) ** 2 + dxpkdt ( 3 ) ** 2 ) dtmin4 = epsilon ( 2 ) * r ( 1 ) / vptc if ( dt > dtmin4 ) dt = dtmin4 dtmin5 = epsilon ( 4 ) / abs ( dxpkdt ( 6 )) if ( dt > dtmin5 ) dt = dtmin5 !   slow down at shock !ddif2 = 16*gper*gper/vptc/vptc !if (dnsk0*dnsk0 < ddif2) then !  dtmin6 = 0.125*gper/vptc**2 !  if (dt > dtmin6) dt = dtmin6 !end if dt = dt / 2 srdt = sqrt ( dt ) !  use EM scheme dw ( 1 ) = gasdev ( iseed ) dxpk = dxpkdt * dt dxpk ( 5 ) = dxpk ( 5 ) + sqrt ( 2 * du ) * dw ( 1 ) * srdt xpk = xpk + dxpk if ( xpk ( 5 ) > 1.0 ) xpk ( 5 ) = 0.99999 if ( xpk ( 5 ) < - 1.0 ) xpk ( 5 ) = - 0.99999 !    g1,2,3 ---- kappa z,x,y !   step forward stochastic differential equation (Euler scheme) !   calculate Wiener noise for spatial diffusion dw ( 2 ) = gasdev ( iseed ) dw ( 3 ) = gasdev ( iseed ) !   calculate increments due to spatial diffusion term xpk ( 1 : 3 ) = xpk ( 1 : 3 ) + ( gxw2 ( 1 : 3 ) * dw ( 2 ) + gxw3 ( 1 : 3 ) * dw ( 3 )) * srdt t = t + dt n = n + 1 !   change the position to spheric coordinates r ( 1 ) = norm2 ( xpk ( 1 : 3 )) r ( 2 ) = dacos ( xpk ( 3 ) / r ( 1 )) r ( 3 ) = datan2 ( xpk ( 2 ), xpk ( 1 )) !  sum source tsh = t0org - t call inorout ( tsh , xpk , dnsk , vsk , vnx ) if ( dnsk0 * dnsk < 0 ) then bm = norm2 ( bv0 ( 1 : 3 )) r2x = mrtx ( sin ( r ( 2 )), cos ( r ( 2 )), sin ( r ( 3 )), cos ( r ( 3 ))) vnr ( 1 : 3 ) = vnx ( 1 ) * r2x ( 1 , 1 : 3 ) + vnx ( 2 ) * r2x ( 2 , 1 : 3 ) + vnx ( 3 ) * r2x ( 3 , 1 : 3 ) ob = acos ( abs ( dot_product ( bv0 ( 1 : 3 ), vnr ( 1 : 3 ))) / bm ) vswn = dot_product ( vpl ( 1 : 3 ), vnr ( 1 : 3 )) u1 = vsk - vswn ! if (u1 < 0) write(*,*) 'NaN1' va = 18 7.8 * bm / sqrt ( densw ) amach = u1 / va tempsw = solarwindtemp ( r ) vs = 7.83e-6 * sqrt ( GAMMA_CS * tempsw ) smach = u1 / vs if ( amach > - 1.0d20 ) then rsh = compress ( amach , smach , ob ) costheta2 = cos ( ob ) ** 2 sintheta2 = 1 - costheta2 rshf = 1 do kf = 1 , 3 rbf = rsh ( kf ) * ( amach * amach - costheta2 ) / ( amach * amach - rsh ( kf ) * costheta2 ) if (( rbf > 1.0000001d0 ) . and . ( rsh ( kf ) > 1.0000001d0 )) rshf = rsh ( kf ) end do rprs = 1 + GAMMA_CS * smach * smach * ( rshf - 1 ) / rshf * ( 1 - rshf * sintheta2 * (( rshf + 1 )& * amach * amach - 2 * rshf * costheta2 ) / 2 / ( amach * amach - rshf * costheta2 ) ** 2 ) tempds = tempsw / rshf * rprs vthds = 7.83e-6 * sqrt ( 2 * tempds ) !    vthds ~ Vsh due to shock heating (mainly protons) if ( dxpkdt ( 4 ) > 0 ) then tacc = ( xpk ( 4 ) / dxpkdt ( 4 )) else tacc = 1e10 end if dtsk = tsh - tcme0 if ( tacc > dtsk ) tacc = dtsk fs1 = fs0 ( tacc , xpk , bm , u1 , densw , ob , amach , rshf , vthds , pinj , pc ) write ( 69 , \"(20e16.6e3)\" ) xpk ( 1 : 3 ), ob , rshf , vthds , pinj , pc , u1 , amach , smach , b1s , fs1 , tsh pas = xpk ( 5 ) ck = xpk ( 6 ) call f0mod ( r , pas , hs , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hs + h0 ) g2n = gper * sin ( ob ) ** 2 dxdtn = dxpkdt ( 1 ) * vnx ( 1 ) + dxpkdt ( 2 ) * vnx ( 2 ) + dxpkdt ( 3 ) * vnx ( 3 ) dlt = abs ( dnsk ) / ( g2n + dxdtn ** 2 * dt / 2 ) fs = fs + fs1 * dlt * rate !   output to analyze source injection profiles ! if (fs1 > 0.0) write(nsts,\"(i1,i3,16(1pe13.5))\") 1,nsplvl,dtsk,xpk,fs1,rate,dlt,u1,amach,smach,ob !   if local shock acceleration injection cutoff, add to p instead of source if ( pc < xpk ( 4 )) xpk ( 4 ) = xpk ( 4 ) * ( 1 - u1 * ( 1 - 1 / rshf ) / 3 * dlt ) end if end if dnsk0 = dnsk if (( xpk ( 4 ) < rp0 ( 4 ) / rdpmax ) . or . ( xpk ( 4 ) > rdpmax * rp0 ( 4 ))) then iw = 0 ns = - 2 end if if ( r ( 1 ) > rmax ) then iw = 0 ns = - 3 end if if ( r ( 1 ) < rb0 ) then iw = 0 ns = n end if if ( t > tsp ) then iw = 0 ns = - 1 end if if ( t > te ) then iw = 0 ns = - 4 end if end do rpb ( 1 : 3 ) = r ( 1 : 3 ) rpb ( 4 : 5 ) = xpk ( 4 : 5 ) ck = xpk ( 6 ) end subroutine subroutine sksurface ( tsh , x , n ) real ( kind = real64 ), intent ( in ) :: tsh real ( kind = real64 ), intent ( out ) :: x ( 6 ) integer , intent ( in ) :: n real ( kind = real64 ) :: vskf0 , acsk , tska ( 20 ), pska ( 20 , 8 ) integer :: nsk common / cmesk / vskf0 , acsk , tska , pska , nsk real ( kind = real64 ) :: t real ( kind = real64 ) :: rskc , drskc , rskmax , rskmin , ask ( 3 ), dask ( 3 ) real ( kind = real64 ) :: rskf , vskf real ( kind = real64 ) :: thetaskc , phiskc , gmsk , dthetaskc , dphiskc , dgmsk real ( kind = real64 ) :: sinthetask , costhetask , sinphisk , cosphisk real ( kind = real64 ) :: r2xsk ( 3 , 3 ) real ( kind = real64 ) :: xp2r ( 3 , 3 ), xp2x ( 3 , 3 ) real ( kind = real64 ) :: xskc ( 3 ), xc ( 3 ), xpc ( 3 ) real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC common / vsksw / vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 integer :: jt real ( kind = real64 ) :: theta , phi , ep , rac , rbc , rhclf i = floor ( n / 36 0.0 ) j = mod ( n , 360 ) theta = ( i + 0.5 ) * PI / 18 0.0 phi = ( j + 0.5 ) * PI / 18 0.0 if ( tsh < tska ( nsk )) then jt = locate ( tska , nsk , tsh ) if ( jt == 0 ) jt = 1 !  maximum shock radial distance for quick search drskc = ( pska ( jt + 1 , 1 ) - pska ( jt , 1 )) / ( tska ( jt + 1 ) - tska ( jt )) rskc = pska ( jt , 1 ) + ( tsh - tska ( jt )) * drskc dask ( 3 ) = ( pska ( jt + 1 , 6 ) - pska ( jt , 6 )) / ( tska ( jt + 1 ) - tska ( jt )) ask ( 3 ) = pska ( jt , 6 ) + ( tsh - tska ( jt )) * dask ( 3 ) else jt = nsk - 1 vcme0 = vskf0 if ( tsh < tauc2_0 ) then rskf = pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tsh - tska ( nsk )) !LC vskf = vcme0 else if ( tauc2_0 > tska ( nsk )) then rskf = 3.0 / 2.0 * ( vcme0 - vsw ) * tauc2 * ((( tsh - tska ( 1 )) / tauc2 )& ** ( 2.0 / 3.0 ) - 1.0d0 ) + vsw * tauc2 * ((( tsh - tska ( 1 )) / tauc2 ) - 1.0d0 )& + pska ( nsk , 1 ) + pska ( nsk , 6 ) + vcme0 * ( tauc2_0 - tska ( nsk )) !LC else rskf = 3.0 / 2.0 * ( vcme0 - vsw ) * tauc2 * ((( tsh - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 & ) - (( tska ( nsk ) - tska ( 1 )) / tauc2 ) ** ( 2.0 / 3.0 )) + vsw * ( tsh - tska ( nsk ))& + pska ( nsk , 1 ) + pska ( nsk , 6 ) end if vskf = ( vcme0 - vsw ) * ((( tsh - tska ( 1 )) / tauc2 ) ** ( - 1.0d0 / 3.0d0 )) + vsw end if rhclf = pska ( nsk , 6 ) / ( pska ( nsk , 1 ) + pska ( nsk , 6 )) rskc = ( 1 - rhclf ) * rskf drskc = ( 1 - rhclf ) * vskf ask ( 3 ) = rhclf * rskf dask ( 3 ) = rhclf * vskf end if dthetaskc = ( pska ( jt + 1 , 2 ) - pska ( jt , 2 )) / ( tska ( jt + 1 ) - tska ( jt )) thetaskc = pska ( jt , 2 ) + ( tsh - tska ( jt )) * dthetaskc dphiskc = ( pska ( jt + 1 , 3 ) - pska ( jt , 3 )) / ( tska ( jt + 1 ) - tska ( jt )) phiskc = pska ( jt , 3 ) + ( tsh - tska ( jt )) * dphiskc dgmsk = ( pska ( jt + 1 , 7 ) - pska ( jt , 7 )) / ( tska ( jt + 1 ) - tska ( jt )) gmsk = pska ( jt , 7 ) + ( tsh - tska ( jt )) * dgmsk if ( tsh < tska ( nsk )) then dask ( 1 ) = ( pska ( jt + 1 , 4 ) - pska ( jt , 4 )) / ( tska ( jt + 1 ) - tska ( jt )) dask ( 2 ) = ( pska ( jt + 1 , 5 ) - pska ( jt , 5 )) / ( tska ( jt + 1 ) - tska ( jt )) ask ( 1 ) = pska ( jt , 4 ) + ( tsh - tska ( jt )) * dask ( 1 ) ask ( 2 ) = pska ( jt , 5 ) + ( tsh - tska ( jt )) * dask ( 2 ) else rac = pska ( nsk , 4 ) / pska ( nsk , 6 ) ask ( 1 ) = rhclf * rskf * rac dask ( 1 ) = rhclf * vskf * rac rbc = pska ( nsk , 5 ) / pska ( nsk , 6 ) ask ( 2 ) = rhclf * rskf * rbc dask ( 2 ) = rhclf * vskf * rbc end if !  thetaskc is colatitude sinthetask = sin ( thetaskc ) costhetask = cos ( thetaskc ) sinphisk = sin ( phiskc ) cosphisk = cos ( phiskc ) r2xsk = mrtx ( sinthetask , costhetask , sinphisk , cosphisk ) !  r2xsk matrix to convert r-the-phi of shock ellipsoid center to xyz of !    of HEEQ. r=z theta=x, phi=y xp2r = mxptr ( gmsk ) xp2x = matmul ( r2xsk , xp2r ) if ( mod ( n , 2 ) == 0 ) then ep = - 1e-6 else ep = 1e-6 end if xpc ( 1 ) = ( ep + ask ( 1 )) * sin ( theta ) * cos ( phi ) xpc ( 2 ) = ( ep + ask ( 2 )) * sin ( theta ) * sin ( phi ) xpc ( 3 ) = ( ep + ask ( 3 )) * cos ( theta ) xc ( 1 : 3 ) = matmul ( xp2x , xpc ) xskc ( 1 ) = rskc * sinthetask * cosphisk xskc ( 2 ) = rskc * sinthetask * sinphisk xskc ( 3 ) = rskc * costhetask x ( 1 : 3 ) = xc ( 1 : 3 ) + xskc ( 1 : 3 ) print \"(4a, 9e16.6e3)\" , __ FILE__ , \":\" , __ LINE__ , \":\" , xskc (:), thetaskc , phiskc , x ( 1 : 3 ), tsh return end subroutine end program","tags":"","url":"sourcefile/shockfront.f90.html"},{"title":"fb.f90 – Fortran Program","text":"Source Code module fb use iso_fortran_env , only : error_unit , real64 use ieee_arithmetic , only : ieee_is_nan use param , only : CSPEED , EP , EE , PI implicit none real ( kind = real64 ), parameter :: OMGP1 = 574745 !in 1/min real ( kind = real64 ), parameter :: OMGE1 = 1055307413 !in 1/min contains real ( kind = real64 ) function fs0 ( tacc , xpk , bm , u1 , densw , ob , amach , rsh , vth , pinj , pc ) real ( kind = real64 ), intent ( in ) :: xpk ( 6 ) real ( kind = real64 ), intent ( in ) :: tacc , bm , u1 !   densw in cm&#94;-3, fs in cm&#94;-3 (GeV/c)&#94;-3, real ( kind = real64 ), intent ( in ) :: densw real ( kind = real64 ), intent ( in ) :: ob , amach , rsh !   vth thermal speed of protons with downstream Maxwellian temperature real ( kind = real64 ), intent ( in ) :: vth real ( kind = real64 ), intent ( in out ) :: pinj , pc !   fampb is amplification of upstream magnetic field !   ratkp is parallel to perpendicular diff ceof ratio real ( kind = real64 ) :: ecrmax , ecrmin , ob0 , obw , etinj , fampb , ratkp common / acc / ecrmax , ecrmin , ob0 , obw , etinj , fampb , ratkp real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: ob2 , dob , obinj , sgm , facob , pth , e1c , f0 , omegae real ( kind = real64 ) :: p1 , omegap , p1inj ob2 = atan ( rsh * sin ( ob ) / cos ( ob )) dob = amach / sqrt ( 40 * ( 1 + rsh * rsh )) obinj = max ( cos ( ob ), 0.25d0 ) !min(ob2,ob2-dob) etinj = 2.5 / obinj !injection at 3*u1 !   shock slope !rpw = rsh * (amach - 1) / (amach + 1.0*sqrt(rsh)) !if (rpw < 1.00001) rpw = 1.00001 sgm = 3 * rsh / ( rsh - 1 ) !if (sgm > 5.0) then !  skp = sgm/2 - 1 !else !  skp = 1.5 !end if !skp = 30.0 !   obliuity factor for normal diffusion coeffiecient facob = sqrt ( ratkp ) facob = facob * cos ( ob ) ** 2 + sin ( ob ) ** 2 / facob if ( rnm > 0.5 ) then pth = EP * vth / CSPEED ! * sqrt((skp-1.5)/skp) ! to kappa !   assume all species have the same thermal speed !    or temperature proportional to mass (Jacco Vink et al 2015,A&A) pth = rnm / rnz * pth !in rigidity p1 = EP * u1 / CSPEED omegap = OMGP1 * bm * fampb p1inj = etinj * p1 pinj = rnm / rnz * p1inj e1c = hypot ( EP , p1inj ) + p1 * p1 / EP * ( 1 - 1 / rsh ) * tacc * omegap / facob * rnz / rnm pc = sqrt ( e1c * e1c - EP * EP ) * rnm / rnz else ! same thermal speed as protons ! no thermalization between e and p pth = EE * vth / CSPEED p1 = EE * u1 / CSPEED omegae = OMGE1 * bm * fampb p1inj = etinj * p1 pinj = p1inj e1c = hypot ( EE , p1inj ) + p1 * p1 / EE * ( 1 - 1 / rsh ) * tacc * omegae / facob / 100 pc = sqrt ( e1c * e1c - EE * EE ) end if !ecr = (ecrmax + ecrmin - (ecrmax-ecrmin) * tanh((ob-ob0)/obw)) / 2 !   only inject particles reached shock acceleration equilibrium if ( pc > xpk ( 4 )) then !   matching distribution at pinj f0 = densw * rsh / ( PI * pth * pth ) ** 1.5 / exp (( pinj / pth ) ** 2 ) !Maxwellian !f0 = densw * rsh / (PI*pth*pth)**1.5 * & !   exp(log_gamma(skp+1) - log_gamma(skp-0.5)) / skp**1.5 / & !   (1 + (pinj/pth)**2 / skp)**(skp+1) fs0 = f0 * sgm * u1 * ( 1 - 1 / rsh ) / 3 / ( xpk ( 4 ) / pinj ) ** sgm if ( ieee_is_nan ( fs0 )) then !write(*,*) fs0, densw, rsh, pth, pinj, pc, sgm fs0 = 0.0 end if else fs0 = 0.0 end if end function subroutine preparefb integer :: nfbconst real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real ( kind = real64 ) :: sclat , sclong , scanw namelist / fb / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst , sclat , sclong , scanw character ( len = 256 ) :: dir common / dir / dir real ( kind = real64 ) :: sp0 , gp , ap , sp , h0 real ( kind = real64 ) :: trgtfs ( 4 ) common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: nfb open ( newunit = nfb , file = trim ( dir ) // 'inputfb.nml' , status = 'old' ) read ( nfb , nml = fb ) close ( nfb ) trgtfs ( 1 ) = sin ( sclat * PI / 180 ) if ( trgtfs ( 1 ) == 0 ) trgtfs ( 1 ) = 1e-27 trgtfs ( 2 ) = cos ( sclat * PI / 180 ) trgtfs ( 3 ) = sin ( sclong * PI / 180 ) trgtfs ( 4 ) = cos ( sclong * PI / 180 ) scanw = scanw * PI / 180 end subroutine real ( kind = real64 ) function fb0 ( torg , rpb ) real ( kind = real64 ), intent ( in ) :: torg , rpb ( 5 ) !integer             :: nfbconst !real(kind=real64)              :: rb0, rmax, rk, deltat, tc, tl, tmodel0 !common/fbcnst/rb0,rmax,rk,deltat,tc,tl,tmodel0,nfbconst !real(kind=real64)              :: sp0, gp, ap, sp, scanw, h0 !real(kind=real64)              :: trgtfs(4) !common /srcmod/sp,sp0,gp,ap,trgtfs,scanw,h0 !rp = rpb(4) !if (torg < 0 .or. torg > deltat) then !  fb0 = 0.0 !else !  if (nfbconst == 0) then !    tmodel = torg + tmodel0 !    fbtimes = exp(-tc/tmodel - tmodel/tl) / tmodel !    ad = cos(rpb(2)) * trgtfs(2) + sin(rpb(2)) * trgtfs(1) * & !        (cos(rpb(3)) * trgtfs(4) + sin(rpb(3)) * trgtfs(3)) !    if (ad < cos(scanw)) fbtimes = 0.0 !  else !    fbtimes = 1.0 !  end if !    fb0 = rp2e(rp)**rk / (rp*rp) * fbtimes !end if fb0 = 0.0 end function !real(kind=real64) function getdeltat() !  real(kind=real64)  :: rb0, rmax, rk, deltat, tc, tl, tmodel0 !  integer :: nfbconst !  common/fbcnst/rb0,rmax,rk,deltat,tc,tl,tmodel0,nfbconst !  getdeltat = deltat !end function !subroutine getfbcnst(rk0, deltat0, tc0, tl0, tmodel00) !  real(kind=real64), intent(out) :: rk0, deltat0, tc0, tl0, tmodel00 !  integer                        :: nfbconst !  real(kind=real64)              :: rb0, rmax, rk, deltat, tc, tl, tmodel0 !  common/fbcnst/rb0,rmax,rk,deltat,tc,tl,tmodel0,nfbconst !  rk0 = rk !  deltat0 = deltat !  tc0 = tc !  tl0 = tl !  tmodel00 = tmodel0 !end subroutine end module fb","tags":"","url":"sourcefile/fb.f90.html"},{"title":"mapb2s.f90 – Fortran Program","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nModification log\n7/12/21: Source Code program mapb2s use iso_fortran_env , only : real64 , int64 use param , only : PI , N_R , N_THETA , N_PHI , TWOPI , DEG_TO_RAD use mtrx , only : norm2 , trilinear use file_op , only : read_maggrid , write_b1rs use rksolvers , only : rk4 implicit none include 'omp_lib.h' real ( kind = real64 ), parameter :: RSS = 2.5d0 real ( kind = real64 ) :: magfieldgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) real ( kind = real64 ) :: gbgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) ! dummy storage real ( kind = real64 ) :: b1rs ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 2 ) real ( kind = real64 ) :: pol real ( kind = real64 ) :: bmag , bmag0 !real(kind=real64) :: v(3) real ( kind = real64 ) :: t , dt real ( kind = real64 ) :: r0 ( 3 ), r1 ( 3 ), r ( 3 ), b ( 3 ) !real(kind=real64) :: sintheta !real(kind=real64) :: nan(6), nan1 !real(kind=real64) :: dis real ( kind = real64 ) :: dr !real(kind=real64) :: bm integer :: n , i , j , k integer :: chunk !integer           :: id !real(kind=real64) :: ratio integer :: lr , ltheta , lphi real ( kind = real64 ) :: rmin ( 3 ), rmin1 ( 3 ) integer :: map ( 0 : N_R , 0 : N_THETA , 0 : N_PHI ) integer :: n1 !real(kind=real64) :: r_mhd, theta_mhd, phi_mhd t = 0 d0 dr = 0.01d0 dt = 0.005d0 chunk = 1 !  load magnetic field grid call read_maggrid ( magfieldgrid , gbgrid ) b1rs = 0.d0 map = 0 print \"('N_R = ',i0,', N_THETA = ',i0,', N_PHI = ',i0)\" , N_R , N_THETA , N_PHI !$OMP PARALLEL NUM_THREADS(20) DEFAULT(firstprivate) SHARED(chunk,magfieldgrid,b1rs,map) !$OMP DO SCHEDULE(static,chunk) !  trace field lines from surface surface back to 1 Rs do k = 0 , N_R r0 ( 1 ) = 1.00001d0 + k * 0.01d0 do i = 0 , N_THETA r0 ( 2 ) = i * DEG_TO_RAD do j = 0 , N_PHI r0 ( 3 ) = j * DEG_TO_RAD r = r0 b = magfield ( r ) if ( b ( 1 ) > 0 ) then pol = 1.0 else pol = - 1.0 end if n = 0 bmag0 = norm2 ( b ) b1rs ( k , i , j , 2 ) = bmag0 bmag = bmag0 if ( k == 1 . and . i == 1 . and . j == 1 ) write ( * , * ) b rmin ( 1 ) = 10000 0.d0 do while ( r ( 1 ) > 1.000009d0 ) r ( 2 ) = acos ( cos ( r ( 2 ))) r ( 3 ) = atan2 ( sin ( r ( 3 )), cos ( r ( 3 ))) if ( r ( 3 ) < 0 ) r ( 3 ) = r ( 3 ) + TWOPI r1 = r b = magfield ( r ) bmag = norm2 ( b ) !v = -pol*b/bmag !v(2) = v(2)/r1(1) !sintheta = sin(r1(2)) !if (sintheta == 0) sintheta = 1.0d-6 !v(3) = v(3) / (r1(1)*sintheta) dt = dr * 0.1 !r = rk4(r1, v, 3, t, dt, vfunc, pol) r = rk4 ( vfunc , t , r1 , dt , pol ) n = n + 1 if ( r ( 2 ) < 0 ) then r ( 2 ) = - r ( 2 ) r ( 3 ) = r ( 3 ) + pi if ( r ( 3 ) > twopi ) r ( 3 ) = r ( 3 ) - twopi end if if ( r ( 1 ) < rmin ( 1 )) rmin = r if (( r ( 1 ) - rmin ( 1 )) > 2.5 . or . n > 10000 ) then !wrong direction? pol = - pol !try back with opposite polarity n1 = 0 r = r0 rmin1 ( 1 ) = 10000 0.0 do while ( r ( 1 ) > 1.000009d0 ) r ( 2 ) = acos ( cos ( r ( 2 ))) r ( 3 ) = atan2 ( sin ( r ( 3 )), cos ( r ( 3 ))) if ( r ( 3 ) < 0 ) r ( 3 ) = r ( 3 ) + twopi r1 = r b = magfield ( r ) bmag = norm2 ( b ) !v = -pol * b / bmag !v(2) = v(2) / r1(1) !sintheta = sin(r1(2)) !if (sintheta == 0) sintheta = 1.0d-6 !v(3) = v(3) / (r1(1)*sintheta) dt = dr * 0.1 !r = rk4(r1, v, 3, t, dt, vfunc, pol) r = rk4 ( vfunc , t , r1 , dt , pol ) n1 = n1 + 1 if ( r ( 2 ) < 0 ) then r ( 2 ) = - r ( 2 ) r ( 3 ) = r ( 3 ) + pi if ( r ( 3 ) > twopi ) r ( 3 ) = r ( 3 ) - twopi end if if ( r ( 1 ) < rmin1 ( 1 )) rmin1 = r ! double open field or stuck if (( r ( 1 ) - rmin1 ( 1 )) > 2.5 . or . n1 > 10000 ) then if ( rmin ( 1 ) < rmin1 ( 1 )) then pol = - pol r = rmin ! use rmin to remap else pol = pol r = rmin1 end if lr = floor (( r ( 1 ) - 1.0d0 ) / 0.01d0 ) ltheta = floor ( r ( 2 ) / pi * 18 0.d0 ) lphi = floor ( r ( 3 ) / pi * 18 0.d0 ) if ((( lr * ( N_THETA + 1 ) + ltheta ) * ( N_PHI + 1 ) + lphi ) < & (( k * ( N_THETA + 1 ) + i ) * ( N_PHI + 1 ) + j )) then map ( k , i , j ) = ( lr * ( N_THETA + 1 ) + ltheta ) * ( N_PHI + 1 ) + lphi else write ( * , * ) \"New x point at\" , lr , ltheta , lphi map ( k , i , j ) = (( lr - 1 ) * ( N_THETA + 1 ) + ltheta ) * ( N_PHI + 1 ) + lphi end if bmag = 0.0 exit end if end do exit end if end do !nan1 = -3.0 !nan = sqrt(nan1) b1rs ( k , i , j , 1 ) = pol * bmag map ( k , i , j ) = pol * map ( k , i , j ) end do end do end do !$OMP BARRIER !$OMP END PARALLEL call write_b1rs ( b1rs , map ) contains ! velocity function. find dr/dt given r and t (t not really needed) ! v = -sgn(B_r) / |B| (B_r r_hat + B_theta / r theta_hat + B_phi / (r sin theta) phi_hat) function vfunc ( t , r , pol ) result ( v ) real ( kind = real64 ), intent ( in ) :: t , r ( 3 ), pol real ( kind = real64 ) :: v ( 3 ) real ( kind = real64 ) :: b ( 3 ), bmag , sintheta b = magfield ( r ) bmag = norm2 ( b ) if ( bmag == 0 ) then v = 0 return end if v = - pol * b / bmag v ( 2 ) = v ( 2 ) / r ( 1 ) sintheta = sin ( r ( 2 )) if ( sintheta == 0 ) sintheta = 1.0d-6 v ( 3 ) = v ( 3 ) / ( r ( 1 ) * sintheta ) end function ! get \\vec{B} = \\vec{B}(\\vec{r}) function magfield ( rvec ) result ( b ) real ( kind = real64 ), intent ( in ) :: rvec ( 3 ) real ( kind = real64 ) :: b ( 3 ) real ( kind = real64 ) :: r , theta , phi ! input copy real ( kind = real64 ) :: fc ( 2 , 2 , 2 ) real ( kind = real64 ) :: px ( 3 ) integer ( kind = int64 ) :: irr , itheta , iphi ! grid positon integer ( kind = int64 ) :: m ! iteration variable b (:) = 0 r = rvec ( 1 ) theta = rvec ( 2 ) phi = rvec ( 3 ) theta = acos ( cos ( theta )) phi = atan2 ( sin ( phi ), cos ( phi )) if ( phi < 0.0 ) phi = phi + twopi !  find the grid cell irr = floor (( r - 1 ) / ( RSS - 1 ) * N_R ) if ( irr >= N_R ) irr = N_R - 1 itheta = floor ( theta / pi * N_THETA ) if ( itheta >= N_THETA ) itheta = N_THETA - 1 iphi = floor ( phi / twopi * N_PHI ) if ( iphi >= N_PHI ) iphi = N_PHI - 1 if ( irr < 0 ) then ! going into the sun, stop at the surface b = magfieldgrid ( 0 , itheta , iphi , :) return end if !  relative displacement from lower grids px ( 1 ) = ( r - 1.0 ) / ( RSS - 1.0 ) * N_R - irr px ( 2 ) = theta / pi * N_THETA - itheta px ( 3 ) = phi / twopi * N_PHI - iphi !print \"(a,':',i3,': ', ' irr = ', i3, ', itheta = ', i3, ', iphi = ', i3)\", & !  __FILE__, __LINE__, irr, itheta, iphi do m = 1 , 3 fc ( 1 , 1 , 1 ) = magfieldgrid ( irr , itheta , iphi , m ) fc ( 2 , 1 , 1 ) = magfieldgrid ( irr + 1 , itheta , iphi , m ) fc ( 1 , 2 , 1 ) = magfieldgrid ( irr , itheta + 1 , iphi , m ) fc ( 2 , 2 , 1 ) = magfieldgrid ( irr + 1 , itheta + 1 , iphi , m ) fc ( 1 , 1 , 2 ) = magfieldgrid ( irr , itheta , iphi + 1 , m ) fc ( 2 , 1 , 2 ) = magfieldgrid ( irr + 1 , itheta , iphi + 1 , m ) fc ( 1 , 2 , 2 ) = magfieldgrid ( irr , itheta + 1 , iphi + 1 , m ) fc ( 2 , 2 , 2 ) = magfieldgrid ( irr + 1 , itheta + 1 , iphi + 1 , m ) ! interpolate the magnetic field b ( m ) = trilinear ( fc , px ) end do end function ! magfield end program !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!Modification log !!7/12/21: !     corona data interpolated e.g. l246 !     adaptive dt based on dr e.g. l70 !     use b1rs from ir-1 if reconnection occurs at ir e.g. l81 !     Failed tracing overhaul 7/2/21 !     output polarity information in sign of b1rs","tags":"","url":"sourcefile/mapb2s.f90.html"},{"title":"arriv_time.f90 – Fortran Program","text":"Source Code program arriv_time use iso_fortran_env , only : real64 use epv , only : e2v implicit none real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: e , v rnz = 2 rnm = 4 print * , 'e = ?(GeV)' read ( * , * ) e v = e2v ( e ) print * , 'v = ' , v , 'AU/day' print * , 'arriving time=' , 1.0 / v , 'days' end program arriv_time","tags":"","url":"sourcefile/arriv_time.f90.html"},{"title":"param.f90 – Fortran Program","text":"Source Code module param use iso_fortran_env , only : real64 , int64 implicit none ! physical constants real ( kind = real64 ), parameter :: PI = 3.14159265358979323846d0 , TWOPI = 2.d0 * PI real ( kind = real64 ), parameter :: & CSPEED = 2 5.8441774d0 , & ! speed of light in R_sun/min QoMSI = 9.57883376d7 , & ! proton charge-to-mass ratio in coulomb/kg EP = 0.938d0 , & ! proton rest energy in GeV EE = 0.510998918d-3 , & ! electron rest energy in GeV GAMMA_CS = 1.6666666666666666666d0 ! heat capacity ratio ! program parameters integer , parameter :: NSEEDMAX = 2001 , NFMAX = 200 integer ( kind = int64 ), parameter :: NBASE = 40 , NSPMAX = 20 ! for PFSS real ( kind = real64 ), parameter :: RSS = 2.5d0 integer , parameter :: N_R = 150 , N_THETA = 180 , N_PHI = 360 real ( kind = real64 ) :: bgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) !real(kind=real64) :: cvgrid(0:N_R, 0:N_THETA, 0:N_PHI, 3) real ( kind = real64 ) :: gbgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI , 3 ) real ( kind = real64 ) :: b1rsgrid ( 0 : N_R , 0 : N_THETA , 0 : N_PHI ) real ( kind = real64 ), parameter :: epsilon ( 4 ) = [ 0.04 , 0.01 , 0.04 , 0.003 ] ! conversion factors real ( kind = real64 ), parameter :: RAD_TO_DEG = 180 d0 / pi real ( kind = real64 ), parameter :: DEG_TO_RAD = pi / 180 d0 real ( kind = real64 ), parameter :: RS_PER_MIN_TO_KM_PER_SEC = 6.96340d5 / 6 0.0 end module param","tags":"","url":"sourcefile/param.f90.html"},{"title":"sim3d_utils.f90 – Fortran Program","text":"Source Code module sim3d_utils use iso_fortran_env , only : real64 use param , only : PI , TWOPI , GAMMA_CS , NSPMAX , nseedmax , CSPEED , & N_R , N_THETA , N_PHI , bgrid , gbgrid , b1rsgrid use fb , only : fb0 use epv , only : rp2beta use mtrx , only : mrtx , mbtr , trilinear , trilineardif implicit none contains subroutine f0mod ( r , pa , f0 , df0 , ddf0 , df0dmu , ddf0dmu2 ) !  function modification factor for distribution !    f=f0mod*g -- g is the new function to be solve the stochastic real ( kind = real64 ), intent ( in ) :: r ( 3 ), pa real ( kind = real64 ), intent ( out ) :: f0 , df0 ( 3 ), ddf0 ( 3 , 3 ), df0dmu , ddf0dmu2 real ( kind = real64 ) :: rs ( 3 ), sintheta , costheta , sinphi , cosphi real ( kind = real64 ) :: sp , sp0 , gp , ap , trgtfs ( 4 ), scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real ( kind = real64 ) :: dcddt , dcddp , ddcddtt , ddcddtp , ddcddpp real ( kind = real64 ) :: daddt , daddp , ddaddtt , ddaddtp , ddaddpp real ( kind = real64 ) :: ad , cd , sd , sdp rs ( 1 ) = rb0 rs ( 2 ) = r ( 2 ) rs ( 3 ) = r ( 3 ) + ( r ( 1 ) - rs ( 1 )) / vom sintheta = sin ( rs ( 2 )) if ( sintheta == 0 ) sintheta = 1e-27 costheta = cos ( rs ( 2 )) sinphi = sin ( rs ( 3 )) cosphi = cos ( rs ( 3 )) cd = costheta * trgtfs ( 2 ) + sintheta * trgtfs ( 1 ) * ( cosphi * trgtfs ( 4 ) + sinphi * trgtfs ( 3 )) dcddt = - sintheta * trgtfs ( 2 ) + costheta * trgtfs ( 1 ) * ( cosphi * trgtfs ( 4 ) + sinphi * trgtfs ( 3 )) dcddp = - sintheta * trgtfs ( 1 ) * ( sinphi * trgtfs ( 4 ) - cosphi * trgtfs ( 3 )) ddcddtt = - cd ddcddtp = - costheta * trgtfs ( 1 ) * ( sinphi * trgtfs ( 4 ) - cosphi * trgtfs ( 3 )) ddcddpp = - sintheta * trgtfs ( 1 ) * ( cosphi * trgtfs ( 4 ) + sinphi * trgtfs ( 3 )) ad = acos ( cd ) sd = sin ( ad ) daddt = - 1 / sd * dcddt daddp = - 1 / sd * dcddp ddaddtt = - cd / sd * daddt * daddt - 1 / sd * ddcddtt ddaddtp = - cd / sd * daddp * daddt - 1 / sd * ddcddtp ddaddpp = - cd / sd * daddp * daddp - 1 / sd * ddcddpp !f0 = (1+pa/sp) * exp(-ad*ad/ap/ap/2) f0 = log ( 1 + pa / sp ) - ad * ad / ap / ap / 2 !used as exp(f0) ! \\frac{df_0}{d\\mu} df0dmu = 1 / ( sp + pa ) !normalized by f0 ! \\frac{d&#94;2 f_0}{d\\mu&#94;2} ddf0dmu2 = 0 !gp * (gp-1) / (sp + pa)**2 !  df0(1-3) = derivative in sphere coordinates /f0 !    first order if ( sd == 0 ) then df0 ( 2 ) = 0.0 df0 ( 3 ) = 0.0 else df0 ( 2 ) = - ad / ap / ap * daddt df0 ( 3 ) = - ad / ap / ap * daddp end if df0 ( 1 ) = df0 ( 3 ) / vom !    second order if ( sd == 0 ) then if ( ad == 0 ) then ddf0 ( 2 , 2 ) = df0 ( 2 ) * df0 ( 2 ) - 1 / ap / ap ddf0 ( 2 , 3 ) = df0 ( 2 ) * df0 ( 3 ) + 0 ddf0 ( 3 , 3 ) = df0 ( 3 ) * df0 ( 3 ) else sdp = 1e-10 ddf0 ( 2 , 2 ) = df0 ( 2 ) * df0 ( 2 ) + PI / ap / ap / sdp ddf0 ( 2 , 3 ) = df0 ( 2 ) * df0 ( 3 ) + 0 ddf0 ( 3 , 3 ) = df0 ( 3 ) * df0 ( 3 ) + PI / ap / ap / sdp * trgtfs ( 1 ) ** 2 end if else !ddsd = (sd-ad*cd)/sd/sd/ap/ap !ddf0(2,2) = df0(2)*df0(2) - ad*cd/ap/ap/sd + ddsd*dcddt*dcddt !ddf0(2,3) = df0(2)*df0(3) + ad/ap/ap/sd*ddcddtp + ddsd*dcddt*dcddp !ddf0(3,3) = df0(3)*df0(3) + ad/ap/ap/sd*ddcddpp + ddsd*dcddp*dcddp ddf0 ( 2 , 2 ) = - ad / ap / ap * ddaddtt + df0 ( 2 ) * df0 ( 2 ) * ( 1 - ap * ap / ad / ad ) ddf0 ( 2 , 3 ) = - ad / ap / ap * ddaddtp + df0 ( 2 ) * df0 ( 3 ) * ( 1 - ap * ap / ad / ad ) ddf0 ( 3 , 3 ) = - ad / ap / ap * ddaddpp + df0 ( 3 ) * df0 ( 3 ) * ( 1 - ap * ap / ad / ad ) end if !ddf0(1,1) = ddf0(3,3)/vom**2 ddf0 ( 1 , 1 ) = - ( ad * ddaddpp + daddp * daddp ) / ap / ap / vom / vom + df0 ( 1 ) ** 2 !ddf0(1,2) = ddf0(2,3)/vom ddf0 ( 1 , 2 ) = - ( ad * ddaddtp + daddt * daddp ) / ap / ap / vom + df0 ( 1 ) * df0 ( 2 ) !ddf0(1,3) = ddf0(3,3)/vom ddf0 ( 1 , 3 ) = - ( ad * ddaddpp + daddp * daddp ) / ap / ap / vom + df0 ( 1 ) * df0 ( 3 ) !   gradient-f0 /f0 in spherical df0 ( 2 ) = df0 ( 2 ) / r ( 1 ) df0 ( 3 ) = df0 ( 3 ) / ( r ( 1 ) * sintheta ) !   grdaient-gradient-f0 /f0 ddf0 ( 2 , 1 ) = ddf0 ( 1 , 2 ) / r ( 1 ) - df0 ( 2 ) / r ( 1 ) / r ( 1 ) ddf0 ( 3 , 1 ) = ( ddf0 ( 1 , 3 ) - df0 ( 3 ) / r ( 1 )) / r ( 1 ) / sintheta ddf0 ( 2 , 2 ) = ( ddf0 ( 2 , 2 ) / r ( 1 ) + df0 ( 1 )) / r ( 1 ) ddf0 ( 3 , 2 ) = ( ddf0 ( 2 , 3 ) - costheta / sintheta * df0 ( 3 )) / r ( 1 ) / r ( 1 ) / sintheta ddf0 ( 3 , 3 ) = ( ddf0 ( 3 , 3 ) / r ( 1 ) / sintheta + df0 ( 1 ) * sintheta + & df0 ( 2 ) / r ( 1 ) * costheta ) / r ( 1 ) / sintheta ddf0 ( 1 , 2 ) = ddf0 ( 2 , 1 ) ddf0 ( 1 , 3 ) = ddf0 ( 3 , 1 ) ddf0 ( 2 , 3 ) = ddf0 ( 3 , 2 ) end subroutine real ( kind = real64 ) function solarwindtemp ( r ) result ( temp ) real ( kind = real64 ), intent ( in ) :: r ( 3 ) !  empirical model in the corona from Withbroe (ApJ 325,442,1988) 10.1086/166015 if ( r ( 1 ) > 1 0.0 ) temp = 1.4d6 * ( 10 / r ( 1 )) ** 1.3333 if ( r ( 1 ) <= 1 0.0 . and . r ( 1 ) >= 1.125 ) temp = 1.4d6 if ( r ( 1 ) < 1.125 ) then temp = ( 1.0d5 ** 3.5 + 2 5.33965d6 * ( 1 / 1.0287 - 1 / r ( 1 ))) ** ( 1 / 3.5 ) end if end function !   use bisection to search for root of shock adiabatic equation !   calculate shock compression ratio of oblique MHD shock function compress ( amach , smach , ob ) result ( rsh ) real ( kind = real64 ), intent ( in ) :: amach , smach , ob real ( kind = real64 ) :: rsh ( 3 ) !real(kind=real64)             :: xr, y1, y2, xmin, xmax, froot real ( kind = real64 ) :: rsh0 real ( kind = real64 ) :: sintheta2 !, costheta2, tbn real ( kind = real64 ) :: pbeta real ( kind = real64 ) :: a0 , a1 , a2 , a3 , b0 , b1 , del complex ( kind = real64 ) :: wth , pr3 , root ( 3 ) real ( kind = real64 ) :: amach2 , amach4 , amach6 integer :: k pbeta = ( amach / smach ) ** 2 sintheta2 = sin ( ob ) ** 2 amach2 = amach * amach amach4 = amach2 * amach2 amach6 = amach4 * amach2 a3 = - 2 * pbeta + pbeta * sintheta2 * 4 - pbeta * sintheta2 * sintheta2 * 2 - amach2 * sintheta2 & - amach2 * GAMMA_CS + amach2 + amach2 * GAMMA_CS * sintheta2 a2 = - amach2 * (& - GAMMA_CS - pbeta * 4 + GAMMA_CS * sintheta2 + pbeta * sintheta2 * 4 + sintheta2 & - amach2 * GAMMA_CS * 2 + amach2 * 2 + amach2 * GAMMA_CS * sintheta2 - 1 ) a1 = - amach4 * (& GAMMA_CS * 2 + pbeta * 2 - GAMMA_CS * sintheta2 - sintheta2 * 2 + amach2 * GAMMA_CS - amach2 + 2 ) a0 = amach6 * GAMMA_CS + amach6 rsh0 = - a2 / ( 3 * a3 ) b1 = ( 3 * a3 * a1 - a2 * a2 ) / ( 3 * a3 * a3 ) b0 = ( 2 * a2 * a2 * a2 - 9 * a3 * a2 * a1 + 27 * a3 * a3 * a0 ) / ( 27 * a3 * a3 * a3 ) del = 4 * b1 * b1 * b1 + 27 * b0 * b0 if ( del < 0 ) then pr3 = ( - b1 / 3 ) ** 0.5 wth = 3 * b0 / ( 2 * b1 ) * ( - 3 / b1 ) ** 0.5 wth = acos ( wth ) / 3 do k = 0 , 2 root ( k + 1 ) = 2 * pr3 * cos ( wth - 2 * PI * k / 3 ) + rsh0 if ( abs ( aimag ( root ( k + 1 ))) < 1.0d-10 ) then rsh ( k + 1 ) = real ( root ( k + 1 )) else rsh ( k + 1 ) = 1 end if end do else if ( b1 < 0 ) then wth = - 3 * abs ( b0 ) / ( 2 * b1 ) * ( - 3 / b1 ) ** 0.5 wth = acosh ( wth ) / 3 !wth = log(wth + sqrt(wth + 1) * sqrt(wth - 1)) / 3 ! this is acosh root ( 1 ) = - 2 * abs ( b0 ) / b0 * ( - b1 / 3 ) ** 0.5 * cosh ( wth ) + rsh0 else wth = 3 * b0 / ( 2 * b1 ) * ( 3 / b1 ) ** 0.5 wth = asinh ( wth ) / 3 !wth = log(wth + sqrt(wth * wth + 1)) / 3 ! this is asinh root ( 1 ) = - 2 * ( b1 / 3 ) ** 0.5 * sinh ( wth ) + rsh0 end if root ( 2 ) = 1 root ( 3 ) = 1 rsh (:) = real ( root (:)) end if end function recursive subroutine split (& iseed , rpb , ck , fs , t , nsplvl , dnsk , bv0 , flx , dflx , walk3d , nsts ) integer , intent ( in ) :: iseed real ( kind = real64 ), intent ( in ) :: rpb ( 5 ) real ( kind = real64 ), intent ( in out ) :: ck , fs real ( kind = real64 ), intent ( in ) :: t integer , intent ( in out ) :: nsplvl real ( kind = real64 ), intent ( in out ) :: dnsk , bv0 ( 3 ), flx , dflx external :: walk3d integer , intent ( in ) :: nsts integer :: nodr ( NSPMAX ) real ( kind = real64 ) :: t0sv ( 2 ** ( NSPMAX + 1 )), cksv ( 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: rpbsv ( 5 , 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: fssv ( 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: dnsksv ( 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: bv0sv ( 3 , 2 ** ( NSPMAX + 1 )) common / svsp / nodr , t0sv , cksv , rpbsv , fssv , dnsksv , bv0sv real ( kind = real64 ) :: rps0 ( 5 ) !real(kind=real64) :: rp0org(5) real ( kind = real64 ) :: rb ( 3 ) real ( kind = real64 ) :: fb_ , f1 real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: rb0 , rmax common / rb0max / rb0 , rmax integer :: nlambdaconst common / nlambdaconst / nlambdaconst real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip !common /param5/p1,beta1,pa1,pol1 integer :: ndpdt common / ndpdt / ndpdt !real(kind=real64) :: trgtf(4) real ( kind = real64 ) :: sp , sp0 , gp , ap real ( kind = real64 ) :: trgtfs ( 4 ) real ( kind = real64 ) :: scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) real ( kind = real64 ) :: t0 , tsp , hb , df0dmu , ddf0dmu2 , pab , rate , tb integer :: nsv , i , ns character ( len =* ), parameter :: writefmt = \"(i1,i3,8(1pe13.5),i3)\" nsplvl = nsplvl + 1 !  save data for splitting nsv = 2 ** nsplvl - 2 ! nsv = 0 ! do i = 1, nsplvl-1 !   nsv = nsv + 2**i ! end do do i = 1 , nsplvl - 1 nsv = nsv + 2 * 2 ** i * nodr ( i ) end do t0sv ( nsv + 1 ) = t cksv ( nsv + 1 ) = ck fssv ( nsv + 1 ) = fs rpbsv (:, nsv + 1 ) = rpb (:) dnsksv ( nsv + 1 ) = dnsk bv0sv (:, nsv + 1 ) = bv0 (:) t0sv ( nsv + 2 ) = t cksv ( nsv + 2 ) = ck fssv ( nsv + 2 ) = fs rpbsv (:, nsv + 2 ) = rpb (:) dnsksv ( nsv + 2 ) = dnsk bv0sv (:, nsv + 2 ) = bv0 (:) do i = 1 , 2 nodr ( nsplvl ) = i - 1 t0 = t0sv ( nsv + i ) ck = cksv ( nsv + i ) fs = fssv ( nsv + i ) rps0 ( 1 : 5 ) = rpbsv ( 1 : 5 , nsv + i ) dnsk = dnsksv ( nsv + i ) bv0 ( 1 : 3 ) = bv0sv ( 1 : 3 , nsv + i ) tsp = ( nsplvl + 1 ) * tdl if ( tsp > te ) tsp = te call walk3d ( iseed , rps0 , rpb , ck , fs , t0 , t , tsp , ns , dnsk , bv0 , nsplvl ) if ( ns == - 1 . and . tsp < te ) then call split ( iseed , rpb , ck , fs , t , nsplvl , dnsk , bv0 , flx , dflx , walk3d , nsts ) else rb ( 1 : 3 ) = rpb ( 1 : 3 ) pab = rpb ( 5 ) call f0mod ( rb , pab , hb , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hb + h0 ) if ( ns >= 0 ) ns = 1 fb_ = fb0 ( tb , rpb ) * rate f1 = ( fs + fb_ ) / 2 ** nsplvl !if (fs > 0.) write(nsts,writefmt) 0,nsplvl,fs if ( fs > 1.d-30 ) write ( nsts , writefmt ) 0 , nsplvl , fs !if (fb_ > 0.) write(nsts,writefmt) 2,nsplvl,fb_,t0org-t,rate,rpb,ns !call flush(nsts) flush ( nsts ) !OMP CRITICAL sum flx = flx + f1 dflx = dflx + f1 * f1 !OMP END CRITICAL sum end if end do nsplvl = nsplvl - 1 end subroutine subroutine vfunc ( t , xpk , dxpkdt , du , gxw2 , gxw3 , bv0 , densw , vpl , gper , b1s ) real ( kind = real64 ), intent ( in ) :: t , xpk ( 6 ) real ( kind = real64 ), intent ( out ) :: dxpkdt ( 6 ) real ( kind = real64 ) :: du real ( kind = real64 ), intent ( out ) :: gxw2 ( 3 ), gxw3 ( 3 ) real ( kind = real64 ) :: densw real ( kind = real64 ), intent ( out ) :: bv0 ( 3 ) real ( kind = real64 ) :: vpl ( 3 ) real ( kind = real64 ), intent ( out ) :: gper real ( kind = real64 ) :: b1s real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: r ( 3 ), b2r ( 3 , 3 ), r2x ( 3 , 3 ), b2x ( 3 , 3 ) real ( kind = real64 ) :: bv ( 3 ), vd ( 3 ) real ( kind = real64 ) :: avr ( 3 ), avx ( 3 ) real ( kind = real64 ) :: cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), pol , gb1s ( 3 ) real ( kind = real64 ) :: culper ( 3 ), culpar ( 3 ) real ( kind = real64 ) :: uax1 ( 3 ), uax2 ( 3 ), uax3 ( 3 ) real ( kind = real64 ) :: gb ( 3 ), gr ( 3 , 3 ), dgr ( 3 ), dgx ( 3 ) real ( kind = real64 ) :: gvpl ( 3 , 3 ) real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) real ( kind = real64 ), parameter :: rg1 = 4.79259e-5 real ( kind = real64 ) :: trgtfs ( 4 ) real ( kind = real64 ) :: sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 real ( kind = real64 ) :: vx ( 3 ) integer :: lpb , lpb2 real ( kind = real64 ) :: p , pa real ( kind = real64 ) :: beta , sinmu , cosp real ( kind = real64 ) :: sintheta , costheta , sinphi , cosphi real ( kind = real64 ) :: adpadt , bm , um , rgmu2 , bbgv , dcs , f0 , dbbds real ( kind = real64 ) :: ddu , divv , dpadt , fk , vpcl , df0dmu , ddf0dmu2 integer :: ndmumu common / ndmumu / ndmumu integer :: i , j r ( 1 ) = norm2 ( xpk ( 1 : 3 )) r ( 2 ) = acos ( xpk ( 3 ) / r ( 1 )) r ( 3 ) = atan2 ( xpk ( 2 ), xpk ( 1 )) p = xpk ( 4 ) beta = rp2beta ( p ) pa = xpk ( 5 ) sintheta = sin ( r ( 2 )) if ( sintheta == 0 ) sintheta = 1e-27 costheta = cos ( r ( 2 )) sinphi = sin ( r ( 3 )) cosphi = cos ( r ( 3 )) call drvbmag ( r , bv , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) bv0 = bv lpb = pol !  local coordinates !   unit outward field line direction: uax1 uax1 = lpb * bv / bm !   unit perdicular directions uax2 ( 1 : 3 ) = [ 0 d0 , - lpb * bv ( 3 ), lpb * bv ( 2 )] um = hypot ( uax2 ( 2 ), uax2 ( 3 )) if ( um == 0 ) then uax2 ( 2 ) = 1 uax2 ( 3 ) = 0 else uax2 ( 2 ) = uax2 ( 2 ) / um uax2 ( 3 ) = uax2 ( 3 ) / um end if ! take cross product and normalize uax3 ( 1 ) = uax1 ( 2 ) * uax2 ( 3 ) - uax1 ( 3 ) * uax2 ( 2 ) uax3 ( 2 ) = uax1 ( 3 ) * uax2 ( 1 ) - uax1 ( 1 ) * uax2 ( 3 ) uax3 ( 3 ) = uax1 ( 1 ) * uax2 ( 2 ) - uax1 ( 2 ) * uax2 ( 1 ) uax3 = uax3 / norm2 ( uax3 ( 1 : 3 )) !   focusing along outward field line dbbds = lpb * dbbds !  calculate matrix from polar spheric to xyz coordinates r2x = mrtx ( sintheta , costheta , sinphi , cosphi ) !  calculate matrix from magnetic to polar spheric coordinates b2r = mbtr ( uax1 , uax2 , uax3 ) !  calculate matrix from magnetic to xyz coordinates b2x = matmul ( r2x , b2r ) !  diffusion tensor in magnetic coordinates call cofm ( r , p , pa , beta , bv , bm , cvtu , gbmag , dbbds , b1s , gb1s , gb , dgr ) !  calculate diffusion coeficients !     in polar spheric coordinates gper = gb ( 2 ) !gb(2)=gb(3) do i = 1 , 3 do j = 1 , 3 gr ( i , j ) = sum ( b2r ( i ,:) * gb (:) * b2r ( j ,:)) end do end do !   1. parallel particle speed + solar wind speed vpcl = beta * CSPEED !   2. drift velocity in spherical coordinates dcs = 1.0d0 / norm2 ( bxgb2 ) sinmu = 1 - pa * pa if ( sinmu < 0 ) then sinmu = 0 else sinmu = sqrt ( sinmu ) end if rgmu2 = rg1 * p / bm * sinmu * 1.414 !sqrt(2),linear; 2,step if ( dcs > rgmu2 ) then !regular drift culpar = dot_product ( bv ( 1 : 3 ), cvtu ( 1 : 3 )) / bm / bm * bv culper = cvtu - culpar vd = rg1 * p * vpcl / bm * ( pa * pa * culper / bm & + ( 1 - pa * pa ) / 2 / bm * culpar + ( 1 + pa * pa ) / 2 * bxgb2 ) else ! current sheet drift (square delta function) vd = - vpcl * sinmu / 2.828 * bxgb2 * dcs end if if ( rnz < 0 ) vd = - vd !   3. solar wind speed call solarwind ( r , vpl , gvpl , densw ) !   4 artificial drift call f0mod ( r , pa , f0 , df0 , ddf0 , df0dmu , ddf0dmu2 ) avr ( 1 : 3 ) = 2 * matmul ( gr , df0 ) avx ( 1 : 3 ) = matmul ( r2x , avr ) !   total do i = 1 , 3 vx ( i ) = dot_product ( r2x ( i , 1 : 3 ), vpl ) dxpkdt ( i ) = - b2x ( i , 1 ) * vpcl * pa - vx ( i ) - dot_product ( r2x ( i , 1 : 3 ), vd ) !  add dg and artifical drift dxpkdt ( i ) = dxpkdt ( i ) + avx ( i ) + dot_product ( r2x ( i , 1 : 3 ), dgr ) end do !  get pitch angle diffusion coefficient call cofdu ( p , pa , beta , bm , du , ddu , ndmumu ) if ( r ( 1 ) > 2 0.0 ) then cosp = bv ( 1 ) / bm du = du * cosp * cosp / facip ddu = ddu * cosp * cosp / facip end if !   pitch angle drift term !   focusing dpadt = - vpcl * dbbds * ( 1 - pa * pa ) / 2.0 !   cooling bbgv = 0.0 do i = 1 , 3 do j = 1 , 3 bbgv = bv ( i ) / bm * gvpl ( i , j ) * bv ( j ) / bm + bbgv end do end do divv = gvpl ( 1 , 1 ) + gvpl ( 2 , 2 ) + gvpl ( 3 , 3 ) !divv1 = 2*vpl(1)/r(1) + gvpl(1,1)  ! for test dpadt = dpadt + pa * ( 1 - pa * pa ) / 2 * ( divv - 3 * bbgv ) !   derivative of pitch-angle diffusion !   artificial due to modification of function adpadt = 2.0 * du * df0dmu dxpkdt ( 5 ) = - dpadt + ddu + adpadt !   momentum loss dxpkdt ( 4 ) = (( 1 - pa * pa ) / 2 * ( divv - bbgv ) + pa * pa * bbgv ) * p !   killing factor fk = ( - dpadt + ddu ) * df0dmu + du * ddf0dmu2 ! increment fk by trace(matmul(gr,  ddf0)) fk = fk + ( & gr ( 1 , 1 ) * ddf0 ( 1 , 1 ) + gr ( 1 , 2 ) * ddf0 ( 2 , 1 ) + gr ( 1 , 3 ) * ddf0 ( 3 , 1 ) + & gr ( 2 , 1 ) * ddf0 ( 1 , 2 ) + gr ( 2 , 2 ) * ddf0 ( 2 , 2 ) + gr ( 2 , 3 ) * ddf0 ( 3 , 2 ) + & gr ( 3 , 1 ) * ddf0 ( 1 , 3 ) + gr ( 3 , 2 ) * ddf0 ( 2 , 3 ) + gr ( 3 , 3 ) * ddf0 ( 3 , 3 ) ) fk = fk + dot_product ( dgr , df0 ) & - dot_product ( vd , df0 ) & - dot_product ( vpl , df0 ) dxpkdt ( 6 ) = fk !  diffusion vector applied to dw2 and dw3 gxw2 (:) = b2x ( 1 : 3 , 2 ) * sqrt ( 2 * gb ( 2 )) gxw3 (:) = b2x ( 1 : 3 , 3 ) * sqrt ( 2 * gb ( 3 )) !write(54,\"(f14.7,13(1pe14.5))\") t, xpk, dxpkdt,bm !call flush(54) end subroutine subroutine solarwind ( r , vpl , gvpl , densw ) !   calculate solar wind velocity in the corotating frame !     and its gradient !     in spherical coordinate system real ( kind = real64 ), intent ( in ) :: r ( 3 ) real ( kind = real64 ), intent ( out ) :: vpl ( 3 ), gvpl ( 3 , 3 ), densw !     use leBalnc(1998) model real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 real ( kind = real64 ) :: omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: sintheta , sinthetap , costheta , rpl sintheta = sin ( r ( 2 )) if ( sintheta == 0 ) then sinthetap = 1e-20 else sinthetap = sintheta end if costheta = cos ( r ( 2 )) rpl = 1 + k4ok2 / r ( 1 ) ** 2 + k6ok2 / r ( 1 ) ** 4 if ( r ( 1 ) < 2.5 ) then vpl = 0.0 gvpl = 0.0 else vpl ( 1 ) = vsw / rpl vpl ( 2 ) = 0 vpl ( 3 ) = - omega * ( r ( 1 ) - 2.5 ) * sintheta !rss=2.5Rs for pfss gvpl ( 1 , 1 ) = vpl ( 1 ) * ( 2 * k4ok2 / r ( 1 ) ** 3 + 4 * k6ok2 / r ( 1 ) ** 5 ) / & ( 1 + k4ok2 / r ( 1 ) ** 2 + k6ok2 / r ( 1 ) ** 4 ) gvpl ( 1 , 2 ) = 0.d0 gvpl ( 1 , 3 ) = - omega * sintheta gvpl ( 2 , 1 ) = 0.0 gvpl ( 2 , 2 ) = vpl ( 1 ) / r ( 1 ) gvpl ( 2 , 3 ) = - omega * ( r ( 1 ) - 2.5 ) * costheta / r ( 1 ) gvpl ( 3 , 1 ) = - vpl ( 3 ) / r ( 1 ) gvpl ( 3 , 2 ) = - costheta / sinthetap * vpl ( 3 ) / r ( 1 ) gvpl ( 3 , 3 ) = vpl ( 1 ) / r ( 1 ) end if densw = densw0 * rpl / r ( 1 ) ** 2 end subroutine function solarwind1 ( r ) result ( vpl ) !   calculate solar wind velocity in the corotating frame !     and its gradient in sphereical coordinate system real ( kind = real64 ), intent ( in ) :: r ( 3 ) real ( kind = real64 ) :: vpl ( 3 ) !     use leBalnc(1998) model real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 real ( kind = real64 ) :: omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip if ( r ( 1 ) < 2.5 ) then vpl = 0.0 else vpl ( 1 ) = vsw / ( 1 + k4ok2 / r ( 1 ) ** 2 + k6ok2 / r ( 1 ) ** 4 ) vpl ( 2 ) = 0.d0 vpl ( 3 ) = - omega * ( r ( 1 ) - 2.5 ) * sin ( r ( 2 )) !rss=2.5Rs for pfss end if end function subroutine drvbmag ( r1 , b , bmag , cvtu , gbmag , bxgb2 , dbbds , pol , b1rs , gb1rs ) real ( kind = real64 ), intent ( in ) :: r1 ( 3 ) real ( kind = real64 ), intent ( out ) :: b ( 3 ), bmag , cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), dbbds , pol !  cvtu is now curl B real ( kind = real64 ), intent ( out ) :: b1rs , gb1rs ( 3 ) real ( kind = real64 ), parameter :: rss = 2.5d0 real ( kind = real64 ) :: r ( 3 ) real ( kind = real64 ) :: phic ( 2 , 2 , 2 ), px ( 3 ), phi real ( kind = real64 ) :: df ( 3 ) !real(kind=real64)  :: b1rsgrid(0:N_R, 0:N_THETA, 0:N_PHI) integer :: irr , itheta , iphi , m integer :: i1 , i2 , i3 real ( kind = real64 ) :: bx , by , bz , gbx , gby , gbz , bm real ( kind = real64 ) :: vr , vt , tpsw real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: rsovr , plbs , tanp , oneptan2 , sroneptan2 real ( kind = real64 ) :: vpl ( 3 ), dvr1 , dvf1 , dvf2 real ( kind = real64 ) :: gbmags ( 3 ), bxgb2s ( 3 ) real ( kind = real64 ) :: bplus ( 3 ), bminus ( 3 ) integer :: nplus , nminus integer :: m1 , m2 , m3 real ( kind = real64 ) :: sintheta , costheta r = r1 if ( r ( 1 ) > rss ) then tpsw = (( r ( 1 ) - k4ok2 / r ( 1 ) - k6ok2 / r ( 1 ) ** 3 / 3 ) & - ( rss - k4ok2 / rss - k6ok2 / rss ** 3 / 3 ) ) / vsw else tpsw = 0.0 end if r ( 2 ) = acos ( cos ( r ( 2 ))) r ( 3 ) = r ( 3 ) + omega * tpsw r ( 3 ) = atan2 ( sin ( r ( 3 )), cos ( r ( 3 ))) if ( r ( 3 ) < 0.0 ) r ( 3 ) = r ( 3 ) + 2 * pi if ( r ( 1 ) > rss ) r ( 1 ) = rss if ( r ( 1 ) < 1.0 ) r ( 1 ) = 1.0 sintheta = sin ( r ( 2 )) if ( sintheta == 0.0 ) sintheta = 1e-20 !  find the grid cell irr = floor (( r ( 1 ) - 1 ) / ( rss - 1 ) * N_R ) if ( irr >= N_R ) irr = N_R - 1 itheta = floor ( r ( 2 ) / pi * N_THETA ) if ( itheta >= N_THETA ) itheta = N_THETA - 1 iphi = floor ( r ( 3 ) / pi / 2 * N_PHI ) if ( iphi >= N_PHI ) iphi = N_PHI - 1 !  relative displacement from lower grids px ( 1 ) = ( r ( 1 ) - 1.0 ) / ( rss - 1.0 ) * N_R - irr px ( 2 ) = r ( 2 ) / pi * N_THETA - itheta px ( 3 ) = r ( 3 ) / TWOPI * N_PHI - iphi do m = 1 , 3 phic ( 1 , 1 , 1 ) = bgrid ( irr , itheta , iphi , m ) phic ( 2 , 1 , 1 ) = bgrid ( irr + 1 , itheta , iphi , m ) phic ( 1 , 2 , 1 ) = bgrid ( irr , itheta + 1 , iphi , m ) phic ( 2 , 2 , 1 ) = bgrid ( irr + 1 , itheta + 1 , iphi , m ) phic ( 1 , 1 , 2 ) = bgrid ( irr , itheta , iphi + 1 , m ) phic ( 2 , 1 , 2 ) = bgrid ( irr + 1 , itheta , iphi + 1 , m ) phic ( 1 , 2 , 2 ) = bgrid ( irr , itheta + 1 , iphi + 1 , m ) phic ( 2 , 2 , 2 ) = bgrid ( irr + 1 , itheta + 1 , iphi + 1 , m ) phi = trilinear ( phic , px ) b ( m ) = phi ! phic(1,1,1) = cvgrid(irr,     itheta,     iphi,     m) ! phic(2,1,1) = cvgrid(irr + 1, itheta,     iphi,     m) ! phic(1,2,1) = cvgrid(irr,     itheta + 1, iphi,     m) ! phic(2,2,1) = cvgrid(irr + 1, itheta + 1, iphi,     m) ! phic(1,1,2) = cvgrid(irr,     itheta,     iphi + 1, m) ! phic(2,1,2) = cvgrid(irr + 1, itheta,     iphi + 1, m) ! phic(1,2,2) = cvgrid(irr,     itheta + 1, iphi + 1, m) ! phic(2,2,2) = cvgrid(irr + 1, itheta + 1, iphi + 1, m) ! phi = trilinear(phic, px) ! cvtu(m) = phi phic ( 1 , 1 , 1 ) = gbgrid ( irr , itheta , iphi , m ) phic ( 2 , 1 , 1 ) = gbgrid ( irr + 1 , itheta , iphi , m ) phic ( 1 , 2 , 1 ) = gbgrid ( irr , itheta + 1 , iphi , m ) phic ( 2 , 2 , 1 ) = gbgrid ( irr + 1 , itheta + 1 , iphi , m ) phic ( 1 , 1 , 2 ) = gbgrid ( irr , itheta , iphi + 1 , m ) phic ( 2 , 1 , 2 ) = gbgrid ( irr + 1 , itheta , iphi + 1 , m ) phic ( 1 , 2 , 2 ) = gbgrid ( irr , itheta + 1 , iphi + 1 , m ) phic ( 2 , 2 , 2 ) = gbgrid ( irr + 1 , itheta + 1 , iphi + 1 , m ) phi = trilinear ( phic , px ) gbmag ( m ) = phi end do do i1 = 0 , 1 do i2 = 0 , 1 do i3 = 0 , 1 bx = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) by = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) bz = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) bm = sqrt ( bx * bx + by * by + bz * bz ) gbx = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) gby = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) gbz = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) phic ( i1 + 1 , i2 + 1 , i3 + 1 ) = ( by * gbz - bz * gby ) / bm / bm end do end do end do phi = trilinear ( phic , px ) bxgb2 ( 1 ) = phi do i1 = 0 , 1 do i2 = 0 , 1 do i3 = 0 , 1 bx = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) by = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) bz = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) bm = sqrt ( bx * bx + by * by + bz * bz ) gbx = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) gby = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) gbz = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) phic ( i1 + 1 , i2 + 1 , i3 + 1 ) = ( bz * gbx - bx * gbz ) / bm / bm end do end do end do phi = trilinear ( phic , px ) bxgb2 ( 2 ) = phi do i1 = 0 , 1 do i2 = 0 , 1 do i3 = 0 , 1 bx = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) by = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) bz = bgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) bm = sqrt ( bx * bx + by * by + bz * bz ) gbx = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 1 ) gby = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 2 ) gbz = gbgrid ( irr + i1 , itheta + i2 , iphi + i3 , 3 ) phic ( i1 + 1 , i2 + 1 , i3 + 1 ) = ( bx * gby - by * gbx ) / bm / bm end do end do end do phi = trilinear ( phic , px ) bxgb2 ( 3 ) = phi phic ( 1 , 1 , 1 ) = abs ( b1rsgrid ( irr , itheta , iphi )) phic ( 2 , 1 , 1 ) = abs ( b1rsgrid ( irr + 1 , itheta , iphi )) phic ( 1 , 2 , 1 ) = abs ( b1rsgrid ( irr , itheta + 1 , iphi )) phic ( 2 , 2 , 1 ) = abs ( b1rsgrid ( irr + 1 , itheta + 1 , iphi )) phic ( 1 , 1 , 2 ) = abs ( b1rsgrid ( irr , itheta , iphi + 1 )) phic ( 2 , 1 , 2 ) = abs ( b1rsgrid ( irr + 1 , itheta , iphi + 1 )) phic ( 1 , 2 , 2 ) = abs ( b1rsgrid ( irr , itheta + 1 , iphi + 1 )) phic ( 2 , 2 , 2 ) = abs ( b1rsgrid ( irr + 1 , itheta + 1 , iphi + 1 )) phi = trilinear ( phic , px ) df = trilineardif ( phic , px ) b1rs = phi gb1rs ( 1 ) = df ( 1 ) / (( rss - 1 ) / N_R ) gb1rs ( 2 ) = df ( 2 ) / ( PI / N_THETA ) / r ( 1 ) gb1rs ( 3 ) = df ( 3 ) / ( TWOPI / N_PHI ) / r ( 1 ) / sintheta nplus = 0 nminus = 0 bplus = 0.0 bminus = 0.0 do m3 = 0 , 1 do m2 = 0 , 1 do m1 = 0 , 1 if ( b1rsgrid ( irr + m1 , itheta + m2 , iphi + m3 ) > 0 ) then nplus = nplus + 1 bplus ( 1 ) = bplus ( 1 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 1 ) bplus ( 2 ) = bplus ( 2 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 2 ) bplus ( 3 ) = bplus ( 3 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 3 ) else nminus = nminus + 1 bminus ( 1 ) = bminus ( 1 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 1 ) bminus ( 2 ) = bminus ( 2 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 2 ) bminus ( 3 ) = bminus ( 3 ) + bgrid ( irr + m1 , itheta + m2 , iphi + m3 , 3 ) end if end do end do end do if (( nplus > 0 ) . and . ( nminus > 0 )) then bplus = bplus / nplus bminus = bminus / nminus if ( dot_product ( bplus , b ) > dot_product ( bminus , b )) then pol = 1.0 else pol = - 1.0 end if else if ( nplus == 0 ) pol = - 1.0 if ( nminus == 0 ) pol = 1.0 end if bmag = norm2 ( b ( 1 : 3 )) dbbds = dot_product ( b ( 1 : 3 ), gbmag ( 1 : 3 )) / ( bmag * bmag ) cvtu = 0.0 ! potential field if ( r1 ( 1 ) >= rss ) then rsovr = rss / r1 ( 1 ) if ( b ( 1 ) >= 0 ) then plbs = 1 else plbs = - 1 end if b ( 1 ) = b ( 1 ) * rsovr ** 2 vpl = solarwind1 ( r1 ) tanp = vpl ( 3 ) / vpl ( 1 ) oneptan2 = 1 + tanp ** 2 sroneptan2 = sqrt ( oneptan2 ) b ( 3 ) = b ( 1 ) * tanp bmag = norm2 ( b ( 1 : 3 )) dvr1 = vsw * ( 2 * k4ok2 / r1 ( 1 ) ** 3 + 4 * k6ok2 / r1 ( 1 ) ** 5 ) / & ( 1 + k4ok2 / r1 ( 1 ) ** 2 + k6ok2 / r1 ( 1 ) ** 4 ) ** 2 dvr1 = dvr1 / vpl ( 1 ) dvf1 = - omega * sintheta / vpl ( 3 ) dvf2 = - omega * ( r1 ( 1 ) - rss ) * cos ( r1 ( 2 )) / r1 ( 1 ) / vpl ( 3 ) dvf2 = dvf2 / vpl ( 3 ) gbmags = gbmag gbmag ( 1 ) = - 2 * bmag / r1 ( 1 ) + bmag * tanp ** 2 / oneptan2 * ( dvf1 - dvr1 ) gbmag ( 2 ) = gbmags ( 2 ) * rsovr ** 3 * sroneptan2 & + bmag * tanp ** 2 / oneptan2 * dvf2 gbmag ( 3 ) = gbmags ( 3 ) * rsovr ** 3 * sroneptan2 bxgb2s = bxgb2 bxgb2 ( 1 ) = - bxgb2s ( 3 ) * rsovr * tanp / sroneptan2 & - b ( 1 ) * tanp ** 3 / oneptan2 * dvf2 / bmag bxgb2 ( 2 ) = bxgb2 ( 2 ) * rsovr / sroneptan2 & - 2 * b ( 1 ) / r1 ( 1 ) * tanp / bmag & + b ( 1 ) * tanp ** 3 / oneptan2 * ( dvf1 - dvr1 ) / bmag bxgb2 ( 3 ) = bxgb2 ( 3 ) * rsovr / sroneptan2 & + b ( 1 ) * tanp ** 2 / oneptan2 * dvf2 / bmag cvtu ( 1 ) = b ( 3 ) * ( dvf2 + cos ( r1 ( 2 )) / sintheta / r1 ( 1 )) & + tanp * rsovr ** 3 * plbs * gbmags ( 2 ) cvtu ( 2 ) = plbs * gbmags ( 3 ) * rsovr ** 3 & + b ( 3 ) * ( 1 / r1 ( 1 ) - dvf1 + dvr1 ) cvtu ( 3 ) = - plbs * gbmags ( 2 ) * rsovr ** 3 dbbds = dot_product ( b , gbmag ) / bmag / bmag b1rs = b1rs / rsovr ** 2 / sroneptan2 gb1rs ( 1 ) = 2 * b1rs / r1 ( 1 ) - b1rs * tanp ** 2 / oneptan2 * ( dvf1 - dvr1 ) gb1rs ( 2 ) = gb1rs ( 2 ) / rsovr / sroneptan2 - b1rs * tanp ** 2 / oneptan2 * dvf2 gb1rs ( 3 ) = gb1rs ( 3 ) / rsovr / sroneptan2 end if end subroutine ! drvbmag end module","tags":"","url":"sourcefile/sim3d_utils.f90.html"},{"title":"epv.f90 – Fortran Program","text":"Source Code module epv use param , only : EP , EE , cspeed use iso_fortran_env , only : real64 implicit none ! Quantities: ! beta - speed in units of c (speed of light) ! gamma - lorentz factor ! v - velocity ! rp - ??? some sort of mass quantity (in GeV/c&#94;2?) ! e - ! ! rnm - ??? ! rnz - ??? contains real ( kind = real64 ) function e2p ( e ) real ( kind = real64 ), intent ( in ) :: e real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm if ( rnm > 0.5 ) then e2p = dsqrt ( 2.0 * EP * e + e * e ) * rnm / rnz else e2p = dsqrt ( 2.0 * EE * e + e * e ) end if end function real ( kind = real64 ) function rp2e ( rp ) real ( kind = real64 ), intent ( in ) :: rp real ( kind = real64 ) :: rnz , rnm , rp1 common / specie / rnz , rnm if ( rnm > . 5 ) then rp1 = rp * rnz / rnm rp2e = hypot ( EP , rp1 ) - EP else rp1 = rp rp2e = hypot ( EE , rp1 ) - EE end if end function real ( kind = real64 ) function rp2beta ( rp ) real ( kind = real64 ), intent ( in ) :: rp real ( kind = real64 ) :: rnz , rnm , rp1 common / specie / rnz , rnm if ( rnm > 0.5 ) then rp1 = rp * rnz / rnm rp2beta = rp1 / hypot ( EP , rp1 ) else rp1 = rp rp2beta = rp1 / hypot ( EE , rp1 ) end if end function real ( kind = real64 ) function rp2v ( rp ) real ( kind = real64 ), intent ( in ) :: rp rp2v = rp2beta ( rp ) * cspeed end function real ( kind = real64 ) function e2beta ( e ) real ( kind = real64 ), intent ( in ) :: e real ( kind = real64 ) :: rp rp = e2p ( e ) e2beta = rp2beta ( rp ) end function real ( kind = real64 ) pure function beta2gamma ( beta ) real ( kind = real64 ), intent ( in ) :: beta beta2gamma = 1.0 / dsqrt ( 1.0 - beta * beta ) end function real ( kind = real64 ) function e2gamma ( e ) real ( kind = real64 ), intent ( in ) :: e real ( kind = real64 ) :: beta beta = e2beta ( e ) e2gamma = 1.0 / dsqrt ( 1.0 - beta * beta ) end function real ( kind = real64 ) function e2v ( e ) real ( kind = real64 ), intent ( in ) :: e e2v = e2beta ( e ) * cspeed end function real ( kind = real64 ) function v2p ( v ) real ( kind = real64 ), intent ( in ) :: v v2p = beta2p ( v / cspeed ) end function real ( kind = real64 ) function beta2p ( beta ) real ( kind = real64 ), intent ( in ) :: beta real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm if ( rnm > 0.5 ) then beta2p = beta * EP / sqrt ( 1.0 - beta * beta ) * rnm / rnz else beta2p = beta * EE / sqrt ( 1.0 - beta * beta ) end if end function end module epv","tags":"","url":"sourcefile/epv.f90.html"},{"title":"datetime_utils.f90 – Fortran Program","text":"Source Code module datetime_utils use iso_fortran_env , only : real64 implicit none type gregorian_date integer :: iday ! day of the month integer :: month ! month of the year integer :: iyear ! year integer :: iyday ! year day end type contains pure logical function is_leap_year ( year ) !! returns if a function is a Gregorian leap year integer , intent ( in ) :: year is_leap_year = & mod ( year , 400 ) == 0 . or . & ( mod ( year , 4 ) == 0 . and . mod ( year , 100 ) /= 0 ) end function function seconds_of_year () result ( total_seconds ) !! return how many seconds have passed since the year started integer :: total_seconds ! how many days have passed since the start of the year at ! the start of this month. assumes leap year integer , parameter :: days_in_month ( 12 ) = [& 0 , 31 , 59 , 90 , 120 , 151 , & 181 , 212 , 243 , 273 , 304 , 334 ] integer :: datetime ( 8 ) integer :: cur_year , cur_dom , cur_doy integer :: cur_hour , cur_min , cur_sec ! get current date and time and extract values from the array call date_and_time ( values = datetime ) cur_hour = datetime ( 5 ) cur_min = datetime ( 6 ) cur_sec = datetime ( 7 ) cur_year = datetime ( 1 ) cur_dom = datetime ( 3 ) cur_doy = cur_dom + days_in_month ( datetime ( 2 )) ! if this is not a leap year take off the leap day if (. not . is_leap_year ( cur_year )) cur_doy = cur_doy - 1 total_seconds = cur_doy * 86400 + cur_hour * 3600 + cur_min * 60 + cur_sec end function subroutine caldate ( jday , iyear , iyday ) !!  This routine takes the modified Julian date and !!  converts it to a date and time string. !! !!  Calls:  GREGORIAN !-------------------------------------------------- !  Define local data. !-------------------------------------------------- ! real ( kind = real64 ), intent ( in ) :: jday !!  modified Julian day (integer) ! older output arguments !character(len=11)             :: dchar !!  date string (character) !character(len=11)             :: tchar !!  time string (character) integer , intent ( out ) :: iyday !!  year day (integer) integer , intent ( out ) :: iyear !!  year (integer) integer :: iday !!  day of the month (integer) integer :: month !!  month of the year (integer) integer :: ihour , imin , isec , julian real ( kind = real64 ) :: fjulian , hour , min character ( len = 3 ), parameter :: mchar ( 12 ) = [ & 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , & 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' ] !            original from HOPS model integer , parameter :: offset = 2440000 type ( gregorian_date ) :: gdtoday !================================================== !  Begin executable code. !================================================== ! !  Add offset to get true Julian date. julian = offset + int ( jday ) !fjulian = jday - int(jday) + 0.5 fjulian = abs ( jday - int ( jday )) if ( fjulian > 1.0 ) then julian = julian + 1 fjulian = fjulian - 1.0 end if !  Compute Gregorian date. gdtoday = gregorian ( julian ) iday = gdtoday % iday month = gdtoday % month iyear = gdtoday % iyear iyday = gdtoday % iyday !-------------------------------------------------- !  Form date and time strings. !-------------------------------------------------- hour = fjulian * 2 4.0 ihour = int ( hour ) min = ( hour - float ( ihour )) * 6 0.0 imin = int ( min ) isec = ( min - imin ) * 6 0.0 !write(dchar,\"(a3,i3,i5)\") mchar(month), iday, iyear !write(tchar,\"(i2.2,':',i2.2,':',i2.2)\") ihour, imin, isec end subroutine pure type ( gregorian_date ) function gregorian ( julian ) !!  This routine converts Julian day number to calendar (Gregorian) date. !---------------------------------------------- !  Define local data. !---------------------------------------------- integer , intent ( in ) :: julian !!     Julian day (integer) integer , parameter :: IYD ( 13 ) = [& 1 , 32 , 60 , 91 , 121 , 152 , 182 , 213 , 244 , 274 , 305 , 335 , 366 ] integer , parameter :: IYDL ( 13 ) = [& 1 , 32 , 61 , 92 , 122 , 153 , 183 , 214 , 245 , 275 , 306 , 336 , 367 ] integer , parameter :: IGREG = 2299161 ! the following parameters are from wikipedia, which is from ! Richards 2013: Explanatory Supplement to the Astronomical Almanac, 3rd ed ! and Richards 1998: Mapping Time: The Calendar and its History integer , parameter :: YGREG = 4716 , JGREG = 1401 , MGREG = 2 integer , parameter :: NGREG = 12 , RGREG = 4 , PGREG = 1461 integer , parameter :: VGREG = 3 , UGREG = 5 , SGREG = 153 integer , parameter :: WGREG = 2 , BGREG = 274277 , CGREG = - 38 integer :: iday , month , iyear , iyday integer :: f , e , g , h !============================================== !  Begin executable code. !============================================== ! all divisions here are meant to be integer divisions f = julian + JGREG + ((( 4 * julian + BGREG ) / 146097 ) * 3 ) / 4 + CGREG e = RGREG * f + VGREG g = mod ( e , PGREG ) / RGREG h = UGREG * g + WGREG iday = mod ( h , SGREG ) / UGREG + 1 month = mod ( h / SGREG + MGREG , NGREG ) + 1 iyear = ( e / PGREG ) - YGREG + ( NGREG + MGREG - month ) / NGREG !if (julian > IGREG) then !  jalpha = int((julian - 1867216 - 0.25) / 36524.25) !  ja = julian + 1 + jalpha - int(0.25 * jalpha) !else !  ja = julian !end if !jb = ja + 1524 !jc = int(6680.0 + (jb - 2439870 - 122.1) / 365.25) !jd = 365*jc + int(0.25*jc) !je = int((jb-jd) / 30.6001) !iday = jb - jd - int(30.6001*je) !month = je - 1 !if (month > 12) month = month - 12 !iyear = jc - 4715 !if (month > 2) iyear = iyear - 1 !if (iyear < 0) iyear = iyear - 1 if ( is_leap_year ( iyear )) then iyday = IYDL ( month ) + iday - 1 else iyday = IYD ( month ) + iday - 1 end if gregorian % iday = iday gregorian % month = month gregorian % iyear = iyear gregorian % iyday = iyday end function real ( kind = real64 ) function modjulianday ( year , month , day , fracday ) !! calculate the julian day from day, month, year and fraction of a day real ( kind = real64 ), intent ( in ) :: fracday integer , intent ( in ) :: day , month , year integer , parameter :: offset = 2440000 !                    original from HOPS model modjulianday = julday ( month , day , year ) - offset + fracday end function integer function julday ( mm , id , iyyy ) integer , intent ( in ) :: mm , id , iyyy integer , parameter :: IGREG = 15 + 31 * ( 10 + 12 * 1582 ) integer :: iyy integer :: jy , jm , ja if ( iyyy == 0 ) stop 'there is no year zero.' iyy = iyyy if ( iyy < 0 ) iyy = iyy + 1 if ( mm > 2 ) then jy = iyy jm = mm + 1 else jy = iyy - 1 jm = mm + 13 end if julday = int ( 36 5.25 * jy ) + int ( 3 0.6001 * jm ) + id + 1720995 if ( id + 31 * ( mm + 12 * iyy ) >= IGREG ) then ja = int ( 0.01 * jy ) julday = julday + 2 - ja + int ( 0.25 * ja ) end if end function end module datetime_utils","tags":"","url":"sourcefile/datetime_utils.f90.html"},{"title":"dmumu.f90 – Fortran Program","text":"Source Code module dmumu use iso_fortran_env , only : real64 use param , only : PI , CSPEED implicit none contains subroutine preparedmumu ( ndmumu ) integer , intent ( in ) :: ndmumu if ( ndmumu == 0 ) then call read_dmumuAH else if ( ndmumu == 1 ) then call read_dmumuBK else if ( ndmumu == 2 ) then call read_dmumuDG else stop end if end subroutine subroutine cofdu ( p , pa , beta , bm , du , ddu , ndmumu ) !   subroutine to calculate pitch angle diffusion coefficient !   and its derivative with respect to pa = cos(). real ( kind = real64 ), intent ( in ) :: p real ( kind = real64 ), intent ( in out ) :: pa real ( kind = real64 ), intent ( in ) :: beta , bm real ( kind = real64 ), intent ( out ) :: du , ddu integer , intent ( in ) :: ndmumu !real(kind=real64)                :: g0(3), b(3), a(3) if ( ndmumu == 0 ) then du = dmumuAH ( p , pa , bm , ddu ) else if ( ndmumu == 1 ) then du = dmumuBK ( p , pa , beta * CSPEED , bm , ddu ) else if ( ndmumu == 2 ) then du = dmumuDG ( beta * CSPEED , pa , ddu ) else stop end if end subroutine real ( kind = real64 ) function dmumuAH ( p , pa , bm , ddu ) real ( kind = real64 ), intent ( in ) :: p , pa , bm real ( kind = real64 ), intent ( out ) :: ddu real ( kind = real64 ) :: du0 , b1 , a1 common / dmumuAHcnst / du0 , b1 , a1 dmumuAH = du0 * p ** b1 / bm ** a1 * ( 1 - pa * pa ) if ( dmumuAH < 0 ) dmumuAH = 0.0 ddu = - 2 * du0 * p ** b1 / bm ** a1 * pa end function real ( kind = real64 ) function dmumuBK ( p , pa , v , bm , ddu ) real ( kind = real64 ), intent ( in ) :: p , pa , v , bm real ( kind = real64 ), intent ( out ) :: ddu real ( kind = real64 ) :: absmu , sgn , du00 , absmuq1sigma real ( kind = real64 ) :: du0 , b1 , a1 , qindx , sigma , h common / dmumuBKcnst / du0 , b1 , a1 , qindx , sigma , h absmu = abs ( pa ) sgn = sign_my ( pa ) absmuq1sigma = absmu ** ( qindx - 1.0 ) * ( 1.0 - sgn * sigma ) !du00 = du0 * p**(qindx-2) * v / bm**(-qindx) du00 = du0 * p ** b1 * v / bm ** a1 dmumuBK = du00 * ( 1 - pa * pa ) * ( absmuq1sigma + h ) if ( dmumuBK < 0 ) dmumuBK = 0.0 if ( pa == 0 ) then ddu = 0.0 else ddu = ( - 2.0 * ( absmuq1sigma + h ) * pa + sgn * ( qindx - 1.0 ) * absmuq1sigma / & absmu * ( 1.0 - pa * pa )) * du00 end if end function real ( kind = real64 ) pure elemental function sign_my ( x ) real ( kind = real64 ), intent ( in ) :: x if ( x > 0.0 ) then sign_my = 1.0 else if ( x < 0.0 ) then sign_my = - 1.0 else sign_my = 0.0 end if end function real ( kind = real64 ) function dmumuDG1 ( v , rmu , ddmumuDG1 ) real ( kind = real64 ), intent ( in ) :: v real ( kind = real64 ), intent ( in out ) :: rmu real ( kind = real64 ), intent ( out ) :: ddmumuDG1 real ( kind = real64 ) :: du0 , rnu , delta , va common / dmumuDGcnst / du0 , rnu , delta , va real ( kind = real64 ) :: vova , q , rr , theta vova = v / va q = rnu if ( rmu > 1.0 ) rmu = 1.0 if ( rmu < - 1.0 ) rmu = - 1.0 rr = hypot ( delta , rmu * vova ) theta = pi - dacos ( rmu * vova / rr ) if ( rmu >= 1.0 . or . rmu <= - 1.0 ) then dmumuDG1 = 0.0 else dmumuDG1 = - du0 * ( 1.0 - rmu * rmu ) * rr ** ( q - 1.0 ) * dsin (( 1 - q ) * theta ) end if if ( dmumuDG1 < 0 ) then print * , 'mu =' , rmu , ' dmumuDG1 =' , dmumuDG1 dmumuDG1 = 0.0 end if if ( 1.0 - rmu * rmu == 0.0 ) then ddmumuDG1 = 2.0 * rmu * du0 * rr ** ( q - 1.0 ) * dsin (( 1 - q ) * theta ) else ddmumuDG1 = ( & - ( 2. * rmu ) / ( 1. - rmu * rmu ) & - ( 1. - q ) / ( rr * rr ) * rmu * vova * vova & ) * dmumuDG1 & + du0 * ( 1.0 - rmu * rmu ) * rr ** ( - ( 1.0 - q )) * dcos (( 1.0 - q ) * theta ) * vova * delta / ( rr * rr ) end if end function real ( kind = real64 ) function dmumuDG ( v , rmu0 , ddmumuDG ) real ( kind = real64 ), intent ( in ) :: v real ( kind = real64 ), intent ( in out ) :: rmu0 real ( kind = real64 ), intent ( out ) :: ddmumuDG real ( kind = real64 ) :: rmu1 real ( kind = real64 ) :: ddmumuDG1 , ddmumuDG2 real ( kind = real64 ) :: d1 , d2 d1 = dmumuDG1 ( v , rmu0 , ddmumuDG1 ) rmu1 = - rmu0 d2 = dmumuDG1 ( v , rmu1 , ddmumuDG2 ) rmu0 = rmu1 dmumuDG = d1 + d2 ddmumuDG = ddmumuDG1 - ddmumuDG2 end function subroutine set_du0AH ( du0rt , du0 ) real ( kind = real64 ), intent ( in ) :: du0rt real ( kind = real64 ), intent ( in out ) :: du0 du0 = du0 * du0rt end subroutine subroutine set_du0BK ( du0rt , du0 ) real ( kind = real64 ), intent ( in ) :: du0rt real ( kind = real64 ), intent ( in out ) :: du0 du0 = du0 * du0rt end subroutine subroutine set_du0DG ( du0rt , du0 ) real ( kind = real64 ), intent ( in ) :: du0rt real ( kind = real64 ), intent ( in out ) :: du0 du0 = du0 * du0rt end subroutine subroutine read_dmumuDG real ( kind = real64 ) :: du0 , rnu , delta , va common / dmumuDGcnst / du0 , rnu , delta , va namelist / inputdmumuDG / du0 , rnu , delta , va character ( len = 256 ) :: dir common / dir / dir integer :: fileunit open ( newunit = fileunit , file = trim ( dir ) // 'inputdmumu.nml' , status = 'old' ) read ( fileunit , nml = inputdmumuDG ) close ( fileunit ) !     convert Alfven speed (km/s) to (AU/DAY) va = va * 5.76e-4 end subroutine subroutine read_dmumuAH real ( kind = real64 ) :: du0 , b1 , a1 common / dmumuAHcnst / du0 , b1 , a1 namelist / inputdmumuAH / du0 , b1 , a1 character ( len = 256 ) :: dir common / dir / dir integer :: fileunit open ( newunit = fileunit , file = trim ( dir ) // 'inputdmumu.nml' , status = 'old' ) read ( fileunit , nml = inputdmumuAH ) close ( fileunit ) end subroutine subroutine read_dmumuBK integer :: nlambda real ( kind = real64 ) :: du0 , b1 , a1 , qindx , sigma , h , rlambda common / dmumuBKcnst / du0 , b1 , a1 , qindx , sigma , h namelist / inputdmumuBK / du0 , rlambda , nlambda , b1 , a1 , qindx , sigma , h character ( len = 256 ) :: dir common / dir / dir integer :: fileunit open ( newunit = fileunit , file = trim ( dir ) // 'inputdmumu.nml' , status = 'old' ) read ( fileunit , nml = inputdmumuBK ) close ( fileunit ) end subroutine end module dmumu","tags":"","url":"sourcefile/dmumu.f90.html"},{"title":"sim3d.f90 – Fortran Program","text":"Source Code program sim3d !  Source injection at shocks !  time backward simulation to calculate fluxes at locations in IP !  pfss magnetic field model !  calculation is done in corotation reference frame !  pitch angle with outward magnetic field line !  pitch angle diffusion (symmetric D_{\\mu\\mu}) !  perpendicular diffusion added use iso_fortran_env , only : real64 , output_unit use datetime_utils , only : caldate use param , only : PI , NSPMAX , NFMAX , N_R , N_THETA , N_PHI , CSPEED , GAMMA_CS , & nseedmax , bgrid , gbgrid , b1rsgrid , epsilon use cme_cross , only : inorout , preparecme use sim3d_utils , only : f0mod , compress , solarwindtemp , split use epv , only : rp2e , e2p use fb , only : fb0 , preparefb , fs0 use mtrx , only : norm2 , vfunc , mrtx , drvbmag use loadptcl , only : prepareptcl use dmumu , only : preparedmumu use dxx , only : preparedxx , set_rlambda , set_rlambdax use file_op , only : read_maggrid , read_b1rs , read_param , record_nodes , fl_open , write_head use random , only : gasdev implicit none include 'omp_lib.h' integer , parameter :: NM1 = 16 , NMXID = 40 real ( kind = real64 ) :: rpb ( 5 ), rp0 ( 5 ) !real(kind=real64)   :: rp0org(5) real ( kind = real64 ) :: r0 ( 3 ), rb ( 3 ) real ( kind = real64 ) :: x0 ( 6 ) real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm integer :: npp , num ( 3 ) real ( kind = real64 ) :: t0 , t , tnp integer :: nsucmin common / nsucmin / nsucmin integer :: npmax common / npmax / npmax real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst integer :: ndpdt common / ndpdt / ndpdt integer :: nodr ( NSPMAX ) real ( kind = real64 ) :: t0sv ( 2 ** ( NSPMAX + 1 )), cksv ( 2 ** ( NSPMAX + 1 )) real ( kind = real64 ) :: rpbsv ( 5 , 2 ** ( NSPMAX + 1 )) common / svsp / nodr , t0sv , cksv , rpbsv real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ), allocatable :: tf (:), rf (:,:), ef (:), rmuf (:) integer :: np , nf !real(kind=real64)   :: tf(NFMAX), rf(3,NFMAX), ef(NFMAX), rmuf(NFMAX) !common /ldptcl/tf,rf,ef,rmuf,np,nf character ( len = 256 ) :: dir common / dir / dir integer :: nodes , chunk integer :: id character ( len = 2 ) :: rankstr common / rankstr / rankstr integer :: iseed integer , allocatable :: nseeds (:) real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip real ( kind = real64 ) :: trgtfs ( 4 ), sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: nsplvl real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) real ( kind = real64 ) :: b1s , gb1s ( 3 ) real ( kind = real64 ) :: bv0 ( 3 ), bm , cvtu ( 3 ), gbmag ( 3 ), bxgb2 ( 3 ), dbbds , pol real ( kind = real64 ) :: dnsk0 , dnsk00 real ( kind = real64 ) :: vsk !real(kind=real64)   :: vnr(3) real ( kind = real64 ) :: vnx ( 3 ) real ( kind = real64 ) :: vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC common / vsksw / vsksw , tauf , tauc1_0 , tauc2 , tauc2_0 , vcme0kmPs , vcme0 !LC integer :: i , j , lsp , ns real ( kind = real64 ) :: df0dmu , ddf0dmu2 real ( kind = real64 ) :: flux , dflux , flx , dflx real ( kind = real64 ) :: doy real ( kind = real64 ) :: e0 , f1 , pa0 , ck real ( kind = real64 ) :: fs , pab , hb , rate , tsp , tb real ( kind = real64 ) :: fb_ real ( kind = real64 ) :: rdf , treal , tod integer :: itjul , iyear , iyday character ( len =* ), parameter :: writefmt = \"(i1,i3,8(1pe13.5),i3)\" integer :: nfl , nsts integer :: ndmumu common / ndmumu / ndmumu integer :: ndxx common / ndxx / ndxx !real(kind=real64) :: b1rsgrid(0:N_R, 0:N_THETA, 0:N_PHI) ! dummy storage densw0 = 16641 0.0 !332820.d0 k4ok2 = 1 2.4242d0 k6ok2 = 24 2.4242d0 nodes = 1 ! default, will be read in readparm from 'dir.dat' if ( nodes > NMXID ) stop 'nodes > NMXID' chunk = 1 ! USES environment variables PARAM_OUTDIR_PATH PARAM_NODES call read_param ( nodes , nseeds ) ! USES environment variables MAGGRID_FILE call read_maggrid ( bgrid , gbgrid ) ! USES environment variables B1RS_FILE call read_b1rs ( b1rsgrid ) ! USES environment variables PTCL_FILE ! this also allocates each of the arrays call prepareptcl ( tf , rf , ef , rmuf , np , nf ) print * , \"nf = \" , nf print * , \"tf = \" , tf print * , \"np = \" , np print \"(a,i0,a)\" , \"Preparing dmumu (ndmumu = \" , ndmumu , \")\" call preparedmumu ( ndmumu ) print * , \"Finished preparing dmumu\" call preparedxx ( ndxx ) call preparefb call record_nodes ( nodes ) print * , 'nodes =' , nodes !   normalize mean free path at 1 GV e0 = rp2e ( 1.0d0 ) call set_rlambda ( e0 ) call set_rlambdax ( e0 ) ! USES environment variable CME_DATA_FILE call preparecme print * , \"tcme0 =\" , tcme0 num = 1 iseed = - 1 te = 0.0 id = 0 write ( rankstr , \"(i0.2)\" ) id call fl_open ( nfl , nsts ) call write_head ( nfl , np ) ! __LINE__ is compiler dependent, and preprocessing is required !print *, __FILE__, \":\", __LINE__, \": Finished preloop preparation\" print * , \"nf = \" , nf do i = 1 , nf print * , \"i = \" , i flx = 0.0 dflx = 0.0 tnp = 0.0 rp0 (:) = [ rf ( 1 , i ), rf ( 2 , i ) * PI / 180 , rf ( 3 , i ) * PI / 180 , e2p ( ef ( i )), rmuf ( i )] t0org = tf ( i ) ! comes from ptcl te = t0org - tcme0 !time from cme onset print * , \"te = \" , te print * , \"tdl = \" , tdl lsp = floor ( te / tdl ) print * , \"lsp = \" , lsp npp = ceiling ( 1.d0 * np * ( lsp + 1 ) / ( 2.0 ** ( lsp + 1 ) - 1 )) print * , \"npp = \" , npp flush ( output_unit ) if ( npp <= 0 ) npp = 1 sp = sp0 + ( gp - sp0 ) * log ( 1.0 + te / 18 0.0 ) !call setasgp(t0org,rp0) r0 ( 1 : 3 ) = rp0 ( 1 : 3 ) pa0 = rp0 ( 5 ) call f0mod ( r0 , pa0 , h0 , df0 , ddf0 , df0dmu , ddf0dmu2 ) call drvbmag ( r0 , bv0 , bm , cvtu , gbmag , bxgb2 , dbbds , pol , b1s , gb1s ) ! Convert spherical coordinates to Cartesian x0 ( 1 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * cos ( r0 ( 3 )) x0 ( 2 ) = r0 ( 1 ) * sin ( r0 ( 2 )) * sin ( r0 ( 3 )) x0 ( 3 ) = r0 ( 1 ) * cos ( r0 ( 2 )) call inorout ( t0org , x0 , dnsk00 , vsk , vnx ) print * , __ FILE__ , \":\" , __ LINE__ , \":\" , \"Finished calling inorout\" write ( nsts , * ) 'For flux at point' , i write ( nsts , * ) 'Time,postion,energy/n,\\mu' write ( nsts , \"(f12.5,3f11.4,e13.5,f9.5,2(1pe13.5))\" ) tf ( i ), rf (:, i ), ef ( i ), rmuf ( i ) write ( nsts , \"(' sp = ',1pe12.4,'; ap = ',1pe12.4)\" ) sp , ap write ( nsts , * ) 'number of original particles npp = ' , npp write ( nsts , * ) 'Nonzero source or boundary value list (f1)' write ( nsts , * ) 'Indicator: 0=summed,1=source,2=boundary value' write ( nsts , * ) 'List may be longer than npp due to split' !call flush(nsts) flush ( nsts ) !$OMP  PARALLEL NUM_THREADS(nodes) DEFAULT(firstprivate)& !$OMP& SHARED(rp0,h0,chunk,np,nseeds,bgrid,gbgrid,flx,dflx) !!$OMP& SHARED(cvgrid) id = OMP_GET_THREAD_NUM () iseed = nseeds ( id + 1 ) !$OMP DO SCHEDULE(DYNAMIC,chunk) REDUCTION(+:flx,dflx) do j = 1 , npp print * , \"Running step i = \" , i , \", j = \" , j ck = 0.0 fs = 0.0 nsplvl = 0 t0 = 0.0 tsp = t0 + tdl ns = 0 dnsk0 = dnsk00 if ( tsp > te ) tsp = te call walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , dnsk0 , bv0 , nsplvl ) if ( ns == - 1 . and . tsp < te ) then call split ( iseed , rpb , ck , fs , t , nsplvl , dnsk0 , bv0 , flx , dflx , walk3d , nsts ) else rb ( 1 : 3 ) = rpb ( 1 : 3 ) pab = rpb ( 5 ) call f0mod ( rb , pab , hb , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hb + h0 ) if ( ns >= 0 ) ns = 1 fb_ = fb0 ( tb , rpb ) * rate f1 = ( fs + fb_ ) / 2 ** nsplvl if ( fs > 1.d-30 ) write ( nsts , writefmt ) 0 , nsplvl , fs !if (fb_ > 1.d-30) write(nsts,writefmt) 2,nsplvl,fb_,t0org-t,rate,rpb,ns !call flush(nsts) flush ( nsts ) !OMP CRITICAL sum flx = flx + f1 dflx = dflx + f1 * f1 !OMP END CRITICAL sum end if end do !$OMP END DO !$OMP BARRIER !$OMP END PARALLEL !write(nsts,*) 'end of list' !call flush(nsts) flush ( nsts ) flux = flx / npp dflux = sqrt ( dflx ) / npp rdf = dflux / flux flux = flux * rp0 ( 4 ) ** 2 * 3e7 !flux in 1/(cm&#94;2 s sr MeV/n) dflux = dflux * rp0 ( 4 ) ** 2 * 3e7 if ( rnm > 0.5 ) then flux = flux * rnm / rnz dflux = dflux * rnm / rnz end if treal = dmapjul + tf ( i ) / 144 0.0 itjul = floor ( treal ) call caldate ( treal , iyear , iyday ) tod = treal - itjul doy = iyday + tod write ( nfl , \"(i4,f12.7,7(1pe12.4))\" ) iyear , doy , rf (:, i ), ef ( i ), rmuf ( i ), flux , dflux !call flush(nfl) flush ( nfl ) print * , \"\" end do !print *, __FILE__, \":\", __LINE__, \": Exited loop with\", i, \"runs\" close ( nfl ) close ( nsts ) contains !  random walk of energetic particles in magnetic !  variables: t, xp(5) !  x - spatial coordinators !  p - momentum !  pa - pitch angle subroutine walk3d ( iseed , rp0 , rpb , ck , fs , t0 , t , tsp , ns , dnsk0 , bv0 , nsplvl ) ! rp0,rpb = (r,theta, phi, p, pa)  theta=const, phi follows Parker spiral ! initial or boundary value integer , intent ( in out ) :: iseed real ( kind = real64 ), intent ( in ) :: rp0 ( 5 ) real ( kind = real64 ), intent ( out ) :: rpb ( 5 ) real ( kind = real64 ), intent ( in out ) :: ck , fs real ( kind = real64 ), intent ( in ) :: t0 , tsp real ( kind = real64 ), intent ( out ) :: t integer , intent ( out ) :: ns real ( kind = real64 ), intent ( in out ) :: dnsk0 , bv0 ( 3 ) integer , intent ( in ) :: nsplvl real ( kind = real64 ), parameter :: rdpmax = 100 !integer           :: id !integer           :: is(3) real ( kind = real64 ) :: xpk ( 6 ) !real(kind=real64) :: x(3), vx(3), bv(3) real ( kind = real64 ) :: r ( 3 ) real ( kind = real64 ) :: dxpkdt ( 6 ), gxw2 ( 3 ), gxw3 ( 3 ) !real(kind=real64) :: dxpkdt1(6), gxw2s(3), gxw3s(3) !real(kind=real64) :: dxpk1(6), dxpk2(6), xpk1(6) real ( kind = real64 ) :: dxpk ( 6 ) real ( kind = real64 ) :: cvtu ( 3 ), cvtu0 ( 3 ), b1s !real(kind=real64) :: gb1s(3) !real(kind=real64) :: gbmag(3), bxgb2(3) !real(kind=real64) :: culper(3), culpar(3) !real(kind=real64) :: uax1(3), uax2(3), uax3(3), uax20(3) real ( kind = real64 ) :: e ( 2 ), sqrte ( 2 ) real ( kind = real64 ) :: dw ( 3 ) !real(kind=real64) :: bw(3) !real(kind=real64) :: gb(3), gr(3,3), dgr(3), dgx(3) !real(kind=real64) :: b2x(3,3), b2r(3,3) real ( kind = real64 ) :: r2x ( 3 , 3 ) real ( kind = real64 ) :: vpl ( 3 ) !, gvpl(3,3) !real(kind=real64) :: vd(3) integer :: nlambdaconst common / nlambdaconst / nlambdaconst real ( kind = real64 ) :: densw0 , vsw , k4ok2 , k6ok2 , vom , facip , b1au , omega common / bpark / densw0 , vsw , k4ok2 , k6ok2 , omega , b1au , vom , facip integer :: ndpdt common / ndpdt / ndpdt real ( kind = real64 ) :: p , pa , p0 , pa0 , pas , hs real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: rb0 , rmax , rk , deltat , tc , tl , tmodel0 integer :: nfbconst common / fbcnst / rb0 , rmax , rk , deltat , tc , tl , tmodel0 , nfbconst real ( kind = real64 ) :: trgtfs ( 4 ), sp , sp0 , gp , ap , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: iw , n , isp , kf real ( kind = real64 ) :: df0 ( 3 ), ddf0 ( 3 , 3 ) real ( kind = real64 ) :: vsk , vnr ( 3 ), vnx ( 3 ) real ( kind = real64 ) :: rsh ( 3 ), fs1 , dt , srdt , du , densw , gper , tsh , ob , vptc real ( kind = real64 ) :: dtmax , dtmin1 , dtmin2 , dtmin3 , dtmin4 , dtmin5 real ( kind = real64 ) :: bm , amach , va , u1 , vswn , costheta2 , sintheta2 , df0dmu , ddf0dmu2 , dlt real ( kind = real64 ) :: vs , tempsw , dtsk , dxdtn , g2n , pinj , pc , rate , rbf , rprs , rshf real ( kind = real64 ) :: tempds , vthds , smach , tacc , dnsk ! e = [5e-6, 0.005] e = [ 5e-8 , 0.005 ] r ( 1 : 3 ) = rp0 ( 1 : 3 ) xpk ( 1 ) = r ( 1 ) * dsin ( r ( 2 )) * dcos ( r ( 3 )) xpk ( 2 ) = r ( 1 ) * dsin ( r ( 2 )) * dsin ( r ( 3 )) xpk ( 3 ) = r ( 1 ) * dcos ( r ( 2 )) p0 = rp0 ( 4 ) pa0 = rp0 ( 5 ) p = p0 pa = pa0 fs1 = 0.0 xpk ( 4 ) = p xpk ( 5 ) = pa xpk ( 6 ) = ck dnsk = dnsk0 t = t0 !0.0 ns = 0 !print *, \"t=\", t !ck = ck0 !0.0 n = 0 iw = 1 isp = 1 sqrte ( 1 : 2 ) = sqrt ( e ( 1 : 2 )) dt = e ( isp ) srdt = sqrte ( isp ) do while ( iw == 1 ) !write(59,\"(f14.6,12(1pe14.5))\") t,xpk,fs1,fs call vfunc ( t , xpk , dxpkdt , du , gxw2 , gxw3 , bv0 , densw , vpl , gper , b1s ) dtmax = epsilon ( 2 ) * r ( 1 ) / CSPEED dt = dtmax dtmin1 = epsilon ( 1 ) ** 2 / ( 2 * du ) if ( dt > dtmin1 ) dt = dtmin1 dtmin2 = abs ( epsilon ( 1 ) / dxpkdt ( 5 )) if ( dt > dtmin2 ) dt = dtmin2 dtmin3 = ( epsilon ( 2 ) * r ( 1 )) ** 2 / ( 2. * gper ) if ( dt > dtmin3 ) dt = dtmin3 !vptc = norm2(dxpkdt(1:3)) dtmin4 = epsilon ( 2 ) * r ( 1 ) / norm2 ( dxpkdt ( 1 : 3 )) if ( dt > dtmin4 ) dt = dtmin4 dtmin5 = epsilon ( 4 ) / abs ( dxpkdt ( 6 )) if ( dt > dtmin5 ) dt = dtmin5 !   slow down at shock !ddif2 = 16*gper*gper/vptc/vptc !if (dnsk0*dnsk0 < ddif2) then !  dtmin6 = 0.125*gper/vptc**2 !  if (dt > dtmin6) dt = dtmin6 !end if dt = dt / 2 srdt = sqrt ( dt ) !  use EM scheme dw ( 1 ) = gasdev ( iseed ) dxpk = dxpkdt * dt dxpk ( 5 ) = dxpk ( 5 ) + sqrt ( 2 * du ) * dw ( 1 ) * srdt xpk = xpk + dxpk if ( xpk ( 5 ) > 1.0 ) xpk ( 5 ) = 0.99999 if ( xpk ( 5 ) < - 1.0 ) xpk ( 5 ) = - 0.99999 !    g1,2,3 ---- kappa z,x,y !   step forward stochastic differential equation (Euler scheme) !   calculate Wiener noise for spatial diffusion dw ( 2 ) = gasdev ( iseed ) dw ( 3 ) = gasdev ( iseed ) !   calculate increments due to spatial diffusion term xpk ( 1 : 3 ) = xpk ( 1 : 3 ) + ( gxw2 ( 1 : 3 ) * dw ( 2 ) + gxw3 ( 1 : 3 ) * dw ( 3 )) * srdt t = t + dt n = n + 1 !   change the position to spheric coordinates r ( 1 ) = norm2 ( xpk ( 1 : 3 )) r ( 2 ) = dacos ( xpk ( 3 ) / r ( 1 )) r ( 3 ) = datan2 ( xpk ( 2 ), xpk ( 1 )) !  sum source tsh = t0org - t call inorout ( tsh , xpk , dnsk , vsk , vnx ) if ( dnsk0 * dnsk < 0 ) then bm = norm2 ( bv0 ) r2x = mrtx ( sin ( r ( 2 )), cos ( r ( 2 )), sin ( r ( 3 )), cos ( r ( 3 ))) vnr ( 1 : 3 ) = vnx ( 1 ) * r2x ( 1 , 1 : 3 ) + vnx ( 2 ) * r2x ( 2 , 1 : 3 ) + vnx ( 3 ) * r2x ( 3 , 1 : 3 ) ob = acos ( abs ( dot_product ( bv0 , vnr )) / bm ) vswn = sum ( vpl * vnr ) u1 = vsk - vswn !if (u1 < 0) write(*,*) 'NaN1' va = 18 7.8 * bm / sqrt ( densw ) amach = u1 / va tempsw = solarwindtemp ( r ) vs = 7.83e-6 * sqrt ( GAMMA_CS * tempsw ) smach = u1 / vs if ( amach > 1.0 ) then rsh = compress ( amach , smach , ob ) costheta2 = cos ( ob ) ** 2 sintheta2 = 1 - costheta2 rshf = 1 do kf = 1 , 3 rbf = rsh ( kf ) * ( amach * amach - costheta2 ) / ( amach * amach - rsh ( kf ) * costheta2 ) if ( rbf > 1.0000001d0 . and . rsh ( kf ) > 1.0000001d0 ) rshf = rsh ( kf ) end do rprs = 1 + GAMMA_CS * smach * smach * ( rshf - 1 ) / rshf * ( 1 - rshf * sintheta2 * (( rshf + 1 )& * amach * amach - 2 * rshf * costheta2 ) / 2 / ( amach * amach - rshf * costheta2 ) ** 2 ) tempds = tempsw / rshf * rprs vthds = 7.83e-6 * sqrt ( 2 * tempds ) !    vthds ~ Vsh due to shock heating (mainly protons) if ( dxpkdt ( 4 ) > 0 ) then tacc = xpk ( 4 ) / dxpkdt ( 4 ) else tacc = 1e10 end if dtsk = tsh - tcme0 if ( tacc > dtsk ) tacc = dtsk fs1 = fs0 ( tacc , xpk , bm , u1 , densw , ob , amach , rshf , vthds , pinj , pc ) pas = xpk ( 5 ) ck = xpk ( 6 ) call f0mod ( r , pas , hs , df0 , ddf0 , df0dmu , ddf0dmu2 ) rate = exp ( ck - hs + h0 ) g2n = gper * sin ( ob ) ** 2 dxdtn = dxpkdt ( 1 ) * vnx ( 1 ) + dxpkdt ( 2 ) * vnx ( 2 ) + dxpkdt ( 3 ) * vnx ( 3 ) dlt = abs ( dnsk ) / ( g2n + dxdtn ** 2 * dt / 2 ) fs = fs + fs1 * dlt * rate !   output to analyze source injection profiles !if (fs1 > 0.0) then !  write(nsts,\"(i1,i3,8(1pe13.5),i3)\") 1,nsplvl,dtsk,xpk,fs1,rate,dlt,u1,amach,smach,ob !end !   if local shock acceleration injection cutoff, add to p instead of source if ( pc < xpk ( 4 )) xpk ( 4 ) = xpk ( 4 ) * ( 1 - u1 * ( 1 - 1 / rshf ) / 3 * dlt ) end if end if dnsk0 = dnsk if (( xpk ( 4 ) < rp0 ( 4 ) / rdpmax ) . or . ( xpk ( 4 ) > rdpmax * rp0 ( 4 ))) then iw = 0 ns = - 2 end if if ( r ( 1 ) > rmax ) then iw = 0 ns = - 3 end if if ( r ( 1 ) < rb0 ) then iw = 0 ns = n end if if ( t > tsp ) then iw = 0 ns = - 1 end if if ( t > te ) then iw = 0 ns = - 4 end if end do rpb ( 1 : 3 ) = r ( 1 : 3 ) rpb ( 4 : 5 ) = xpk ( 4 : 5 ) ck = xpk ( 6 ) end subroutine end program","tags":"","url":"sourcefile/sim3d.f90.html"},{"title":"mtrx.f90 – Fortran Program","text":"Source Code module mtrx use iso_fortran_env , only : real64 use param , only : CSPEED , N_R , N_THETA , N_PHI , pi , twopi use epv , only : rp2beta use dxx , only : cofm use dmumu , only : cofdu use file_op , only : open_file_from_environment implicit none contains ! delete this function when the fortran 2008 standards are supported real ( kind = real64 ) function norm2 ( arr ) real ( kind = real64 ), intent ( in ) :: arr (:) norm2 = sqrt ( sum ( arr * arr )) end function norm2 function cartesian2spherical ( x ) result ( r ) real ( kind = real64 ), intent ( in ) :: x ( 3 ) real ( kind = real64 ), intent ( out ) :: r ( 3 ) r ( 1 ) = norm2 ( x ) r ( 2 ) = acos ( x ( 3 ) / r ( 1 )) ! acos(z/r) r ( 3 ) = atan2 ( x ( 2 ), x ( 1 )) ! atan(y/x) end function function spherical2cartesian ( r ) result ( x ) real ( kind = real64 ), intent ( in ) :: r ( 3 ) real ( kind = real64 ), intent ( out ) :: x ( 3 ) cartesian ( 1 ) = r ( 1 ) * sin ( r ( 2 )) * cos ( r ( 3 )) ! r sin(theta) cos(phi) cartesian ( 2 ) = r ( 1 ) * sin ( r ( 2 )) * sin ( r ( 3 )) ! r sin(theta) sin(phi) cartesian ( 3 ) = r ( 1 ) * cos ( r ( 2 )) ! r cos(theta) end function function mxptr ( gm ) result ( xptr ) !  calculate matrix for xyz' ellipsoid coordinate Kwon to spheric real ( kind = real64 ), intent ( in ) :: gm real ( kind = real64 ) :: xptr ( 3 , 3 ) real ( kind = real64 ) :: sing , cosg sing = sin ( gm ) cosg = cos ( gm ) xptr ( 1 ,:) = [ 0.d0 , 0.d0 , 1.d0 ] xptr ( 2 ,:) = [ cosg , - sing , 0.d0 ] xptr ( 3 ,:) = [ sing , cosg , 0.d0 ] end function function dmxptr ( gm , dgm ) !  calculate matrix for xyz' ellipsoid coordinate Kwon to spheric real ( kind = real64 ), intent ( in ) :: gm , dgm real ( kind = real64 ) :: dmxptr ( 3 , 3 ) real ( kind = real64 ) :: sing , cosg sing = sin ( gm ) cosg = cos ( gm ) dmxptr ( 1 ,:) = [ 0.d0 , 0.d0 , 0.d0 ] dmxptr ( 2 ,:) = [ - sing * dgm , - cosg * dgm , 0.d0 ] dmxptr ( 3 ,:) = [ cosg * dgm , - sing * dgm , 0.d0 ] end function function mbtr ( uax1 , uax2 , uax3 ) result ( b2r ) !  calculate martix from magnetic to polar spheric coordinates real ( kind = real64 ), intent ( in ) :: uax1 ( 3 ), uax2 ( 3 ), uax3 ( 3 ) real ( kind = real64 ) :: b2r ( 3 , 3 ) b2r (:, 1 ) = uax1 (:) b2r (:, 2 ) = uax2 (:) b2r (:, 3 ) = uax3 (:) end function function mrtx ( sintheta , costheta , sinphi , cosphi ) !  calculate martix from polar spheric to xyz coordinates real ( kind = real64 ), intent ( in ) :: sintheta , costheta , sinphi , cosphi real ( kind = real64 ) :: mrtx ( 3 , 3 ) mrtx ( 1 ,:) = [ sintheta * cosphi , costheta * cosphi , - sinphi ] mrtx ( 2 ,:) = [ sintheta * sinphi , costheta * sinphi , cosphi ] mrtx ( 3 ,:) = [ costheta , - sintheta , 0.d0 ] end function function dmrtx ( sintheta , costheta , sinphi , cosphi , dtheta , dphi ) !  calculate martix from polar spheric to xyz coordinates real ( kind = real64 ), intent ( in ) :: sintheta , costheta , dtheta real ( kind = real64 ), intent ( in ) :: sinphi , cosphi , dphi real ( kind = real64 ) :: dmrtx ( 3 , 3 ) dmrtx ( 1 , 1 ) = costheta * dtheta * cosphi - sintheta * sinphi * dphi dmrtx ( 1 , 2 ) = - sintheta * dtheta * cosphi - costheta * sinphi * dphi dmrtx ( 1 , 3 ) = - cosphi * dphi dmrtx ( 2 , 1 ) = costheta * dtheta * sinphi + sintheta * cosphi * dphi dmrtx ( 2 , 2 ) = - sintheta * dtheta * sinphi + costheta * cosphi * dphi dmrtx ( 2 , 3 ) = - sinphi * dphi dmrtx ( 3 , 1 ) = - sintheta * dtheta dmrtx ( 3 , 2 ) = - costheta * dtheta dmrtx ( 3 , 3 ) = 0.0 end function ! trilinear interpolation function trilinear ( phic , x ) result ( phi ) !  phic the value of phi at the corner of cubic box of side 1 real ( kind = real64 ), intent ( in ) :: phic ( 2 , 2 , 2 ) !  location inside the cube (0<=x<=1) or outside x<0 x>1 real ( kind = real64 ), intent ( in ) :: x ( 3 ) !  phi(1)=interpolated phi real ( kind = real64 ) :: phi phi = phic ( 1 , 1 , 1 ) * ( 1 - x ( 1 )) * ( 1 - x ( 2 )) * ( 1 - x ( 3 )) & + phic ( 2 , 1 , 1 ) * x ( 1 ) * ( 1 - x ( 2 )) * ( 1 - x ( 3 )) & + phic ( 1 , 2 , 1 ) * ( 1 - x ( 1 )) * x ( 2 ) * ( 1 - x ( 3 )) & + phic ( 1 , 1 , 2 ) * ( 1 - x ( 1 )) * ( 1 - x ( 2 )) * x ( 3 ) & + phic ( 2 , 1 , 2 ) * x ( 1 ) * ( 1 - x ( 2 )) * x ( 3 ) & + phic ( 1 , 2 , 2 ) * ( 1 - x ( 1 )) * x ( 2 ) * x ( 3 ) & + phic ( 2 , 2 , 1 ) * x ( 1 ) * x ( 2 ) * ( 1 - x ( 3 )) & + phic ( 2 , 2 , 2 ) * x ( 1 ) * x ( 2 ) * x ( 3 ) end function function trilineardif ( phic , x ) result ( dphi ) !  phic the value of phi at the corner of cubic box of side 1 real ( kind = real64 ), intent ( in ) :: phic ( 2 , 2 , 2 ) !  location inside the cube (0<=x<=1) or outside x<0 x>1 real ( kind = real64 ), intent ( in ) :: x ( 3 ) ! dphi(1)=dphi/dx, dphi(2)=dphi/dy, dphi(3)=dphi/dz real ( kind = real64 ) :: dphi ( 3 ) dphi ( 1 ) = ( phic ( 2 , 1 , 1 ) - phic ( 1 , 1 , 1 )) * ( 1 - x ( 2 )) * ( 1 - x ( 3 )) & + ( phic ( 2 , 2 , 1 ) - phic ( 1 , 2 , 1 )) * x ( 2 ) * ( 1 - x ( 3 )) & + ( phic ( 2 , 1 , 2 ) - phic ( 1 , 1 , 2 )) * ( 1 - x ( 2 )) * x ( 3 ) & + ( phic ( 2 , 2 , 2 ) - phic ( 1 , 2 , 2 )) * x ( 2 ) * x ( 3 ) dphi ( 2 ) = ( phic ( 1 , 2 , 1 ) - phic ( 1 , 1 , 1 )) * ( 1 - x ( 1 )) * ( 1 - x ( 3 )) & + ( phic ( 2 , 2 , 1 ) - phic ( 2 , 1 , 1 )) * x ( 1 ) * ( 1 - x ( 3 )) & + ( phic ( 1 , 2 , 2 ) - phic ( 1 , 1 , 2 )) * ( 1 - x ( 1 )) * x ( 3 ) & + ( phic ( 2 , 2 , 2 ) - phic ( 2 , 1 , 2 )) * x ( 1 ) * x ( 3 ) dphi ( 3 ) = ( phic ( 1 , 1 , 2 ) - phic ( 1 , 1 , 1 )) * ( 1 - x ( 1 )) * ( 1 - x ( 2 )) & + ( phic ( 2 , 1 , 2 ) - phic ( 2 , 1 , 1 )) * x ( 1 ) * ( 1 - x ( 2 )) & + ( phic ( 1 , 2 , 2 ) - phic ( 1 , 2 , 1 )) * ( 1 - x ( 1 )) * x ( 2 ) & + ( phic ( 2 , 2 , 2 ) - phic ( 2 , 2 , 1 )) * x ( 1 ) * x ( 2 ) end function end module mtrx","tags":"","url":"sourcefile/mtrx.f90.html"},{"title":"average.f90 – Fortran Program","text":"Source Code program average use ieee_arithmetic , only : ieee_is_nan use iso_fortran_env , only : real64 implicit none real ( kind = real64 ) :: t , fl , fl2 real ( kind = real64 ) :: ar ( 9 ) integer :: na , i na = 0 do i = 1 , 6 read ( * , * ) enddo do while ( t > - 10 ) read ( * , * ) t , ar !if (ar(7) * ar(7) >= 0) then ! nan testing if (. not . ieee_is_nan ( ar ( 7 ))) then na = na + 1 fl = ar ( 7 ) + fl fl2 = ar ( 7 ) ** 2 + fl2 end if end do print * , fl / na , sqrt ( fl2 ) / na stop end program","tags":"","url":"sourcefile/average.f90.html"},{"title":"loadptcl.f90 – Fortran Program","text":"Source Code module loadptcl use iso_fortran_env , only : real64 !use param,           only: CSPEED!, NFMAX !use epv,             only: rp2e, rp2beta !use dxx,             only: get_rlambda0, cofm !use mtrx,            only: drvbmag use file_op , only : open_file_from_environment implicit none contains subroutine prepareptcl ( tf , rf , ef , rmuf , np , nf ) ! USES environment variables !     PTCL_FILE !real(kind=real64) :: tf(NFMAX), rf(3,NFMAX), ef(NFMAX), rmuf(NFMAX) real ( kind = real64 ), intent ( out ), allocatable :: tf (:), rf (:,:), ef (:), rmuf (:) integer :: np , nf !common/ldptcl/tf,rf,ef,rmuf,np,nf real ( kind = real64 ) :: t0org , te , tdl , dmapjul , tcme0 common / tmprm / t0org , te , tdl , dmapjul , tcme0 character ( len = 256 ) :: dir common / dir / dir real ( kind = real64 ) :: rnz , rnm common / specie / rnz , rnm real ( kind = real64 ) :: sp0 , gp , ap real ( kind = real64 ) :: trgtfs ( 4 ) real ( kind = real64 ) :: sp , scanw , h0 common / srcmod / sp , sp0 , gp , ap , trgtfs , scanw , h0 integer :: i integer :: ptcl_fileunit call open_file_from_environment ( \"PTCL_FILE\" , ptcl_fileunit , \"FORMATTED\" ) !open(newunit=ptcl_fileunit, file=trim(dir)//'loadptcl.dat') read ( ptcl_fileunit , * ) ! sp0, gp, ap header line read ( ptcl_fileunit , * ) sp0 , gp , ap read ( ptcl_fileunit , * ) ! header line for tdl read ( ptcl_fileunit , * ) tdl read ( ptcl_fileunit , * ) ! another header line (rnz, rnm) read ( ptcl_fileunit , * ) rnz , rnm read ( ptcl_fileunit , * ) ! you guessed it, header (nf, np) read ( ptcl_fileunit , * ) nf , np allocate ( tf ( nf ), rf ( 3 , nf ), ef ( nf ), rmuf ( nf )) read ( ptcl_fileunit , * ) ! headers yay (time, r(3), ...) do i = 1 , nf read ( ptcl_fileunit , * ) tf ( i ), rf (:, i ), ef ( i ), rmuf ( i ) end do close ( ptcl_fileunit ) end subroutine !subroutine setasgp(t0,rp0) !  implicit none !  real(kind=real64) :: rp0(5), t0 !  real(kind=real64) :: r(3), r2(3) !  real(kind=real64) :: bv(3), g2(3), dg2(3,3) !  real(kind=real64) :: cvtu(3), gbmag(3), bxgb2(3), pol !  real(kind=real64) :: sp0, gp, ap !  real(kind=real64) :: trgtfs(4) !  real(kind=real64) :: sp, scanw, h0 !  common /srcmod/sp,sp0,gp,ap,trgtfs,scanw,h0 !  real(kind=real64) :: p2, beta2 !  real(kind=real64) :: tanp, sqr1p, dl !  real(kind=real64) :: bm, dbbds, b1s, gb1s(3) !  real(kind=real64) :: et1, rlambda1, rd, pa2, bm2 !  ! set up parameters in f0mod to adjust artificial drift !  !  gp: order of pitch-angle anisotropy (typically arround 1.0) !  !  sp: inverse of pitch-angle anisotropy amplitude (>1.0) !  !  ap: lateral (lat-long) angular width of distribution !  gp = 1.0 !  !  use radial diffusion to estimate pitch-angle anisotropy amplitude !  r(1:3) = rp0(1:3) !  p2 = rp0(4) !  beta2 = rp2beta(p2) !  call drvbmag(r, bv, bm, cvtu, gbmag, bxgb2, dbbds, pol, b1s, gb1s) !  tanp = abs(bv(3)/bv(1)) !  sqr1p = sqrt(1+tanp*tanp) !  dl = r(1) / 2 * (sqr1p + log(tanp+sqr1p) / tanp) !  sp = 9*dl / (t0*beta2*CSPEED) !  if (sp > 0.9) sp = 0.9 !  sp = 1/sp !  sp = 4.0 !  !  estimate the radial diffusion !  et1 = rp2e(p2) !  rlambda1 = get_rlambda0(et1) !  rd = sqrt(1.5 * t0 * rlambda1 * beta2 * CSPEED/3.) !  !  perpendicular diffusion at half rd !  r2(1) = rd !  r2(2) = r(2) !  r2(3) = r(3) !  pa2 = rp0(5) !  call drvbmag(r, bv, bm2, cvtu, gbmag, bxgb2, dbbds, pol, b1s, gb1s) !  call cofm(r2, p2, pa2, beta2, bv, bm2, cvtu, gbmag, dbbds, b1s, gb1s, g2, dg2) !  !  estimate angular radius of perpendicular diffusion !  ap = sqrt(1.5*t0*g2(2)/(rd)**2) !  tanp = abs(bv(3)/bv(1)) !  sqr1p = sqrt(1+tanp*tanp) !  ap = ap*sqr1p !  ap = 1e20 !end subroutine end module","tags":"","url":"sourcefile/loadptcl.f90.html"}]}